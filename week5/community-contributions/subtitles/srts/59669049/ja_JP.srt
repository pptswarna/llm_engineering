WEBVTT

00:00.860 --> 00:12.650
つまり､ 最終的にデプロイするアプリを選ぶ前にテストするための一時的なアプリということです｡

00:12.680 --> 00:16.520
エフェメラル・アプリにはもう少し長く付き合うつもりだ｡

00:16.520 --> 00:24.380
前回構築した独自モデルをエフェメラル・アプリとしてデプロイしてから､ 実際にデプロイするつもりだからだ｡

00:24.380 --> 00:31.460
そのために､ Pricer ephemeralというファイルをお見せしよう｡  Pythonのモジュールで､ 先ほど見たものと似ている部分もありますが､

00:31.490 --> 00:43.910
1つだけ重要な違いがあります｡

00:43.910 --> 00:43.910
1､

00:43.910 --> 00:50.990
推論でモデルを実行し､ それをテストしていたときにコードラボで使用したコードと非常によく似たコードを使用して､

00:50.990 --> 00:54.830
独自の微調整を行ったモデルを使用します｡

00:54.830 --> 01:03.380
このPythonモジュールでは､ まず前回と同じようにmodalをインポートします｡ 

01:03.620 --> 01:06.590
そしてまた､ ボリュームを取り除く｡ 

01:06.800 --> 01:09.650
一時はそれを使うつもりだったが､ 結局使わなかった｡ 

01:10.160 --> 01:14.240
つまり､ アプリを立ち上げるわけだ｡ 

01:14.240 --> 01:15.260
プライサーと呼ばれている｡ 

01:15.290 --> 01:16.760
それが､ あなたが見たアプリの名前になる｡ 

01:16.790 --> 01:17.630
プライサー

01:18.020 --> 01:20.510
以前､ 私のプリサーの展開版を見ただろう｡ 

01:20.810 --> 01:25.640
次に､ イメージを作成して､ 同じパッケージをインストールします｡ 

01:25.640 --> 01:27.410
だが待ってくれ､ 新しいパッケージがある｡ 

01:27.410 --> 01:38.060
微調整したウェイトと秘密をロードできるようにするために必要な､ パラメーター効率の良い微調整パッケージを覚えているだろう｡

01:38.060 --> 01:42.890
願わくば､ それらを加える方法を見つけて､ HFシークレットの下に置くべきだ｡ 

01:42.890 --> 01:47.210
あるいは､ もしそれを他のものの下に置くのであれば､ 明らかにここの名前を変えてください｡ 

01:47.210 --> 01:50.030
それが秘密のカテゴリーの名前だ｡ 

01:50.030 --> 01:57.650
そしてその中に､ 通常のHFアンダースコア・トークンを抱きしめて､ トークンそのものを抱きしめていなければならない｡

01:58.040 --> 02:00.480
ええと､ それが実際にコードのどこかにあるかどうか確認してください｡ 

02:00.510 --> 02:02.070
それはないと思う｡ 

02:06.390 --> 02:13.740
T4GPUが欲しいと指定する｡ 

02:13.770 --> 02:16.200
もちろんベースモデルは指定する｡ 

02:16.230 --> 02:17.850
ラマ 3. 180億ドル

02:18.060 --> 02:19.620
ええと､ プロジェクト名です｡ 

02:19.620 --> 02:22.980
これは､ ハギング・フェイスのハブから引っ張ってくるからだ｡ 

02:23.280 --> 02:25.860
これが僕のハグする顔のユーザーネームなんだ｡ 

02:25.860 --> 02:30.000
私の訓練されたバージョンを使いたいのであれば､ そこに私の名前を残しておいてほしい｡ 

02:30.000 --> 02:35.130
もし､ あなたが自分のバージョンを使いたいのであれば､ そのバージョンを微調整し､ もしかしたらさらに良くするかもしれないからだ｡ 

02:35.130 --> 02:41.370
もしかしたらハイパーパラメーターの最適化をやっていて､ 私に勝ったのかもしれない｡

02:41.520 --> 02:44.850
うーん､ でもこれは僕のものだし､ 僕のものを使うなら､ そのランネームを使うべきだよ｡ 

02:44.850 --> 02:51.870
そしてこのリビジョン番号は､ オーバーフィットを始める前の､ 私が最高の結果を得たエポックだったことを覚えているだろう｡

02:51.870 --> 02:56.250
こうして､ 微調整されたモデル名で終わる｡ 

02:56.250 --> 03:00.030
そうして､ シンプルな関数価格を手に入れた｡ 

03:00.030 --> 03:04.980
これは､ グーグル・コラボにあった機能とほとんど同じものだ｡ 

03:05.190 --> 03:16.200
これをローカル・ボックスに置いて､ このデコレーターでデコレーションするんだ｡

03:16.290 --> 03:20.340
しかし､ これはすべて同じものだ｡ 

03:20.370 --> 03:21.990
輸入も行っている｡ 

03:22.380 --> 03:24.720
その質問と接頭辞に注目したい｡ 

03:25.230 --> 03:28.860
1ドル単位でいくらですか？

03:28.890 --> 03:32.580
次に商品の説明､ そして価格がドル表示される｡ 

03:32.580 --> 03:37.920
そうなると､ モデルにとって､ 価格がいくらなのか答えないのはほとんど耐え難いことになる｡ 

03:38.340 --> 03:41.550
そして､ ここで量子化を行う｡ 

03:41.550 --> 03:44.160
先ほどと同じようにモデルをロードする｡ 

03:44.160 --> 03:46.980
そして､ このセリフを覚えていてほしい｡ 

03:46.980 --> 03:51.540
ここでローラのファインチューン・モデルをロードする｡ 

03:51.540 --> 03:53.400
私たちはベースモデルを提供する｡ 

03:53.400 --> 03:57.640
微調整されたモデルの名前と､ この場合はリビジョン番号を提供する｡ 

03:57.640 --> 04:01.030
最終的なセーブを取るだけなら､ それは外してもいい｡ 

04:01.030 --> 04:02.980
中間点を取る必要はない｡ 

04:02.980 --> 04:04.090
私のあり方｡ 

04:04.810 --> 04:06.670
これは再現性のためだ｡ 

04:06.670 --> 04:08.560
ランダムシードが設定されるように｡ 

04:08.590 --> 04:12.130
だから､ トークン化するたびに同じ数字が得られる｡ 

04:12.340 --> 04:19.570
そして､ 微調整したモデルにドットジェネレーションのコールをかけ､ デコードする｡ 

04:19.570 --> 04:22.840
そして最後に､ 願わくばこのコードも認識していただきたい｡ 

04:22.840 --> 04:29.440
これは､ 戻ってくるテキストから浮動小数点数を取り除く､

04:29.470 --> 04:39.700
ちょっとしゃれたコードで､ ドル記号などが間違っている場合に備えている｡

04:39.730 --> 04:42.970
この時点では､ かなり見慣れたコードになっているはずだ｡ 

04:42.970 --> 04:44.950
では､ ここに戻ろう｡ 

04:45.130 --> 04:48.640
ええと､ ウォームアップが必要だから､ 前と同じように走らせたんだ｡ 

04:48.640 --> 04:49.840
数分かかる｡ 

04:49.840 --> 04:52.180
だから､ 毎回待たされるのは苦痛だ｡ 

04:52.180 --> 04:53.620
でも､ もう走ったんだ｡ 

04:53.650 --> 04:55.700
もちろん､ これは私が走ったものだ｡ 

04:56.480 --> 05:00.470
モーダルイネーブル出力で実際にこれを持つ必要はない､ とあなたは言う｡ 

05:00.470 --> 05:04.550
でも､ もしそうしなければ､ 他にもたくさんのプリントがある｡ 

05:04.550 --> 05:07.730
だから､ これはすっきりとした形にする方法なんだ｡ 

05:08.030 --> 05:10.700
でも､ アプリのドットランは必要だよ｡ 

05:10.940 --> 05:14.000
ええと､ それから､ 結果は遠隔地での価格だと言うだけだ｡ 

05:14.000 --> 05:22.790
そして､ 私が求めているのは､ ある特定のものに値段をつけることです｡

05:22.790 --> 05:27.140
そして､ 私が値付けを依頼した対象は､ まさにここで私が話しているマイクだ｡ 

05:27.140 --> 05:29.690
だから､ そこに入力したんだ｡ 

05:29.690 --> 05:31.130
いくらかかったか覚えている｡ 

05:31.160 --> 05:31.940
なぜそうしないのか？

05:31.940 --> 05:34.490
それを見積もってどうなるか見てみよう｡ 

05:34.670 --> 05:35.900
それで走ったんだ｡ 

05:35.930 --> 05:37.190
数分かかったよ｡ 

05:37.220 --> 05:42.710
このボックスをウォームアップして､ いろいろなものを入力しなければならないので､

05:42.800 --> 05:47.090
2､ 3分かかります｡

05:47.090 --> 05:50.600
Huggingfaceのハブからダウンロードして､ それをメモリにロードしなければならない｡ 

05:50.810 --> 05:54.020
ええと､ これらのパッケージをすべてpipでインストールする必要があります｡ 

05:54.020 --> 05:57.230
だから､ たくさんのことが起こらなければならないし､ だから少し時間がかかるんだ｡ 

05:57.410 --> 06:04.370
ええと､ それでいろいろやって､ 最後には完了して､ 1番､ 33番､ 133ドルを返した｡ 

06:04.370 --> 06:06.770
そして､ それがこの費用の相場だと思う｡ 

06:06.770 --> 06:13.790
だから､ ああ､ そうだね､ うん､ たぶん､ その通りだと思う｡ 

06:13.790 --> 06:14.180
誰が知っている？

06:14.180 --> 06:18.530
トレーニングデータセットの中にあったかもしれないが､ まあ､ 確かにいい結果だ｡ 

06:19.220 --> 06:22.670
だから願わくば､ これを試してみてほしい｡ 

06:22.670 --> 06:24.980
2分､ 2分､ 3分待たなければならない｡ 

06:24.980 --> 06:29.540
そうしているうちにモーダルにも行けるようになるし､ エフェメラルアプリにも行けるようになる｡ 

06:29.630 --> 06:33.320
今はもう稼働していないが､ 稼働している間はここにいて､

06:33.320 --> 06:40.850
その様子を見て､ 納得のいく結果を得ることができるだろう｡

06:41.150 --> 06:41.780
オーケー｡ 

06:41.780 --> 06:48.560
しかし､ それが終わった今､ リモートで機能を実行する方法に過ぎないエフェメラルなアプリから移行する時が来た｡

06:48.560 --> 06:58.310
デプロイされたアプリは､ いくつかの機能があり､ それを常設したいことをModellに伝えます｡

06:58.340 --> 07:09.230
しかし､ 私たちはこのプロジェクトに名前をつけ､ 必要なときにすぐに戻れるような適切な場所を作りたいと考えています｡

07:09.650 --> 07:17.690
コマンドラインでmodelと入力するんだ｡  deployとデプロイしたいアプリの名前を入力する｡

07:17.960 --> 07:24.260
データサイエンティストとして構築したコードやモデルを､

07:24.260 --> 07:31.550
本番で使えるようにデプロイしているのだ｡

07:31.550 --> 07:33.740
PythonのAPIを使う予定だ｡ 

07:33.740 --> 07:40.220
人々はPythonからこのAPIを呼び出すことができ､ APIを呼び出すことができる｡ 

07:40.460 --> 07:47.540
これはJupyterLabに元々組み込まれているプロダクション化の例です｡ 

07:47.930 --> 07:55.450
モーダルは､ Pythonから呼び出される必要がないように､ 非常に簡単にRestエンドポイントを構築することもできます｡

07:55.450 --> 08:00.070
どのようなHTTPクエリからでも呼び出すことができる｡ 

08:00.250 --> 08:03.610
このクラスでは､ Pythonを使うので､ Pythonについては扱いません｡ 

08:03.610 --> 08:05.980
だから､ Pythonから呼び出せばいいのだ｡ 

08:06.010 --> 08:09.160
でも､ それはとても簡単なことだし､ ドキュメントにもはっきり書いてある｡ 

08:09.700 --> 08:14.710
それで､ ちょっと前に話したことなんだけど､ もう知っているかもしれないね｡ 

08:14.710 --> 08:23.080
ジュピターには､ 感嘆符を押すだけでターミナルで何かを実行できる素晴らしい機能があるんだ｡

08:23.080 --> 08:26.920
そして､ 実行したいコマンドの名前を入力する｡ 

08:26.920 --> 08:32.170
プラスボタンを押してターミナル・ウィンドウを開き､ ターミナルを作成することもできる｡

08:32.170 --> 08:36.640
ええと､ でもこれはもっと簡単で､ このプロンプトの中でできるんです｡ 

08:36.640 --> 08:41.710
コマンドはモーダルデプロイで､ 次にパッケージ名を指定する｡ 

08:41.710 --> 08:43.510
つまり､ プライスレスなサービスなんだ｡ 

08:43.510 --> 08:46.480
では､ サービス価格というパッケージを見てみよう｡ 

08:46.510 --> 08:48.340
早速だが､ ここで私が得たものを紹介しよう｡ 

08:48.370 --> 08:53.280
だから......驚くほど似ているんだ｡ 

08:53.550 --> 09:00.300
基本的には､ 定数があり､ 関数が定義され､

09:00.300 --> 09:15.990
基本的には同じことなのですが､ これでコードをサービスとしてデプロイするのに十分なのです｡

09:16.140 --> 09:18.150
でも､ 同じことだよ｡ 

09:18.150 --> 09:21.900
パッケージが違うだけで､ 同じコードだ｡ 

09:21.900 --> 09:24.720
そしてまた､ このボリュームではその必要はない｡ 

09:25.080 --> 09:34.470
初日のノートブックに戻ると､ プライスのサービスとしてデプロイされているのがわかる｡

09:34.710 --> 09:37.530
ええと､ 最後に小さなURLが表示されるんだ｡ 

09:37.800 --> 09:45.450
それが終わったら､ ここに戻ってアプリの配置に行くと､ 価格が表示されているのがわかると思う｡

09:45.660 --> 09:50.830
T4のGPUボックスの上に座っている｡ 

09:50.860 --> 09:57.970
ここで話を戻すと､ デプロイされたアプリを呼び出す方法は､ エフェメラル・アプリとは異なり､ 実はシンプルだ｡

09:58.000 --> 09:58.900
それは必要ない｡ 

09:58.900 --> 10:01.870
さっきの足場｡ 

10:01.900 --> 10:10.690
その代わりに､ モーダル・ドット・ファンクション､ ドット・ルックアップと言い､ サービス名とファンクション名を指定する｡

10:10.720 --> 10:11.800
単純なことだ｡ 

10:11.800 --> 10:12.760
モーダルドット機能｡ 

10:12.790 --> 10:15.430
サービスと機能をドット検索する｡ 

10:15.700 --> 10:22.120
そうしたら､ price dot remoteと言って､ リモート・コールができる｡ 

10:22.120 --> 10:25.120
そして､ 同じ133という数字が返ってきた｡ 

10:25.120 --> 10:26.350
それがすべてだ｡ 

10:26.380 --> 10:34.480
私たちは､ 独自モデルのアプリをクラウドにデプロイし､ それを呼び出してクラウド上で実行したところです｡

10:35.470 --> 10:39.910
もっといい方法があるんだ｡ 

10:39.910 --> 10:45.400
このように作ると､ スリープして再び温める必要があるたびに､

10:45.400 --> 10:49.300
1､ 2分後にはスリープしてしまう｡

10:49.810 --> 10:56.290
そのため､ 呼び出すたびに余分な時間を待たされ､ 基本的には毎回､ 画像を再構築し､

10:56.290 --> 11:02.230
インポートを行い､ モデルをロードしなければならない｡

11:02.560 --> 11:03.340
あの､ すみません｡ 

11:03.370 --> 11:05.800
その必要がないバージョンにジャンプしたんだ｡ 

11:05.800 --> 11:06.340
さあ､ 始めよう｡ 

11:06.370 --> 11:09.340
これはそのすべてをやらなければならない悪いバージョンだ｡ 

11:09.430 --> 11:11.560
だから､ 第2バージョンを作ったんだ｡ 

11:11.560 --> 11:13.780
価格は2π｡ 

11:13.810 --> 11:19.000
このモジュールは......そしてこのモジュールは､ もう少しスマートな方法で作られている｡ 

11:19.000 --> 11:28.300
これはクラスを使って行われ､ 初期化のいくつかの側面を事前に構築することができる｡

11:28.300 --> 11:30.130
だから毎回やる必要はない｡ 

11:30.430 --> 11:39.250
このようなクラスを定義すると､ このデコレーター・モデルのドットビルドを使用して､ 最初にボックスをビルドしたときに､

11:39.250 --> 11:45.820
そのボックスにデータを入力する関数を書くことができます｡

11:46.000 --> 11:51.140
この場合､ 私はhuggingfaceからモデルをダウンロードし､ それをキャッシュに入れる｡ 

11:51.290 --> 11:54.950
時間の都合上､ 練習として残しておくが､

11:54.950 --> 11:59.030
これは完全に自明なことだ｡

11:59.180 --> 12:05.720
このコードはHuggingfaceからファイルをロードし､ Huggingfaceのキャッシュに置く｡ 

12:05.990 --> 12:12.530
そして､ このデコレーター・モーダル・ドットを入力させれば､ この関数が実際に呼び出される｡ 

12:12.950 --> 12:21.680
そしてここで､ トークナイザーをセットアップし､ 一度読み込まれるベースモデルをセットアップする｡

12:21.680 --> 12:23.510
だから繰り返し使える｡ 

12:23.660 --> 12:26.480
これがスリープに入る前に呼ばれた場合｡ 

12:26.990 --> 12:30.530
ええと､ これは方法そのものの値段なんだ｡ 

12:30.530 --> 12:47.000
これは以前と同じですが､ モデルをメモリにロードするコードは､ Aデコレータのモーダルまたはエンターの下のセットアップのモーダルにあるこのコードに取り出されました｡

12:47.750 --> 12:52.640
この結果､ もし私がまだこの件で皆さんを迷わせていないのであれば､ 初日に戻って､

12:52.640 --> 12:58.130
重要なポイント､ つまり､ 私はプロセス・サービス2をモーダルにデプロイする｡

12:58.160 --> 13:00.320
プロセス・サービス2が配備されるわけだ｡ 

13:00.530 --> 13:04.310
そうしたら､ このコードを少し変えて使うことができる｡ 

13:04.340 --> 13:08.090
前回､ モーダル・ドット・ファンクション・ドット・ルックアップをやったのを覚えているだろうか｡ 

13:08.090 --> 13:13.190
今は､ モーダルのドット・クラスをやっている｡ 

13:13.340 --> 13:17.300
うーん､ おそらくクラスはすでに使われているものだろう｡ 

13:17.300 --> 13:18.680
だから､ 彼らはそれを使うことができなかった｡ 

13:18.770 --> 13:26.420
つまり､ モーダル・ドット・ドット・ルックアップし､ サービス価格と価格を大文字のP価格で表示する｡ 

13:26.420 --> 13:27.650
だからクラスなんだ｡ 

13:27.650 --> 13:32.900
これで､ 今デプロイしたクラスを見つけることができる｡ 

13:33.020 --> 13:35.450
そのクラスをインスタンス化することができる｡ 

13:35.450 --> 13:38.960
だから､ プライスはプライスのインスタンスだと言っているんだ｡ 

13:39.500 --> 13:42.770
それから､ プライサー・ドット・プライス・ドット・リモートに電話すればいい｡ 

13:42.950 --> 13:46.620
そうすると､ またその答えが返ってくる｡ 

13:46.620 --> 13:52.440
そして､ 以前これを実行したときは､ すでにメモリにあったため超高速で実行されたが､ 今はすでにスワップアウトされているのだろう｡

13:52.440 --> 13:58.500
だから､ 足手まといにならないように､ 今はやめておくよ｡

13:58.830 --> 14:02.400
ええと､ その間に話ができるように､ 今キックオフしようと思うんだ｡ 

14:02.430 --> 14:03.390
走らせてみよう｡ 

14:03.390 --> 14:17.250
そこで､ これをSpecialist Agentという便利なクラスにまとめました｡

14:17.370 --> 14:23.970
これは､ モーダルで動いているプライサーを調べて､ プライサーを呼び出すものです｡ 

14:23.970 --> 14:29.220
そして､ それはただ一つの関数､ 一つのメソッド価格を取るものだ｡ 

14:29.220 --> 14:31.560
そして､ 値段も自由に設定できる｡ 

14:31.560 --> 14:32.460
行って見よう｡ 

14:32.460 --> 14:33.780
それはエージェントにある｡ 

14:33.900 --> 14:35.490
そして今､ 最初のプレビューができる｡ 

14:35.520 --> 14:38.700
今週プレーするさまざまなエージェントを見てほしい｡ 

14:38.940 --> 14:42.120
この捜査官を調べに行くんだ｡ 

14:42.120 --> 14:46.380
スペシャリスト・エージェントと呼ばれるのは､ 我々の特別なモデルを使っているからだ｡ 

14:46.380 --> 14:50.340
これがスペシャリスト・エージェント用のPythonモジュールだ｡ 

14:50.340 --> 14:56.220
そして､ 約束したように､ 私がコメントを書いたり､ 何らかのヒントがあることがわかるだろう｡ 

14:56.430 --> 14:58.620
だから､ このクラスはとてもシンプルなクラスだ｡ 

14:58.620 --> 15:03.630
これは､ 我々の微調整されたLLMをモーダルでリモートで実行するエージェントだ｡ 

15:04.020 --> 15:08.040
ええと､ 名前を決めて､ 自分に名前と色をつけるんだ｡ 

15:08.250 --> 15:13.290
その理由は後でわかるが､ エージェントにログを残してもらうためだ｡ 

15:13.290 --> 15:15.060
だから､ 彼らが何をしているのか見ることができる｡ 

15:15.060 --> 15:17.430
そしてスペシャリスト・エージェントは赤を選ぶ｡ 

15:17.430 --> 15:20.490
だから､ いつ何を考えているのか､ 何をしているのか､ そういうことがわかるようになる｡ 

15:21.240 --> 15:31.440
コンストラクタの初期化メソッドで初期化し､ ログに記録する｡

15:31.440 --> 15:35.340
そして､ このモーダルなドット＋ドット検索を行う｡ 

15:35.340 --> 15:37.470
そして､ サービスや価格を調べる｡ 

15:37.650 --> 15:40.680
そして､ これが先ほど配備したものだ｡ 

15:40.680 --> 15:44.470
だから､ それを調べてインスタンス化した｡ 

15:44.470 --> 15:47.470
そして､ ビジネスの準備ができたことを記録する｡ 

15:47.530 --> 15:52.180
そして､ プライスコール自体も､ まさに今見てきたようなことをする｡ 

15:52.210 --> 15:55.540
私たちは価格ドット・プライス・ドット・リモートを行っている｡ 

15:55.570 --> 15:57.910
ハロー・ドット・リモートの時と同じだよ｡ 

15:57.910 --> 15:59.110
私たちはファンクションを取っている｡ 

15:59.110 --> 16:02.410
私たちはリモートと呼んでいるが､ これはクラウド上で実行することを意味している｡ 

16:02.410 --> 16:04.360
ほとんど透明なんだ｡ 

16:04.360 --> 16:12.520
Pythonで直接呼び出しているようなものだが､ 実際には指定したT4ボックス上のクラウド上で実行される｡

16:12.550 --> 16:19.000
説明を渡し､ 完了したことを記録し､ 結果を返す｡ 

16:19.570 --> 16:24.340
だから願わくば､ 初日に戻ったときには終わっていて､ まだ終わっていないということになるくらい､

16:24.340 --> 16:26.290
長い間おしゃべりしていたい｡

16:26.650 --> 16:32.950
それなら､ ここをめくって時間を埋めることもできる｡ 

16:33.310 --> 16:39.850
ええと､ だから今ここで､ 思い出す前に､ 僕は儚いアプリを探して迷子になったんだ｡ 

16:39.880 --> 16:47.470
現在､ デプロイされたアプリについて正しく理解しています｡ なぜなら､ デプロイされたアプリであるPricerサービスまたはPricerを見ているからです｡

16:47.470 --> 16:49.840
私たちはこの中に入って見てみることができる｡ 

16:49.870 --> 16:51.400
ああ､ 今は成功したと言っている｡ 

16:51.400 --> 16:52.720
戻って見てみよう｡ 

16:52.720 --> 16:54.220
それは確かに成功した｡ 

16:54.220 --> 16:54.940
これでよし｡ 

16:54.940 --> 16:58.000
それは成功し､ 正しい数字133を返した｡ 

16:58.030 --> 17:02.470
そして､ 遅滞なくすぐにもう一度走らせたら､ どれだけ速いかわかるだろう？

17:02.470 --> 17:05.560
すでに暖かくなっているときは､ それだけ早くなるのが普通だ｡ 

17:05.560 --> 17:07.360
それがクラウドに出るんだ｡ 

17:07.360 --> 17:09.730
早く違うものを考えよう｡ 

17:09.760 --> 17:16.780
iPhone SEセカンドエディションにしよう｡ 

17:18.040 --> 17:19.300
iPhoneの値段を見てみよう｡ 

17:19.300 --> 17:19.660
これでよし｡ 

17:19.660 --> 17:21.640
299ドルらしい｡ 

17:21.850 --> 17:34.150
そして､ iPad Pro第2世代を見ることができたことをうれしく思う｡ 

17:36.610 --> 17:40.340
299ドルというのは､ またしても人気の値段なのだろう｡ 

17:40.640 --> 17:43.370
だから､ 暖まればいい感覚が得られる｡ 

17:43.370 --> 17:49.460
一旦モデルを入力したら､ それを素早く呼び出すことができ､ 素早い応答が返ってくる｡ 

17:49.460 --> 17:51.440
そしてまた､ エージェントに電話する｡ 

17:51.440 --> 17:57.290
そして､ 我々のエージェントがやっていることは､ こちらのエージェントがすでにやっていることだ｡ 

17:57.290 --> 18:01.370
すでにクラスがあり､ インスタンス化されている｡ 

18:01.370 --> 18:04.070
そして､ そのクラスはすでにハギング・フェイスのファイルにロードされている｡ 

18:04.070 --> 18:06.470
そして､ 暖かく､ ビジネスの準備が整っている｡ 

18:06.470 --> 18:10.070
そして､ このメソッドを呼び出すと､ ファイルを再度読み込む必要がなくなる｡ 

18:10.070 --> 18:11.090
準備万端だ｡ 

18:11.090 --> 18:12.800
必要なのは推論だけだ｡ 

18:12.800 --> 18:14.420
だから､ とても速いんだ｡ 

18:14.420 --> 18:16.490
それがコツなんだ｡ 

18:16.520 --> 18:23.030
これが､ クラウドでサーバーレスで動作するモデルへのAPIを構築する方法であり､

18:23.030 --> 18:29.420
モデルの重みをメモリにキャッシュして､ すぐに実行できるようにする方法だ｡

18:29.420 --> 18:33.530
だから､ 私たちはあっという間に終わってしまった｡ 

18:33.560 --> 18:36.680
モーダルでうまく機能し､ 見栄えがすることを確認してください｡ 

18:36.680 --> 18:39.110
それではまた､ 次のビデオでお会いしましょう｡ 
