WEBVTT

00:00.620 --> 00:03.290
6주 차 폴더에 잘 오셨어요

00:03.290 --> 00:08.450
이제 이틀째예요, 데이터 큐레이션의 두 번째이자 마지막 단계죠

00:08.720 --> 00:11.840
데이터 집합을 훨씬 더 크게 확장할 거예요

00:11.840 --> 00:16.880
그걸 가지고 아주 특별하고 완벽한 요리를 만들 거예요

00:16.880 --> 00:23.150
훈련을 위해 수입과 환경 설정 포옹 로깅으로 시작합니다

00:23.150 --> 00:27.110
그리고 준비하죠

00:27.260 --> 00:35.240
지난 시간에는 파이썬 을 이용한 모듈을 다뤘었죠. 제가 작성한 항목으로 데이터 포인트를 좋은 항목으로

00:35.240 --> 00:37.550
구문 분석할 수 있었죠.

00:37.550 --> 00:43.610
잘 기억하시니 시간을 들여 직접 살펴보면서 작동 원리를 확인하셨길

00:43.610 --> 00:44.750
바라요

00:44.750 --> 00:51.470
제가 만든 파이썬 툴의 다른 모듈은 더 짧고 간단합니다 로더라고 합니다

00:51.470 --> 01:00.470
단일 클래스 아이템 로더를 가지고 있고 포옹하는 얼굴 저장소에서 데이터셋을 가져오는 좋은

01:00.500 --> 01:02.060
방법이죠

01:02.540 --> 01:10.850
하는 일은 몇 가지 복잡한 것을 이용하는 것입니다 파이썬 에서의 동시 미래 패키지에서 여러 작업자와

01:10.850 --> 01:16.700
함께 작업합니다 그렇지 않으면 시간이 오래 걸리기 때문이죠

01:16.850 --> 01:20.780
너무 자세히 볼 필요는 없어요

01:20.780 --> 01:24.260
몇 가지 말씀드릴 게 있는데 다시 틀에 적힌 대로 잘되고

01:24.260 --> 01:26.870
있다고 스스로를 설득해 보세요

01:26.990 --> 01:31.130
주요 메서드는 로드라고 불려요

01:31.130 --> 01:35.990
작업자 수를 전달하면 자동으로 8명으로 추정하죠

01:35.990 --> 01:41.420
맥북 프로를 작업 중인데 코어가 8개라 감당할 수 있어요

01:41.450 --> 01:43.430
제 기계가 정말 망가졌어요

01:43.430 --> 01:44.300
이걸 하는 동안에요

01:44.300 --> 01:50.090
더 적은 수의 작업자를 통과시키고 싶을 수도 있죠 얼마나 기꺼이 머신의 CPU를 포기할지에

01:50.090 --> 01:54.020
따라서요 동시에 다른 것을 하지 않을 경우에요

01:54.350 --> 02:02.480
이 load in parallel 메서드가 이 프로세스를 사용하는 메서드예요

02:02.480 --> 02:03.470
수영장 집행인요

02:03.500 --> 02:09.560
익숙하시다면, 전에 사용해 보셨다면 기본적으로 다른 여러 개를 생성하죠

02:09.680 --> 02:15.590
여기서 실수를 발견했어요 노동자라고 써야 하는데 실제로는 노동자 8명을 쓰고

02:15.590 --> 02:16.520
있네요

02:16.520 --> 02:18.320
안 그러면 항상 6개를 사용하죠

02:18.590 --> 02:26.480
이건 지정된 작업자 수를 생성할 겁니다 그런 다음 각각의 데이터

02:26.480 --> 02:32.300
포인트를 로드하는데 단위로 하죠

02:32.300 --> 02:38.000
제가 한 일은 발생기를 만든 겁니다 발생기에 익숙한 거죠 결과를

02:38.000 --> 02:42.500
스트리밍백할 때 앞서 사용했으니까요

02:42.650 --> 02:48.440
하지만 우리는 발전기를 사용해서 데이터를 토막 내고 있어요

02:48.470 --> 02:51.350
마침 여기 1000으로 덩어리를 설정했네요

02:51.350 --> 02:53.360
한 번에 1,000개의 데이터 포인트가 있는 거죠

02:53.360 --> 02:56.960
한 번에 1,000개의 데이터 포인트로 나누어져 있죠

02:56.960 --> 03:06.930
각각의 덩어리는 전달되고 궁극적으로 새 데이터 포인트를 생성합니다 지난 시간에 작업했던 동일한 아이템

03:06.930 --> 03:08.970
클래스를 이용해서요

03:08.970 --> 03:10.650
진짜 마법은 아니군요

03:10.650 --> 03:16.290
효율적으로 물건을 담기 위한 화려한 포장일 뿐이에요

03:16.320 --> 03:20.820
한 번에 천 개씩 8명의 노동자에게 나눠 주죠

03:20.820 --> 03:25.920
하지만 이 코드를 검토할 가치가 있다고 말씀드리고 싶네요 왜냐하면 이건 이런 종류의 것이니까요

03:25.950 --> 03:28.350
이런 종류의 프로젝트에서 많은 일을 하죠

03:28.350 --> 03:35.760
상자는 무거우니 잘 활용해야 합니다 그리고 여러 인부로 나누어

03:35.850 --> 03:40.110
작업하기 좋은 경우가 많죠

03:40.110 --> 03:42.210
이 코드는 재사용이 가능해야 해요

03:42.240 --> 03:50.520
읽기 쉽게 썼으면 좋겠고 재사용도 많이 했으니 여러분도 그렇게 하세요

03:51.150 --> 03:56.490
트릭이 하나 더 있는데 지적하고 싶어요 트릭은 아니고요

03:56.490 --> 03:56.700
미안해요

03:56.730 --> 04:02.010
또 다른 결정이 내려졌는데 그게 결과에 영향을 미칠 거예요

04:02.160 --> 04:15.180
0달러 미만 제품만 고르기로 결정했어요 50달러, 999달러 그리고 0달러요

04:15.180 --> 04:15.180
49살요

04:15.180 --> 04:19.380
그 범위에서 그 가격으로 제한할 거예요

04:19.380 --> 04:21.270
여러 가지 이유가 있어요

04:21.390 --> 04:28.140
첫째, 그 수치보다 훨씬 더 큰 수치가 나오면 그 결과가 왜곡될

04:28.140 --> 04:29.460
수 있어요

04:29.490 --> 04:36.210
적은 것에는 큰돈이 들 수 있습니다 그래서 테스트 성능 같은 걸 완전히 망칠

04:36.240 --> 04:37.290
수 있죠

04:37.290 --> 04:43.050
만약 엄청나게 비싼 걸 골랐다면 비트만 잘못돼도 엄청난 오류가 날 수

04:43.050 --> 04:43.830
있어요

04:43.830 --> 04:49.140
절대 오류를 사용해야 하니까요 권장 가격과 실제 가격의

04:49.140 --> 04:50.310
차이죠

04:50.340 --> 04:57.120
가격을 합리적인 범위 내에 유지하면 모델 성능을 알 수

04:57.120 --> 05:00.870
있고 이상한 게 나오지 않아요

05:00.870 --> 05:06.030
본질적으로 이 프로젝트의 스코프에서 우리가 하는 걸 위해서는 1,000달러

05:06.030 --> 05:08.790
이하의 것에 대해 얘기할 거예요

05:08.790 --> 05:13.800
그게 우리 스코프가 될 겁니다 데이터 집합에 집중할 수 있게 해주죠

05:13.890 --> 05:20.220
다른 경계를 두고 실험해 볼 수도 있어요 더 큰 범위를 시도해 보고 어떻게 되는지

05:20.220 --> 05:21.150
보죠

05:21.150 --> 05:26.040
하지만 이렇게 하면 작업하기 쉽고 전반적으로 좋은 결과를 낼 수 있어요

05:26.040 --> 05:28.920
그런 일이 벌어지고 있어요

05:29.370 --> 05:34.980
이걸 저장하고 일상으로 돌아가 보죠

05:34.980 --> 05:45.840
이걸 다시 로드하겠습니다 저 버그를 고치고 커널을 재시작하고 이걸 다시 실행했으니까요

05:45.840 --> 05:50.310
수입 기록 조회하고 포옹 사이트에 다시 로그인해요

05:50.400 --> 05:58.050
이제 아까 했던 것처럼 데이터 어플라이언스를 로드할게요 제 컴퓨터를

05:58.080 --> 05:59.760
박살 낼 거예요

06:00.300 --> 06:07.500
작업하는 게 보여요 1분 전에 데이터 세트 전체 어플라이언스를 로드했는데

06:07.500 --> 06:14.070
이번엔 0분 걸렸어요 2분

06:14.070 --> 06:17.190
그래서 길들이는 게 더 빠르죠

06:17.220 --> 06:20.280
직원 8명이 내 컴퓨터를 망가뜨려요

06:20.400 --> 06:22.440
여러분도 그렇게 하세요

06:22.440 --> 06:29.850
하지만 여기서 통과하면 작업자는 for less죠 프로세스가 적다면요

06:30.330 --> 06:34.830
그게 가전제품 데이터 세트예요

06:34.830 --> 06:42.600
제한된 범위 내에 가격 책정된 28,625개의 데이터 포인트가 있어요

06:42.870 --> 06:47.610
전부 차에 실었어요 첫 번째 사진을 보죠

06:47.640 --> 06:49.470
첫 번째가 뭐였는지 기억하세요?

06:51.780 --> 06:52.620
또 그랬네요

06:52.650 --> 06:53.610
저번에도 그랬잖아요

06:53.610 --> 06:53.970
됐어요

06:54.000 --> 06:54.810
이거 먹어 봐요

06:55.020 --> 06:56.400
자, 보세요

06:56.400 --> 06:59.490
랙, 롤러 스터드 조립 키트예요

06:59.520 --> 07:02.220
프롬프트를 프린트하죠

07:04.530 --> 07:12.690
또 스스로 납득할 수 있길 바라요 그 투박한 부품 번호는 걸러졌다고요

07:12.720 --> 07:13.740
맞아요

07:13.770 --> 07:19.350
이건 식기세척기 톱 슬랙 릴과 스터드 조립 세트예요

07:22.680 --> 07:26.460
이건 문 피벗 블록이에요

07:26.850 --> 07:28.500
늘 그런 게 필요했죠

07:28.650 --> 07:30.510
자, 됐어요

07:30.660 --> 07:35.100
로드된 데이터 포인트예요

07:35.460 --> 07:43.560
이제 규모를 키워서 더 큰 문제에 착수할 때예요

07:43.560 --> 07:49.980
아마존에서 모든 데이터를 가져올 거예요

07:49.980 --> 07:55.120
제품 가격 데이터셋 저장소예요

07:55.150 --> 08:00.010
대형 가정용품 가게에서 볼 수 있는 물건들과 꽤 비슷한

08:00.010 --> 08:01.810
걸 골랐어요

08:01.810 --> 08:08.770
아마존에서 거의 모든 걸 취급해요 옷, 화장품, 책, 소프트웨어 그런

08:08.920 --> 08:10.690
건 제외하고요

08:10.690 --> 08:14.650
모든 게 비슷하게 느껴졌어요

08:14.740 --> 08:18.040
포괄적인 데이터 집합이 될 거예요

08:18.040 --> 08:19.570
여기 데이터 집합이 있어요

08:19.570 --> 08:25.000
물론 여러분이 따라 할 때 이걸 하고 이걸 할 때 이걸 한다면

08:25.000 --> 08:30.550
이걸 갖고 놀면서 다른 데이터 세트를 선택할 수 있어요

08:30.550 --> 08:31.030
원하신다면요

08:31.030 --> 08:34.090
이렇게 옷을 만들고 어떻게 작동하는지 보세요

08:34.180 --> 08:39.970
데이터의 크기가 걱정되고 작업을 빨리하고 싶다면 제한하면

08:39.970 --> 08:40.480
돼요

08:40.480 --> 08:43.450
어플라이언스 데이터셋은 가장 작은 것 중 하나예요

08:43.480 --> 08:46.210
전자 제품은 가운데에 있어요

08:46.210 --> 08:48.340
전자 제품에만 집중할 수 있게요

08:48.520 --> 08:54.760
음, 그래도 여전히 재미있고 성능도 데이터셋에서 얻을 수 있는 것과

08:54.760 --> 08:57.730
동일한 결과를 얻게 될 거예요.

08:57.880 --> 09:00.160
이게 모든 데이터 세트 이름이에요

09:00.160 --> 09:06.550
이제 아이템 로더를 이용해 get을 불러오는 모든 것을 읽어볼게요.

09:06.550 --> 09:09.370
한 번에 하나씩 읽어요

09:09.370 --> 09:12.790
가장 큰 도전은 자동차인데 목록 1번이에요

09:12.790 --> 09:16.180
전 보통 제일 큰 걸 주문해요

09:16.330 --> 09:20.920
시간이 좀 걸릴 거예요 처음 실행할 때 허깅페이스 데이터를 컴퓨터에

09:20.920 --> 09:26.410
다운로드 해야 하거든요 그 단계를 거치고 나면 이미 실행했기 때문에 제 컴퓨터 캐시에서

09:26.410 --> 09:29.110
데이터를 재사용하는 거죠

09:29.230 --> 09:33.130
하지만 비트 때문에 시간이 좀 더 걸릴 거예요

09:33.130 --> 09:35.170
그리고 떨어질 거예요

09:35.380 --> 09:40.180
제 컴퓨터로 작업하는 데 걸리는 시간은 20분 정도예요

09:40.240 --> 09:47.890
제 CPU가 완전히 다운된 걸 알 수 있죠 잠시 쉬었다가 다시 만나겠습니다 데이터가 모두 로드된

09:47.890 --> 09:50.080
휴식 시간 직후에요
