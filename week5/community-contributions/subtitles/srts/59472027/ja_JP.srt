WEBVTT

00:00.620 --> 00:03.530
そして今､ データセットをキュレーションする時が来た｡ 

00:03.530 --> 00:09.110
ハグした顔から得たデータ・ポイントを､ Pythonのオブジェクト､

00:09.140 --> 00:16.430
itemというクラスに変換します｡

00:16.430 --> 00:22.310
とても重要なことなので､ 実は別のモジュール項目を設定したんだ｡  このクラスはJupyterノートブックではなく､

00:22.310 --> 00:35.630
独自のモジュールにPythonのコードとして書いた｡

00:35.630 --> 00:47.750
その中には､ データをきれいにするために､ データを分解するための面倒なコードが含まれている｡

00:47.750 --> 00:54.050
でも､ もっと詳しく見て､ もう少し詳しく理解するための練習があるんだ｡

00:54.110 --> 00:59.870
だから､ 独自のモジュール項目になっているんだ｡  pyで､ クラス項目を定義しています｡ 

00:59.890 --> 01:11.560
そして､ それを始める前に､ ベースモデルという定数をラマ3に設定することから始めることを指摘しておく｡

01:11.560 --> 01:11.560
180億バリアントのベースモデル｡ 

01:11.920 --> 01:17.380
今､ 私たちがやっていることとラマ・モデルがいったい何の関係があるのか､ と言われるかもしれない｡

01:17.380 --> 01:20.080
オープンソースに進むのは来週だ｡ 

01:20.080 --> 01:23.560
今週は､ 微調整のためのフロンティアモデルの使い方についてだ｡ 

01:23.950 --> 01:25.330
その答えはこうだ｡ 

01:25.330 --> 01:36.970
llamaトークナイザーの最大トークン数として､ ある一定のトークン数に収まるようにデータセットを作成します｡

01:36.970 --> 01:41.200
なぜそうするかというと､ オープンソースのモデルを使うことになったときに､ より安く､

01:41.200 --> 01:43.900
より簡単にトレーニングできるからだ｡

01:43.900 --> 01:50.530
また､ フロンティア・モデルを使用することで安くなる｡

01:50.530 --> 02:01.690
だから､ プロンプトを作成し､ それを一定のトークン数に固定するとき､ フロンティアモデルとオープンソースモデルの両方が同じ量の情報を得られるようにしたい｡

02:01.690 --> 02:09.190
もっと予算があり､ もっと大きなGPUで訓練したり､ フロンティアモデルでもっと予算があれば､ カットオフの幅を広げて､

02:09.190 --> 02:14.260
もっともっと大量のテキストを扱えるようになる｡

02:14.260 --> 02:19.570
でも､ それぞれのデータにはたくさんのテキストがあるはずだ｡ 

02:19.570 --> 02:25.270
だから､ フロンティア・モデルとオープンソース・モデルのトレーニングはこれで十分なのだ｡ 

02:25.870 --> 02:30.670
とにかく､ これがllamaモデルを見ている理由だ｡ 文字数が正しいかどうかをチェックするときに､

02:30.670 --> 02:34.660
このモデルのトークナイザーを使うことになるからだ｡

02:34.840 --> 02:42.280
各アイテムには､ タイトル､ 価格､ カテゴリー（家電製品など）､

02:42.310 --> 02:49.000
トークン数（トークンの数）が設定されます｡

02:49.000 --> 03:00.660
そして最も重要なのは､ LLMに入力されるテキストとなるプロンプトだ｡

03:01.770 --> 03:07.080
つまり､ ごく簡単に言うと､ このコードに目を通し､ 私は何も悪いことはしていない､

03:07.080 --> 03:15.810
これはすべて､ 健全な家事と文字列の掃除に過ぎない､ と納得することだ｡

03:15.810 --> 03:24.360
スクラブ・ディテールという機能があって､ モデルにとって邪魔になりそうなものをテキストから削除するんだ｡

03:24.390 --> 03:27.030
バッテリーが含まれているようなものだ｡ 

03:27.150 --> 03:33.060
それから､ この中にある "メーカー "という言葉｡ 

03:33.060 --> 03:39.870
そのため､ 関連性がない､ または関連性が大きくないものがたくさんあり､ そこにあることで貴重なトークンを消費するよりは､

03:39.900 --> 03:44.310
取り除いたほうがいいと思った｡

03:45.030 --> 03:59.990
スクラブという方法があって､ 変な文字を一掃してくれるし､ 正規表現忍者のために正規表現を使って複数のスペースを1つのスペースに変換してくれる｡

04:00.080 --> 04:03.500
あなたにとっては簡単なことでしょう｡ 

04:03.530 --> 04:13.280
また､ このスクリプトを再利用することで､ 文字列のさまざまな問題を取り除くことができる｡

04:13.280 --> 04:18.680
また､ Jupyterノートブックでこれをテストして､ 書いてあるとおりに動いていることを確認することもできる｡

04:19.070 --> 04:30.500
というのも､ この行は､ 私たちの特別なケースに役立つちょっとしたトリックを入れただけだからだ｡

04:30.530 --> 04:38.180
アマゾンの商品説明に品番を引用しているものが多いことに気づいた｡ 

04:38.180 --> 04:42.650
だから彼らは､ これは部品番号と互換性があると言うんだ｡ 

04:42.650 --> 04:50.720
そして､ これらの部品番号は多くの場合､ 8桁､ 8文字以上で､ 文字と数字を含んでいる｡

04:50.720 --> 04:59.360
トークンに変換されるときに､ トークンをたくさん使ってしまうという問題がある｡

04:59.360 --> 05:11.330
そうすると､ トークンの無制限な容量を､ 私たちのモデルにはまったく関係のない部品番号を表すトークンでいっぱいにしてしまうことになる｡

05:11.360 --> 05:19.190
つまり､ この行は､ 8文字以上で数字を含む単語があれば､ その単語をスクラップする､

05:19.190 --> 05:23.180
というものだ｡

05:23.180 --> 05:24.950
気が散るだろうね｡ 

05:25.160 --> 05:32.720
このことを強調したのは､ やはり､ データを掘り下げて初めてこのような発見に出くわすということを示すためです｡

05:32.750 --> 05:37.190
たくさんの例を見て､ こういうことが起こっていることを知った｡ 

05:37.190 --> 05:39.410
これを試す瞬間がある｡ 

05:39.410 --> 05:44.630
そしてモデルを再実行すると､ ここ数週間で1度か2度やったことがあると思うが､

05:44.930 --> 05:51.860
データがよりリッチになり､ より正確になっているため､ 改善されていることに気づく｡

05:52.460 --> 05:56.080
だから､ それはプロセスの重要な部分なんだ｡ 

05:56.530 --> 06:10.180
そして､ データ・ポイントを受け取り､ さまざまなスクラブやストリッピングを行い､ 最終的にプロンプトに変換するparseメソッドを使用する｡

06:10.420 --> 06:14.890
そしてプロンプトとともに､ そのプロンプトに含まれるトークンの数をカウントする｡ 

06:14.890 --> 06:17.440
すぐにプロンプトが表示されます｡ 

06:17.440 --> 06:23.110
しかし､ プロンプトはLLMに合格するためのものであり､ それを完成させることが求められる｡

06:23.230 --> 06:25.510
そして､ これにはいくらかかるんだ？

06:25.510 --> 06:27.490
その代償は大きい｡ 

06:28.390 --> 06:31.870
プロンプトを見る機能もあるだろう｡ 

06:31.900 --> 06:36.580
また､ テストプロンプトと呼ばれるものもあり､ これはプロンプトと同じものだが､

06:36.580 --> 06:38.410
答えは明らかにされない｡

06:38.440 --> 06:42.370
このプロンプトはトレーニング中に使用され､ そこには答えが書かれている｡ 

06:42.370 --> 06:48.160
そのため､ トレーニングの間に､ モデルはテスト時に答えを予測する能力がどんどん向上していく｡ 

06:48.160 --> 06:50.620
答えは見せたくない｡ 

06:50.620 --> 06:54.540
テキストを与えて､ それが正しい答えを導き出すかどうかを確かめたい｡ 

06:54.540 --> 06:58.680
トレーニングのプロンプトとテストのプロンプト｡ 

06:58.710 --> 07:03.660
後で､ データをトレーニングセットとテストセットに分けることについて話すつもりだ｡ 

07:03.900 --> 07:05.520
もっと見ることができるだろう｡ 

07:05.550 --> 07:07.350
後でもっとはっきりする｡ 

07:08.160 --> 07:10.740
これがアイテム・クラスだ｡ 

07:10.740 --> 07:13.650
そして､ もっとこの記事に目を通すことをお勧めする｡ 

07:13.650 --> 07:17.880
しかし､ 恐れることはない｡ 私たちは､ これらのアイテムと多くの時間を過ごし､ それらを眺めることになるのだ｡ 

07:17.880 --> 07:21.840
それで､ この機能が何をするものなのか､ よく理解できるだろう｡ 

07:21.990 --> 07:33.120
さて､ ここに戻って､ これから行うのは､ データセットの中の価格を持つすべてのものに対して､ これらのアイテム・オブジェクトを1つ作成することだ｡

07:33.450 --> 07:36.090
では､ 今すぐ実行してみよう｡ 

07:37.110 --> 07:40.620
つまり､ これはそのコードの中を走っているのだ｡ 

07:40.620 --> 07:43.200
それはゴシゴシ洗うことだ｡ 

07:43.200 --> 07:45.540
部品番号のようなものを削除しているんだ｡ 

07:45.540 --> 07:51.540
変な文字をスペースに置き換えている｡ 

07:51.870 --> 08:00.140
そして､ プロンプトを作成し､ そのプロンプトが適切な数のトークンに収まるようにするのだ｡ 

08:00.140 --> 08:11.450
つまり､ そのすべてが今起きていることであり､ 4万台以上の家電製品､ つまり価格のある家電製品に対してそれを行うことになる｡

08:11.570 --> 08:14.870
だから､ もうそろそろ終わるはずだ｡ 

08:17.240 --> 08:20.990
それを終えている間に､ 私は私たちに見てもらうための準備をする｡ 

08:20.990 --> 08:21.680
終わったよ｡ 

08:21.830 --> 08:22.490
これでよし｡ 

08:22.490 --> 08:26.750
では､ その中の最初の1枚を見てみよう｡ 

08:28.040 --> 08:33.440
そこで最初に紹介するのが､ ラックローラーとスタッドのアッセンブリーキットだ｡ 

08:33.440 --> 08:37.580
アミ・パーツのフルパックは､ ブラブラブラに代わる｡ 

08:37.610 --> 08:43.940
これが商品のタイトルで､ これが9ドルの値段だ｡ 

08:43.940 --> 08:46.910
そして､ そのことはアイテムのタイトルにも記されている｡ 

08:46.910 --> 08:50.390
こういう部品番号､ こういう長い部品番号がある｡ 

08:50.420 --> 08:51.260
もうひとつ見てみよう｡ 

08:51.260 --> 08:52.980
その中の最初の項目を見てみよう｡ 

08:53.760 --> 08:56.310
繰り返すが､ 最初の項目はこうだ｡ 

08:56.340 --> 09:00.750
ドアピボットブロック対応｡ 

09:00.780 --> 09:01.680
ケンモア・キッチンエイド

09:01.680 --> 09:03.480
メイタグのワールプール冷蔵庫｡ 

09:03.510 --> 09:06.090
ここにもたくさんの部品番号がある｡ 

09:06.300 --> 09:18.390
では､ この関数がアイテムを作成したというプロンプトを見たらどうなるか見てみよう｡

09:18.390 --> 09:20.070
もう一度やってみてもいい｡ 

09:21.060 --> 09:22.260
それを印刷しよう｡ 

09:22.260 --> 09:25.740
そのため､ きれいな空行でフォーマットされて表示される｡ 

09:28.410 --> 09:30.930
プロンプトにはこう書いてある｡ 

09:30.930 --> 09:33.570
1ドル単位でいくらかかりますか？

09:33.600 --> 09:35.640
それについては1ドル単位で詳しく話そう｡ 

09:35.670 --> 09:36.810
後の時代には

09:36.810 --> 09:42.300
なぜそうすることにしたのか､ そのメリットとデメリットについて話そう｡ 

09:42.300 --> 09:45.210
では､ 1ドル単位でいくらかかるのか｡ 

09:45.960 --> 09:52.780
そしてここに､ 見出しのための1行と､ 説明のための1行がある｡

09:52.780 --> 10:00.970
そしておわかりになるのは､ 案の定､ これらの部品番号はこの説明から抜き出され､ 切り捨てられたものだということだ｡

10:00.970 --> 10:03.760
トークンの数が一定数に達したらね｡ 

10:03.760 --> 10:09.100
実際､ 180トークン弱になる｡ 

10:09.100 --> 10:10.930
それがここにある｡ 

10:11.110 --> 10:16.300
そして､ これを読めば､ その品物そのものについての豊かな記述であることがわかる｡ 

10:16.300 --> 10:18.730
トレーニングにはこれで十分だろう｡ 

10:19.330 --> 10:21.760
次を見てみよう｡ 

10:22.000 --> 10:25.570
もちろん､ これが私たちのピボット・ブロックだ｡ 

10:25.600 --> 10:27.130
ドアピボットブロック｡ 

10:27.160 --> 10:33.070
背番号100､ アイスメーカー・メカを目指そう｡ 

10:33.190 --> 10:35.650
これはサムスンの交換部品です｡ 

10:36.100 --> 10:41.200
ここには部品や交換用パーツがたくさんあることにもお気づきだろう｡ 

10:41.200 --> 10:50.400
ここでもまた､ 以前我々が見たように､ このスペースは､ 交換部品のような低価格の部品によって混雑する可能性がある｡

10:50.400 --> 10:56.460
やや意外だが､ この部品は118ドルもするので､ そう簡単な部品ではない｡ 

10:56.880 --> 11:02.310
このサムスン製氷機のメカが必要ないことを祈るよ｡ 

11:03.180 --> 11:09.120
そう､ これはトレーニングのプロンプトを見ているんだ｡ 

11:09.120 --> 11:12.330
これがトレーニング中にパスするものだ｡ 

11:12.330 --> 11:22.830
そして､ モデルにはこれが与えられ､ トレーニング中にこの価格を再現する最善の方法を学び始める｡

11:22.830 --> 11:24.810
テスト中はどうなんだ｡ 

11:24.810 --> 11:29.010
そのモデルが役に立っているかどうかを評価する時はどうだろう？

11:29.010 --> 11:35.880
では､ アイテム番号100のこの男を見て､ テスト時間になったらどうするか見てみよう｡ 

11:35.880 --> 11:37.260
私たちはそうする｡ 

11:39.660 --> 11:42.600
これをモデルに提供する｡ 

11:42.630 --> 11:46.590
まったく同じだが､ ここで終わっている｡ 

11:46.620 --> 11:54.420
そしてもちろん､ モデルはこのような例を数多く見てきており､ さまざまな異なるアイテムをカバーしているため､

11:54.420 --> 12:10.740
実行時に再びこのような例を見せられたときに､ どのようにしてこの価格を完成させればよいかを知っている｡

12:12.030 --> 12:12.960
分かった｡ 

12:12.990 --> 12:22.230
これらのアイテムに通常いくつのトークンが入っているのか､ 別の図を使って見てみよう｡ 

12:22.230 --> 12:28.860
そしておわかりのように､ トークンの数が最も多いのは178である｡ 

12:28.890 --> 12:32.850
平均は176｡ 

12:32.850 --> 12:35.010
本当にぎっしり詰まっているんだ｡ 

12:35.340 --> 12:43.650
だから､ 私たちは一般的に､ この程度の情報を持つデータセットを選択し､ 作成してきた｡ 

12:43.650 --> 12:47.250
トークンは最大180枚｡ 

12:47.250 --> 12:51.470
また､ フロンティア・モデルを使用する場合にも､

12:51.470 --> 13:00.350
コストを低く抑えることができる｡

13:01.640 --> 13:02.450
オーケー｡ 

13:02.450 --> 13:09.800
そして､ 選んだアイテムの価格分布を見てみよう｡ 

13:10.160 --> 13:11.450
さあ､ 始めよう｡ 

13:12.020 --> 13:16.190
だから平均価格は100ドルだ｡ 

13:16.340 --> 13:21.560
こっちの最高値は......11,000ドル近くだ｡ 

13:21.560 --> 13:29.450
そのため､ 選別の過程で､ 実はあの超高価な電子レンジを外したのだ｡

13:29.570 --> 13:31.760
それでも､ かなり高価なものを手に入れた｡ 

13:31.790 --> 13:36.440
それが何であるかは､ 私が上に書いたことを再現すればわかる｡ 

13:36.590 --> 13:46.730
そして､ 私たちが見てきたように､ おそらく交換部品と思われる激安品に大きく偏っていることがわかる｡

13:46.730 --> 13:51.010
だから､ これも次回の調査対象だ｡ 

13:51.910 --> 13:58.810
それから､ これらのデータセットを視覚化することは､ 私たちがよくやることだということも言っておきたかったんだ｡

13:58.840 --> 14:01.420
そして､ さまざまな方法で多くのことを行うことになる｡ 

14:01.450 --> 14:06.280
ええと､ matplotlibの様々な機能を利用できるのはいいことだよ｡ 

14:06.280 --> 14:12.100
そのひとつが､ さまざまな色のチャートを作成できることだ｡ 

14:12.100 --> 14:16.660
これらの色が何色なのか知りたい方は､

14:16.660 --> 14:25.360
matplotlibのページにリンクしてあります｡

14:25.360 --> 14:27.610
それを見てみるのはいいことだ｡ 

14:27.760 --> 14:32.680
ええと､ これは､ ブックマークしておくためのちょっとしたおまけです｡ 

14:32.710 --> 14:40.570
ええと､ 今日はもうひとつ､ ちょっとしたプロとしての心得があるんだけど､ 本当にやるべきことは､ アイテムクラスを見てくることなんだ｡

14:40.570 --> 14:42.100
あっという間に終わってしまった｡ 

14:42.100 --> 14:53.770
それは､ データを可能な限り高品質にするために､ 実際のデータ例に基づいて行う､ よりぞっとするようなデータAスクラブがあるからだ｡

14:54.130 --> 15:01.780
そして､ 私はすべての詳細であなたを退屈させませんでしたが､ それは､ あなたがこれから自分自身で詳細を見てくれると信じているからでもあります｡

15:01.810 --> 15:10.510
JupyterLabを使って､ これらの関数がどのようにデータをクリーンアップし､ 将来トレーニングプロンプトやテストプロンプトとして使用される各データポイント､

15:10.510 --> 15:18.310
各アイテムについて､ 約180トークンのリッチな説明､ リッチな表現を持つようになったかを調べ､

15:18.310 --> 15:26.890
試し､ 理解する｡

15:27.220 --> 15:34.000
だから次回は､ これをさらに拡大して､ 他の多くの種類の製品を組み合わせることになるだろう｡ 

15:34.000 --> 15:39.700
このデータセットが大きなデータセットだと思ったのなら､ あなたはまだ何も見ていない｡ 

15:39.700 --> 15:41.260
だから､ その準備をしておくんだ｡ 

15:41.260 --> 15:45.730
その前に､ この日を締めくくるスライドをもう2枚｡ 
