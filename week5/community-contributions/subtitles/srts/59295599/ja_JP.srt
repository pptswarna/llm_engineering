WEBVTT

00:00.980 --> 00:04.850
4日目のJupyter Labへようこそ｡ 

00:04.880 --> 00:10.820
とても見慣れたものに見えるだろうが､ 実は3日目と重複して始めているからだ｡ 

00:11.030 --> 00:14.720
そしてこの複製にはいくつかの細胞がある｡ 

00:14.720 --> 00:19.880
インポートを再実行し､ 環境をつなげたい｡ 

00:19.880 --> 00:22.340
フロンティアモデルにつなげたい｡ 

00:22.340 --> 00:23.630
だってそうだろう｡ 

00:23.630 --> 00:29.900
フロンティア・モデルとオープンソース・モデルを共存させることができる｡

00:30.260 --> 00:39.530
プロンプトやメッセージ関数は､ Cプラス・プラス・ファイルに書き出すことができる｡

00:39.920 --> 00:43.880
ええと､ これは上書きされるから実行する必要はないと思う｡ 

00:43.880 --> 00:49.850
でも､ Piプログラムのコードは､ 覚えているだろうから､ 試す必要はない｡ 

00:49.850 --> 01:00.680
しかし､ 最大の累積数を持つ配列の部分配列を探すハード・プログラムのコードは得られるだろう｡

01:01.360 --> 01:07.870
そして､ このストリーム､ GPT機能が必要なんだ｡ 

01:07.870 --> 01:10.600
そして､ このストリーム､ クロード機能が必要なのだ｡ 

01:10.600 --> 01:14.710
そして､ これから上書きすることになるが､ このオプティマイズ関数が必要なのだ｡ 

01:14.710 --> 01:22.270
そして､ ゴージャスなグラデーション関数は､ Pythonを実行し､

01:22.270 --> 01:28.180
Cプラスプラスを実行することを覚えているだろう｡

01:28.180 --> 01:34.360
PythonやCプラスアルファの任意のコードを実行させることを許したくはないだろう｡

01:34.360 --> 01:35.650
それはよくない｡ 

01:35.650 --> 01:40.960
だから､ グラディオのインターフェイスは自分だけのものにしておき､ それについてはシェア＝トゥルーなんて言わないことだ｡ 

01:40.960 --> 01:44.170
そして､ CSSで見栄えを良くする｡ 

01:44.200 --> 01:45.430
分かった｡ 

01:45.430 --> 01:47.770
そして､ 新しいコードに取りかかる｡ 

01:47.770 --> 01:50.710
そして､ それは極めてシンプルなものになるだろう｡ 

01:50.710 --> 01:52.780
まずは輸入品から｡ 

01:52.780 --> 01:59.860
Huggingface hubからインポートしているのは､ 前に見たログイン関数と､ 推論クライアントというクラスだ｡

02:00.280 --> 02:03.210
そしてトークナイザーをインポートする｡ 

02:03.810 --> 02:05.790
ハグ顔にログインするんだ｡ 

02:05.790 --> 02:06.780
これでよし｡ 

02:06.780 --> 02:09.030
そして今度は､ いくつかの定数だ｡ 

02:09.150 --> 02:17.040
コードとは､ このコードモデルの名前である｡

02:17.070 --> 02:22.200
これは私のエンドポイントのURLなので､ エンドポイントのページから取ってきただけです｡ 

02:22.200 --> 02:24.540
このURLを持っていけばいいんだ｡ 

02:24.540 --> 02:29.040
今､ 私のエンドポイントはそこで動いていて､ コストは0ドルだ｡  時給80円｡ 

02:29.040 --> 02:35.250
そしてこれは､ 特に安定していなかったため､ 惜しまれつつも一時停止しているコード・ジェンマだ｡ 

02:35.640 --> 02:38.370
オーケー､ ではこれを試してみよう｡ 

02:38.400 --> 02:45.090
そこで､ オートトークナイザークラスを使用して作成できるトークナイザーを覚えておき､ Frompretrainedと言い､ モデルの名前を渡すと､

02:45.090 --> 02:49.020
そのモデルに適したトークナイザーが表示されます｡

02:49.020 --> 02:51.390
そして､ これを作るんだ｡ 

02:51.390 --> 03:03.380
これは前に書いた関数で､ 構造化された辞書のリストを作成し､ 円周率を表す単純な関数をC＋＋＋で書き換えるよう求めるものだ｡

03:03.380 --> 03:09.980
そして､ Tokenizersのapply chat templateを使ってテキストに変換します｡ 

03:10.010 --> 03:12.110
ここで私が話していることを見てみよう｡ 

03:12.110 --> 03:15.650
だから､ それを忘れずに実行し､ 次にこれを実行すればいい｡ 

03:16.250 --> 03:19.250
だからまず､ メッセージとは何かを思い出してほしい｡ 

03:19.250 --> 03:22.490
メッセージは2つの要素を持つリストである｡ 

03:22.490 --> 03:24.650
そのうちの1人はシステムの役割を担っている｡ 

03:24.650 --> 03:25.760
それが内容だ｡ 

03:25.790 --> 03:29.180
あなたはPythonのコードを再インプリメントすることに固執していた｡ 

03:29.900 --> 03:34.850
そしてユーザー､ ユーザーメソッド｡ 

03:34.880 --> 03:41.810
ここで､ 完全にオープンであることの精神から､ 乱数ジェネレーターの実装を同一にし､

03:41.810 --> 03:49.940
結果が正確に一致するようにする､ というちょっとしたヒントを付け加えておく｡

03:50.060 --> 03:57.410
想像できるように､ あちこちにヒントを付け加えなければならない｡ 

03:57.470 --> 04:00.830
その結果はすぐにわかるだろう｡ 

04:00.880 --> 04:04.240
これはもちろん､ 皆さんがよく知っているメッセージだ｡ 

04:04.240 --> 04:11.710
そして､ チャットテンプレートを適用した後､ どのようなテキストになったかをお見せすると､ これを印刷すると､

04:11.740 --> 04:13.240
少し間隔が空きます｡

04:13.270 --> 04:14.590
印刷されるのを見よう｡ 

04:14.950 --> 04:16.360
さあ､ 始めよう｡ 

04:16.510 --> 04:17.440
これを見てほしい｡ 

04:17.440 --> 04:24.490
だから､ 特別なトークンがあって､ それからシステム､ それからシステム・メッセージがあるんだ｡ 

04:24.490 --> 04:26.080
そしてユーザーも同じだ｡ 

04:26.080 --> 04:27.970
そしてこれがコードだ｡ 

04:27.970 --> 04:30.700
そして､ この小さなプロンプトで終わる｡ 

04:30.700 --> 04:37.330
つまり､ LMはそのままアシスタンス対応を続けるということだ｡ 

04:37.540 --> 04:46.090
そうなると､ ハグする顔のエンドポイントに電話をかけ､ オープンソースモデルにこの種のメッセージを送り､

04:46.090 --> 04:51.430
レスポンスを返すのは本当に難しいことだと想像できるだろう｡

04:51.730 --> 04:52.840
そして､ そうではない｡ 

04:52.840 --> 04:55.390
ほんの2､ 3行のコードでできることだ｡ 

04:55.390 --> 04:56.050
これだ｡ 

04:56.050 --> 04:57.490
簡単なことだ｡ 

04:57.580 --> 05:04.020
推論クライアントというオブジェクトを作り､ エンドポイントのURLとハグする顔のトークンを伝え､

05:04.050 --> 05:09.150
クライアント・ドット・テキスト生成と言うだけだ｡

05:09.150 --> 05:13.320
テキストを渡して､ この場合は結果をストリームバックしたい､ と言う｡ 

05:13.320 --> 05:15.780
それがなかったら､ これはもっと短くなる｡ 

05:15.780 --> 05:18.030
でも､ 結果がどんどん戻ってくるのはうれしい｡ 

05:18.330 --> 05:24.030
そして､ 新しいトークンを最大まで増やすことで､ 少しの間なら続けられると伝えるんだ｡ 

05:24.270 --> 05:26.790
どうなるかな？

05:28.080 --> 05:38.610
この変換の結果､ 私のエンドポイントからストリーミングが戻ってきている｡

05:40.650 --> 05:44.580
このコードを認識し､ PythonからCプラスへのコードの変換がとても合法的で､

05:44.580 --> 05:51.300
とてもしっかりしたものであることを確認してほしい｡

05:51.300 --> 05:57.990
それに､ 冒頭でC＋＋コードについて少し説明しているんだ｡

05:57.990 --> 06:01.850
そして､ なぜそのようなことをしたのかというたくさんの文章で締めくくられている｡ 

06:01.880 --> 06:07.070
私のシステムメッセージは､ そんなことをしてはいけないと主張しているにもかかわらず､ だ｡ 

06:07.190 --> 06:15.980
ええと､ 説明をしないでくださいと書いてありますが､ システムメッセージで説明をしないようにすることはできませんでした｡

06:16.010 --> 06:20.420
とはいえ､ GPTの4番とクロードは指示に従っている｡ 

06:20.420 --> 06:26.900
だから､ そうならないようにするために､ もっと時間をかけてプロンプトに取り組むことができるだろうね｡

06:26.900 --> 06:32.360
しかし､ そうでない場合は､ もちろん､ 後処理をするのはとても簡単で､

06:32.360 --> 06:45.890
Cプラスプラスコードの始まりから､ その記号までのすべてを取り除くことができる｡

06:46.010 --> 06:49.850
だから､ 後処理でそれをやるのはかなり簡単だろう｡ 

06:50.270 --> 06:51.170
分かった｡ 

06:51.170 --> 06:55.310
とにかく､ 推論を実行するのがいかに簡単であるかはわかった｡ 

06:55.460 --> 07:00.620
ええと､ また次回､ UIにこれを組み込んでやってみよう｡ 

07:00.650 --> 07:01.520
ではまた
