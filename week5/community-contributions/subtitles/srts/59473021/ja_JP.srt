WEBVTT

00:00.860 --> 00:03.890
JupyterLabへようこそ｡ 

00:03.890 --> 00:06.920
そして3日目｡ 

00:06.920 --> 00:08.900
第6週だ｡ 

00:09.200 --> 00:13.580
またこのノートを楽しみにしています｡ 

00:13.580 --> 00:16.130
いいものを用意したよ｡ 

00:16.310 --> 00:21.650
だから､ 今日もベースラインモデルを見るつもりだ｡ 

00:21.650 --> 00:28.190
だから､ まずは見たことのあるインポートの数々から始めよう｡ 

00:28.190 --> 00:30.080
特に目新しいことはない｡ 

00:30.080 --> 00:33.890
しかし､ この2番目のセルに新しいインポートがいくつか入っている｡ 

00:33.890 --> 00:41.150
従来の機械学習用パンダのインポートをいくつか紹介しよう｡ このパンダは､

00:41.150 --> 00:48.260
おそらく旅の中で何度も出会ったことがあるだろう｡

00:48.380 --> 00:51.320
ええと､ もちろん､ numpyはあなたにとって古馴染みだと確信している｡ 

00:51.320 --> 00:52.760
そしてsklearn｡ 

00:52.790 --> 01:00.620
Scikit learnは信じられないほど人気のある機械学習ライブラリで､ 今日私たちがたくさん使うことになる一般的なアルゴリズムが何トンも何トンもありますが､

01:00.620 --> 01:14.120
最も重要なのは線形回帰で､ 線形回帰モデルを実行するためのデータサイエンティストのツールキットの標準的な部分です｡

01:14.690 --> 01:20.630
Gensimは､ 少し前に紹介したword

01:20.660 --> 01:32.780
two vecのようなNLP関連でとても便利なライブラリだ｡

01:32.810 --> 01:40.010
先ほど述べたように､ 言葉をベクトルに変えるための強力なモデルである｡ 

01:40.010 --> 01:44.450
だから､ そのセルも必ず走らせる｡ 

01:44.780 --> 01:47.720
それからもうひとつ､ 輸入品がある｡ 

01:47.810 --> 01:50.630
ええと､ またscikit learnから｡ 

01:50.630 --> 01:57.590
ただ､ より高度な機械学習のためにやっている2つの異なるインポートなので､ これらは別々にしておいた｡

01:57.590 --> 02:03.600
1つはサポート・ベクトル回帰で､ サポート・ベクトル・マシンとパッケージの一部である｡ 

02:03.600 --> 02:06.870
そしてもう1つは､ ランダムフォレスト・リグレッサーだ｡ 

02:06.930 --> 02:12.390
ええと､ 先ほどランダムフォレストについて触れましたが､ それも取り入れましょう｡ 

02:12.840 --> 02:13.800
オーケー｡ 

02:13.830 --> 02:17.700
さて､ この定数セットだが､ あなたを驚かせるかもしれない｡ 

02:17.730 --> 02:19.860
ちょっと変わった形をしている｡ 

02:20.070 --> 02:22.500
ええと､ その考えは止めておくように言っておくよ｡ 

02:22.500 --> 02:23.670
後から入ってくる｡ 

02:23.670 --> 02:26.040
このようなことをしたことがある人なら､ 見覚えがあるかもしれない｡ 

02:26.040 --> 02:32.910
それは､ うーん､ 少し奇妙なことに､ 非常に歴史的な様々な理由がある｡ 

02:33.090 --> 02:42.960
ええと､ その特定の記号を標準出力にプリントすると､ 色が緑色に変わるんだ｡

02:43.200 --> 02:47.370
まあ､ いろいろな理由があるんだけど､ それはここでは書かないよ｡ 

02:47.490 --> 02:53.820
そして､ リセットは色を黒か白に戻す｡ 

02:53.850 --> 03:00.600
この定数を知っていれば､ カラー印刷も簡単にできる｡

03:00.840 --> 03:01.410
オーケー｡ 

03:01.410 --> 03:07.950
そこで､ 定数を実行し､ いつもの環境設定を実行し､ ハギング・フェイスにログインする｡ 

03:08.280 --> 03:09.510
うーん､ よくわからない｡ 

03:09.510 --> 03:14.910
今日はハギング・フェイスを実際に使うことはないと思うので､ ハギング・フェイスにログインする必要はなかったと思う｡

03:15.180 --> 03:18.900
それから､ Jupyterノートブックにmatplotlibが入っていることを確認してください｡ 

03:18.990 --> 03:26.160
ええと､ データを再作成するのではなく､ ピックルファイルからデータを読み込みます｡ 

03:26.160 --> 03:33.180
そこで､ トレーニングデータをもう一度見てみよう｡ 

03:33.180 --> 03:35.970
では､ 最初のトレーニング・データを取ってみよう｡ 

03:35.970 --> 03:39.870
そして､ これが何であったかをもう一度思い出してもらうために､ その促しを求めるだけだ｡ 

03:39.870 --> 03:48.150
というわけで､ このアイテム・オブジェクトのプロンプト属性を探しています｡

03:48.150 --> 03:52.050
ええと､ 過去に､ ええと､ 2日前に｡ 

03:52.140 --> 03:55.350
でも､ これで皆さんがこのことをより身近に感じてくれることを願っています｡ 

03:55.380 --> 03:58.110
きれいに印刷できるように印刷させてください｡ 

03:58.560 --> 04:01.740
うーん､ そうだな｡ 

04:02.010 --> 04:02.880
ええと､ これです｡ 

04:02.880 --> 04:04.620
1ドル単位でいくらですか？

04:04.620 --> 04:08.350
そしてタイトルがあり､ ディテールがあり､ 価格がある｡ 

04:08.380 --> 04:15.580
さて､ なぜ私がこの問題のために特別にこのアイテムクラスのようなものに多くの時間を費やしているのか不思議に思うかもしれない｡

04:15.580 --> 04:20.710
このようなことは､ あなた自身が商業的な問題に直面したときに､ その問題を解決し､

04:20.740 --> 04:25.450
データを加工する方法を探すために行うことなのです｡

04:25.450 --> 04:28.420
だから､ これは役に立つ実戦経験なんだ｡ 

04:28.450 --> 04:34.000
このコード､ つまりアイテム・クラスを正確に使うことはないだろうし､ おそらくこのようなプロンプトはないだろう｡

04:34.000 --> 04:39.190
しかし､ このようなテクニックは皆さんにも再現できるものなので､ それを理解し､ 私がどのような決断を下しているのかを理解することが重要で､

04:39.190 --> 04:46.720
そうすれば皆さんは自分のプロジェクトで自信を持って同じことができるようになる｡

04:46.780 --> 04:51.160
つまり､ これがトレーニングのプロンプトだ｡ 

04:51.190 --> 04:53.500
では､ テストプロンプトを見てみよう｡ 

04:53.500 --> 04:57.700
では､ テスト項目の1つ目を紹介しよう｡ 

04:57.700 --> 05:00.790
そして､ このメソッドをテスト・プロンプトと呼ぶことにする｡ 

05:00.790 --> 05:11.980
そして､ 基本的にトレーニングのプロンプトを取るが､ モデルをテストするときに答えが明らかにならないように実際の価格を取り除くことを覚えておいてほしい｡

05:11.980 --> 05:14.950
そして､ その価格を埋めるのが仕事だ｡ 

05:14.950 --> 05:19.810
そして､ もしそれが何を記入することになっているのか知りたければ､ うーん､ トレーニングポイントのためにそれを取るよ｡ 

05:19.960 --> 05:25.360
電車に乗ったら､ そのまま値段を言えばいい｡ 

05:25.360 --> 05:34.030
そして､ これが実際の価格であり､ この価格に関連するものである｡

05:34.120 --> 05:36.700
しかし､ 本当の値段は少し違う｡ 

05:36.700 --> 05:43.090
この訓練とテストの方法､ 訓練項目とテスト項目のリスト､ そしてそれらをどのように呼ぶかについて､

05:43.240 --> 05:51.280
記憶を呼び覚ますことができれば幸いだ｡

05:51.490 --> 05:58.510
このコードの塊は､ あなたのプロジェクトで正確にこのコードを使うことはないかもしれないが､

05:58.540 --> 06:03.280
似たようなことはできるだろう｡

06:03.280 --> 06:12.800
だから､ これは一種の原理原則であり､ 問題に取り組むための素晴らしい方法であり､ あなた自身の問題にも応用できるはずだ｡

06:12.800 --> 06:21.200
だから､ 私たちが考え出したさまざまなモデルを､ 本当に素早くシンプルな方法でテストできるようにしたかった｡ 

06:21.410 --> 06:28.850
テストデータの束をモデルに通し､ その結果を視覚化するんだ｡

06:28.850 --> 06:38.180
結局､ 同じことを何度も繰り返したくなるので､ コードを何度もコピー・アンド・ペーストしなければなりませんでした｡

06:38.180 --> 06:44.780
そうする時はいつでも､ 自分のために何らかのユーティリティを構築する時だと思う｡

06:44.900 --> 06:50.930
それで私が考えたのがこのクラス・テスターで､

06:50.930 --> 07:01.790
モデルをテストできるようにするものです｡

07:01.790 --> 07:10.130
そして､ その唯一の仕事は､ アイテムを受け取り､ それに応答し､

07:10.130 --> 07:14.570
見積もり価格を返すことである｡

07:14.570 --> 07:19.070
このような関数を書いたら､ あとはテスターを呼び出すだけだ｡ 

07:19.100 --> 07:24.800
これから紹介するクラスは､ ドット・テストと関数名を渡す｡ 

07:24.800 --> 07:26.720
そして､ この機能を使う｡ 

07:26.720 --> 07:34.910
実際､ 250の異なるテスト項目に対してこのテストを繰り返し実行し､ 結果を予測する能力がどの程度あるかを調べ､

07:34.910 --> 07:38.600
その情報を視覚的にまとめて返す｡

07:38.870 --> 07:39.980
そういうことだ｡ 

07:39.980 --> 07:43.190
そして､ ワークフローを明確に簡素化することができる｡ 

07:43.430 --> 07:45.410
ええと､ これは授業そのものです｡ 

07:45.410 --> 07:46.460
至ってシンプルだ｡ 

07:46.460 --> 07:48.650
色で対処しなければならないことがあるんだ｡ 

07:48.650 --> 07:50.720
何色かプリントすると言ったはずだ｡ 

07:50.720 --> 08:01.100
データ・ポイントを実行し､ そのデータ・ポイントを取得する｡

08:01.130 --> 08:05.030
ここで､ あなたが提供した関数が呼び出される｡ 

08:05.030 --> 08:08.730
モデルのモデルを取得するために､ データポイントとともに呼び出す｡ 

08:08.730 --> 08:12.630
あなたの機能で､ その価値を推測してください｡ 

08:12.630 --> 08:18.480
そして､ 先ほど見た価格属性を呼び出すことで真実を得る｡ 

08:18.480 --> 08:24.510
そして､ その誤差はもちろん､ 推測と真実の絶対的な差である｡ 

08:24.540 --> 08:25.980
簡単なことだ｡ 

08:26.010 --> 08:37.410
また､ 二乗対数誤差と呼ばれるものも計算され､ 二乗対数誤差の公式はまさにここにある通りである｡

08:37.440 --> 08:43.770
これは､ 真実の対数プラス1から推測の対数プラス1を引いたものである｡ 

08:44.160 --> 08:50.700
なぜ､ このプラス1が計算式にあるのかは､ 想像がつくだろう｡ 

08:50.700 --> 08:55.500
真実がゼロだったら､ 数学はいらないからだ｡  丸太が吹き飛ぶ｡ 

08:55.560 --> 09:02.580
だからこの式は､ 例えば､ 真実や推測がゼロの場合にうまく機能する｡

09:03.120 --> 09:08.790
対数誤差の2乗は､ もちろんこの2乗だ｡ 

09:09.330 --> 09:14.400
それから､ ちょっと処理をするんだ｡ 

09:14.400 --> 09:17.850
これからちょっとしたグラフを描くことができる｡ 

09:18.030 --> 09:19.380
ええと､ 報告書を書いてください｡ 

09:19.380 --> 09:23.880
そしてこれが最終的に､ さっき言った機能なんだ｡ 

09:23.880 --> 09:27.960
このテストを実行するにはtestを呼び出せばいい｡ 

09:28.170 --> 09:28.740
オーケー｡ 

09:28.770 --> 09:30.240
そのセルを実行させてくれ｡ 

09:30.240 --> 09:35.160
だから､ このテストクラスで私がやったことのすべてを特に理解する必要はない｡ 

09:35.160 --> 09:47.550
このような小さなテストハーネスを作成し､ それに少し時間を投資することで､ モデルを実行した結果について本当の洞察を得ることができるようになるという原則だ｡

09:47.550 --> 09:49.080
それがここでの学びだ｡ 

09:49.350 --> 09:54.450
では､ 考えられる最もシンプルなモデルは何だろう？

09:54.450 --> 09:56.610
最もシンプルなモデルとは？

09:56.610 --> 09:59.250
本当のベースラインモデルを作る前に､ 私たちは出てくるつもりだ｡ 

09:59.250 --> 10:04.560
私たちは2つのお笑いモデルをやるつもりで､ 想像しうる最も基本的なことをやるおバカなモデルだ｡

10:04.560 --> 10:07.110
そして､ ちょっと挑戦させてほしい｡ 

10:07.230 --> 10:12.760
可能な限りシンプルなモデルは何か考えてみてほしい｡ おそらく､ それよりももっとシンプルなものになるだろう｡

10:12.940 --> 10:16.900
ええと､ ではまず､ 非常にシンプルな2つのモデルを紹介します｡ 

10:16.900 --> 10:19.090
1つ目は､ すでに答えを明らかにしている｡ 

10:19.090 --> 10:24.130
おそらく､ 最初の1つは乱数を当てるだけだと見ただろう｡ 

10:24.130 --> 10:25.540
それだけだ｡ 

10:25.540 --> 10:27.640
これがその機能だ｡ 

10:27.640 --> 10:31.090
プロンプトを受け取らない関数がある｡ 

10:31.090 --> 10:39.520
そのアイテムを完全に無視し､ 代わりに何を言われても気にしないようにするのだから｡

10:39.520 --> 10:43.510
1から1000の間の乱数を返す｡ 

10:43.690 --> 10:47.500
ええと､ すみません､ 1～999の間です｡ 

10:47.740 --> 10:53.320
ええと､ ランダムシードを設定して､ このテストを実行するたびに同じになるようにします｡ 

10:53.440 --> 10:54.880
そして今､ 我々はそれを実行している｡ 

10:54.880 --> 11:00.730
このテストをもう一度実行するには､ テスター・クラスでドット・テストを実行します｡ 

11:00.730 --> 11:03.700
そして､ 単純にこの関数の名前を渡す｡ 

11:03.700 --> 11:08.920
関数を呼び出さないのは､ もし関数を呼び出したら､ 一度だけ呼び出してそれでおしまいだからだ｡

11:08.950 --> 11:11.590
関数そのものをこのように渡す｡ 

11:11.620 --> 11:17.350
そして今､ これを実行に移し､ 私のプログラムの結果を見てもらう｡ 

11:17.800 --> 11:20.800
このモデルは非常に素早いものだったからだ｡ 

11:20.800 --> 11:24.280
だから､ 上にスクロールし直して､ あなたがここで見ているものを教えようと思う｡ 

11:24.790 --> 11:29.770
次の数回の授業で何度もやることになるので､ とても慣れることになる｡

11:29.770 --> 11:37.060
つまり､ ここに表示されている各行は､ テスト・データの異なる1点を表している｡ 

11:37.060 --> 11:40.270
そして､ この右側にあるアイテムが何であるかを教えてくれる｡ 

11:40.270 --> 11:47.050
LEDライトキット､ ハンドヘルドLED｡ 

11:47.050 --> 11:49.270
そしてその後､ 短く切った｡ 

11:49.270 --> 11:57.760
そして､ このLEDライトキットに表示されているのは､ LEDライトキットの機能を推測したモデルです｡

11:57.760 --> 12:01.810
そして､ 乱数ジェネレーターだから143ドルを当てた｡ 

12:02.260 --> 12:03.760
真実とは何か？

12:03.760 --> 12:12.980
ちょっと驚くべきことに､ 真実は289ドルで､ これは私が予想していたよりもむしろ高い｡

12:12.980 --> 12:13.490
たぶんね｡ 

12:13.790 --> 12:17.150
もしかしたら､ ノートパソコンが横に付いてくるかもしれない｡ 

12:17.900 --> 12:19.190
それがエラーなんだ｡ 

12:19.220 --> 12:23.330
それくらい､ このモデルは間違っている｡ 

12:23.330 --> 12:26.930
対数誤差の2乗については､ また別の機会に説明することにしよう｡ 

12:26.930 --> 12:32.630
しかし､ これは絶対的な誤差と相対的なパーセンテージの誤差の差をよりよく補正し､

12:32.630 --> 12:35.720
よりよく反映させるためのものだ｡

12:35.870 --> 12:40.970
しかし､ 私たちは何よりもこのことに焦点を当てるつもりだ｡ なぜなら､ 私たちにとって､

12:41.000 --> 12:45.920
人間にとって､ 推測と真実の違いを理解するのはとても簡単だからだ｡

12:46.310 --> 12:51.200
ええと､ 赤で塗られているのは､ それが本当にひどい推測だと考えられているからです｡ 

12:51.200 --> 12:53.270
だから赤は本当にひどい｡ 

12:53.270 --> 12:56.210
黄色は......､ 緑はまあまあかな｡ 

12:56.210 --> 13:02.540
その定義は､ 上にスクロールして戻ってみると､ 経験則のようなものがある｡

13:02.540 --> 13:06.710
私は､ 40ドルか20％以内で当てたら緑と呼んでいる｡ 

13:06.740 --> 13:09.950
40ドルか20％以内ならグリーンだ｡ 

13:09.950 --> 13:17.510
40ドルというのはかなり気前がいいと思うかもしれないが､ ここでは値段の幅が大きく､ 何かの説明を受けただけだということを覚えておいてほしい｡

13:17.510 --> 13:20.420
そして､ これを実行するのは本当に難しい｡ 

13:20.420 --> 13:25.250
だから､ 40ドル以内で当てることができれば､ それは立派な仕事だと思う｡ 

13:25.430 --> 13:28.070
だから､ 望むならもっと厳しくすることももちろんできる｡ 

13:28.070 --> 13:29.930
これを微調整するのはあなた次第だ｡ 

13:30.080 --> 13:32.300
でも､ それが私の原則だった｡ 

13:32.810 --> 13:35.180
では､ すべてのポイントを紹介しよう｡ 

13:35.180 --> 13:38.630
そして最後には､ ちょっとした視覚化もある｡ 

13:38.660 --> 13:40.730
では､ 何が見えているのか｡ 

13:40.760 --> 13:41.900
私はこの図が大好きだ｡ 

13:41.930 --> 13:43.340
このような図をたくさん見ることになるだろう｡ 

13:43.340 --> 13:44.960
だから､ これに慣れることだ｡ 

13:44.990 --> 13:51.530
X軸は､ 製品の実際の価値を示している｡ 

13:51.560 --> 13:58.850
また､ データサイエンティストがyと表現するのを耳にすることもありますが､ この軸はデータサイエンティストが言うところのyハット､

13:58.850 --> 14:04.760
つまりモデルがどのような推定値を出したかを示しています｡

14:04.760 --> 14:10.430
つまり､ 製品の実際の真価に対するモデルの推定値を見ているのだ｡ 

14:10.430 --> 14:17.940
つまり､ 真の値は常に0から1000の範囲にある｡

14:17.970 --> 14:20.520
完全にランダムな点の集合｡ 

14:20.520 --> 14:26.310
この青い線は､ もちろん完全な推測の線を表している｡ 

14:26.580 --> 14:34.920
もしモデルがこの青い線に沿って推測するようなことがあれば､ それはまさにグランド・トゥルース（地上真実）上にいることになり､ 運がよかったと見ることができる｡

14:34.920 --> 14:40.530
もちろん､ 幸運に恵まれるのはわずかな時間であり､ 青い線に近い緑色の点は､

14:40.530 --> 14:44.310
かなりうまくいっていることを表している｡

14:44.550 --> 14:52.020
黄色い点は「A」､ 赤い点はトリックが外れて右に出てしまった場合だ｡ 

14:52.500 --> 14:54.690
ああ､ 楽しかった｡ 

14:54.690 --> 14:55.860
楽しんでいただけたなら幸いだ｡ 

14:55.860 --> 15:00.750
もうひとつ､ とてもつまらないモデルがある｡

15:00.750 --> 15:05.520
非常に基本的なモデルとして､ ええと､ 私が思いついた本当に基本的なものの1つは､ すべてに対してゼロを推測しよう､

15:05.520 --> 15:09.060
あるいはすべてに対して1を推測しよう､ と思ったかもしれない｡

15:09.330 --> 15:11.280
私たちはそれよりも少しマシなことができる｡ 

15:11.310 --> 15:19.620
トレーニング・データ・セットを使って､ すべてのトレーニング・データ・セットにおける商品の平均価格はいくらか､ と言うことができる｡

15:19.620 --> 15:22.710
というのも､ 我々のモデルにはトレーニング・データセットが提供されているからだ｡ 

15:22.710 --> 15:26.970
だから､ 私たちはそれを一定の推測として考えることができる｡ 

15:27.000 --> 15:33.930
学習データセットに含まれるあらゆるものの平均価格がすべてだと仮定しよう｡ 

15:34.140 --> 15:40.470
基本的には､ トレーニングデータセットの価格を計算し､

15:40.470 --> 15:45.450
その平均を求めます｡

15:45.450 --> 15:52.440
これで､ トレーニング・データ・セット内のあるポイントの平均価格が得られる｡ 

15:52.470 --> 15:56.820
そして､ これが我々の非常に洗練されたモデルだ｡ 

15:56.820 --> 16:02.220
繰り返しになるが､ これはアイテムを受け取り､ その平均値を返すだけである｡ 

16:02.220 --> 16:05.940
そのため､ 渡されたものはすべて無視され､ ただ平均値が返される｡ 

16:05.940 --> 16:08.490
では､ これがどのようなものか見てみよう｡ 

16:08.520 --> 16:13.170
これから見る図がどのようなものか､ 頭の中に思い浮かべることができるかどうか試してみよう｡ 

16:13.290 --> 16:17.320
どんな感じか想像できるかな？

16:18.190 --> 16:20.800
そして､ 自分が正しいかどうかを確かめる準備ができているならね｡ 

16:21.040 --> 16:21.790
バム！

16:21.790 --> 16:23.890
もちろん､ これがその図だ｡ 

16:23.890 --> 16:32.920
もし500点だと思ったのなら､ 分布がより安いものに偏っていることを覚えておいてほしい｡

16:32.950 --> 16:35.170
元々ほどひどくはない｡ 

16:35.200 --> 16:37.480
修正したが､ ほんの少しだ｡ 

16:37.690 --> 16:41.620
ええと､ だから､ この金額は絶対にすべてに対して当てられたんだ｡ 

16:41.950 --> 16:50.650
そしてもちろん､ それが製品の価値と同じになった時点で緑､ そうでなければ黄色か赤になった｡

16:50.680 --> 16:53.140
だからスプレッドがある｡ 

16:53.170 --> 16:56.590
そして､ 期待通りの結果を見ることができる｡ 

16:56.590 --> 17:02.080
実際の結果をスクロールバックしてみると､ 赤の海が広がっており､

17:02.080 --> 17:07.240
平均に近い値段のものには時折緑が混じっているのがわかる｡

17:08.050 --> 17:11.080
それでは､ 楽しんでいただけたら幸いです｡ 

17:11.080 --> 17:16.360
今のところ､ まだ実際の機械学習モデルを見ていないが､ 心配しないでほしい｡

17:16.390 --> 17:17.290
頑張るんだ｡ 

17:17.380 --> 17:18.280
それではまた次回
