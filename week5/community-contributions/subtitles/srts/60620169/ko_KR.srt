WEBVTT

00:00.080 --> 00:07.280
이런 멋진 비즈니스 결과를 얻고 LLM을 두 번 호출하는 것에 대해 아주 만족스러우시길 바랍니다

00:07.370 --> 00:13.340
스트리밍이라는 걸 추가함으로써 이 결과를 좀 더 만족스럽게 만들 수 있어요 아주

00:13.340 --> 00:19.310
흔한 거죠 채팅에서 경험한 이런 도구에서 볼 수 있습니다 사용자 인터페이스와

00:19.610 --> 00:26.420
스트리밍 채팅에서 정보가 LLM에서 다시 흘러와 타자기 스타일 인터페이스로 나타날

00:26.420 --> 00:27.980
때죠

00:28.430 --> 00:31.670
그 방법은 놀랍도록 간단해요

00:31.760 --> 00:42.350
오픈AI 채팅 완료를 위한 호출을 만들 때 생성할 때 한 번에 다 받고 싶진 않지만 다시

00:42.380 --> 00:48.920
흘러가길 원한다면 다른 매개 변수 스트림을 참으로

00:48.920 --> 00:50.480
넘기면 되죠

00:50.510 --> 00:55.880
클로드를 사용할 때 API가 약간 다른 걸 알게 될 겁니다 하지만 GPT와

00:55.880 --> 00:59.510
클로드가 약간 다른 건 드문 경우죠

00:59.510 --> 01:02.200
GPT 스트리밍 = True에선 이렇게 하는 거예요

01:02.230 --> 01:03.460
그게 무슨 뜻이죠?

01:03.460 --> 01:10.420
스트림으로 돌아온 것은 더 이상 단일 텍스트 응답이 아니라 반복할

01:10.420 --> 01:16.450
수 있는 것을 얻게 됩니다 반복을 하면 각 응답 덩어리가 나타납니다

01:16.450 --> 01:22.510
스트림 프린트 덩어리를 선택하는 거죠

01:22.540 --> 01:27.640
우리 경우엔 그것보다 좀 더 영리해야 해요 왜냐하면 마크다운 비트로 이걸

01:27.640 --> 01:28.750
보여주니까요

01:28.960 --> 01:37.090
사실 좀 성가신 일이에요 마크다운이란 마크다운 캐릭터를 스트림으로

01:37.090 --> 01:43.990
만들 때 그걸 화면에 포함시켜야 하거든요

01:43.990 --> 01:49.600
여기 호키 코드가 좀 있네요 각 비트에 대해 전체 마크다운 버전을 다시 써야 한다는 사실을

01:49.600 --> 01:53.230
처리하기 위해서요 여러분이 살펴볼 수 있게요

01:53.230 --> 01:59.100
기본적으로는 모든 것에 대한 대응을 위한 트랙을 유지해요 모든 덩크가

01:59.100 --> 02:01.980
누적된 트랙을 만드는 거죠

02:01.980 --> 02:09.120
그래서 저는 답변을 받을 때마다 그 부분을 포함해요

02:09.120 --> 02:14.070
실제로 마크다운이라는 단어가 있으면 그 단어는 반응에서 제거해요

02:14.070 --> 02:18.090
마지막으로 전체 디스플레이를 업데이트해 보여드릴게요

02:18.090 --> 02:20.850
비트 코드는 좀 복잡해요

02:20.850 --> 02:24.270
그냥 글만 쓰면 이런 건 필요 없잖아요

02:24.270 --> 02:30.990
이렇게 해야 하는 이유는 멋지게 줄이는 방식으로 보여주고 싶어서예요

02:30.990 --> 02:32.880
무슨 뜻인지 보여 드릴게요

02:32.880 --> 02:38.880
이걸 anthropic에서 반복하면 1분 기다려야 합니다 링크를 먼저

02:38.880 --> 02:42.780
찾고 이 페이지들을 다 얻을 때까지요 이제 됐네요

02:42.810 --> 02:43.560
보세요

02:43.560 --> 02:50.760
익숙한 스트리밍 인터페이스죠 다 됐어요

02:50.760 --> 02:55.320
마크다운이 되어 있어서 링크 같은 것도 get이 된다는 게 좋아요

02:55.320 --> 02:57.680
제가 말하던 걸 보여드릴게요

02:57.680 --> 03:03.590
마크다운에서 디스플레이하는 걸 원치 않는 경우 더 간단한

03:03.590 --> 03:10.550
방법은 스트림에서의 청크를 위한 것 같은 걸 하는 거죠

03:12.560 --> 03:15.260
한 덩어리 인쇄해요

03:15.260 --> 03:20.060
그런 다음 end = 같은 걸 해야 합니다 매번 새 줄을 프린트하는 걸 멈추도록요

03:20.060 --> 03:22.640
제 생각엔 이게∙∙∙ 작동하는지 보죠

03:23.090 --> 03:29.330
이건 그냥 일련의 텍스트 조각으로 프린트할 거예요 마크다운 포맷이 안 나오게요

03:29.330 --> 03:30.890
Get up

03:31.280 --> 03:33.560
그건 안 돼요

03:34.040 --> 03:34.940
미안해요

03:34.940 --> 03:37.850
이건 당연히 청크죠

03:38.810 --> 03:41.720
그냥 이렇게 다 얹는 게 낫겠어요

03:41.720 --> 03:43.940
안 그러면 물체가 뒤로 흐르거든요

03:43.970 --> 03:47.510
제가 이러는 걸 보고 바보라고 생각하셨겠죠

03:47.600 --> 03:49.340
실시간이란 걸 보여주죠

03:49.550 --> 03:51.560
네, 다시 해 보죠

03:51.590 --> 03:53.180
Get it, get it, get it, get it, it, it, it! 이제 더 좋은 결과가 나오는지 보죠

03:53.990 --> 03:58.990
여기에 입력하면∙∙∙ print 문을요

03:58.990 --> 03:59.770
이렇게요

03:59.770 --> 04:01.090
다시 보게 될 거예요

04:01.090 --> 04:01.930
여기요

04:01.960 --> 04:03.700
다시 돌아오죠

04:03.700 --> 04:05.080
아주 간단해요

04:05.080 --> 04:07.450
서식이 별로일 뿐이죠

04:07.450 --> 04:10.510
하지만 코드는 이렇게 하면 정말 간단해요

04:10.510 --> 04:13.570
결과를 스트리밍하는 데 필요한 모든 코드예요

04:13.570 --> 04:18.250
스트리밍 = true를 설정하면 그 방법으로 반복되죠

04:19.180 --> 04:29.170
이제 저걸 제거하고 주석을 제거하겠습니다 여러분이 모르신다면 command와 나눗셈 기호 혹은 Windows에서

04:29.170 --> 04:36.250
Windows 키와 나눗셈 기호는 코드 블록의 주석을 제거하거나 주석을 제거하는

04:36.250 --> 04:39.010
것이죠

04:39.010 --> 04:44.020
유용한 지름길이죠 이걸 다시 실행해 근사한 서식이 있는

04:44.020 --> 04:47.530
athropic을 한 번 더 보죠

04:47.800 --> 04:49.180
연결 고리를 찾죠

04:49.180 --> 04:50.800
또 나오네요

04:50.800 --> 04:55.350
물론 매번 다른 브로슈어가 있어요

04:55.590 --> 04:58.860
이번엔 그렇게 됐네요

04:58.860 --> 05:00.600
이제 다른 회사를 알아보죠

05:00.600 --> 05:07.530
인공지능 엔지니어를 위한 유비쿼털 오픈 소스 플랫폼을 안아보죠

05:07.560 --> 05:09.090
get get 해 볼게요

05:09.120 --> 05:10.800
Get it 링크도 있네요

05:10.800 --> 05:16.380
이제 안아주는 얼굴 책자가 나오네요

05:16.380 --> 05:17.010
특전이죠

05:17.040 --> 05:18.060
Get it 연락 주세요

05:18.060 --> 05:18.780
그리고요

05:18.810 --> 05:21.300
함께 인공지능의 미래를 만들어 나가요

05:21.330 --> 05:22.530
아주 좋아요

05:22.560 --> 05:25.740
좋아요, 더 재미있게 한 가지 더 해보죠

05:25.740 --> 05:31.050
시스템 프롬프트를 생성했던 곳으로 돌아가보죠

05:31.050 --> 05:32.910
어디서요?

05:32.940 --> 05:34.710
저 뒤쪽에서요

05:34.710 --> 05:36.210
시스템 프롬프트예요

05:36.210 --> 05:41.220
시스템 프롬프트의 특징 중 하나는 완료될 작업을 설명하는

05:41.220 --> 05:49.200
곳일 뿐 아니라 톤과 문자에도 대해 얘기합니다 LLM이 콘텐츠를 생성할 때 채택해야

05:49.200 --> 05:50.760
하는 거죠

05:50.760 --> 05:57.690
이걸 주석 처리하고 변형을 해제하죠

05:57.690 --> 05:59.730
이 변형에는 그런 게 포함되죠

05:59.730 --> 06:05.610
짧고, 유머러스하고, 재미있고, 농담조의 브로슈어여야 해요 그 코드를 실행하죠

06:05.820 --> 06:11.970
여기서 아주 노골적으로 사용하기 때문에 System 프롬프트는 다른 곳에서도 언급하는 전역 변수

06:12.000 --> 06:12.600
같아요

06:12.600 --> 06:17.640
이걸 재실행할 필요는 없어요 하드코딩이 돼 있으니까요

06:17.640 --> 06:21.600
여기까지 와서 이걸 그냥 재실행하면 되죠

06:21.630 --> 06:29.760
제 생각이 맞는다면 이제 아주 유쾌하고 재미있는 장면이 나올 거예요 get it get it

06:29.790 --> 06:33.900
안전망이 있는 안드로픽에 잘 오셨어요

06:34.380 --> 06:39.240
앤스로픽에서는 여러분이 믿을 수 있는 인공지능 시스템을 개발합니다 모닝커피보다

06:39.240 --> 06:43.920
더 신뢰할 수 있고 고양이 감정의 변화보다 이해하기 쉽도록요

06:44.670 --> 06:50.100
샌프란시스코의 햇살 나라에서는 인공지능을 적이 아닌 친구로 만들려 하죠

06:50.130 --> 06:57.620
즉각적으로 시스템을 약간 변경했을 뿐인데 이렇게 완전히 다른

06:57.650 --> 07:03.740
회사 브로슈어를 만들 수 있다니 정말 놀라워요

07:03.860 --> 07:07.220
정말 놀라운 일이에요

07:07.430 --> 07:12.860
주석 제거∙∙∙ 주석을 달겠습니다 여러분이 혼란스러워하지 않도록요

07:13.010 --> 07:20.990
이 기회에 이 말을 하고 싶네요 이 실험을 통해 여러분이 깊이 이해할 수 있는 기회가

07:20.990 --> 07:28.460
될 겁니다 어떤 작품이 탄생하든 프롬프트를 통해 개성에 영향을 준다는 게 어떤

07:28.460 --> 07:30.560
의미인지 말이죠

07:30.560 --> 07:32.840
한 단계 더 나아갈 수 있게요

07:32.840 --> 07:36.740
비꼬는 내용으로 책자를 만들어 봐요

07:36.740 --> 07:38.810
스페인어로 책자를 만들어요

07:38.930 --> 07:43.790
다른 언어로 번역할 수 있는 것도 추가해 주세요

07:43.790 --> 07:46.010
다양한 걸 시도해 보는 거죠

07:46.160 --> 07:53.230
이건 아주 중요한 부분이에요 어떻게 프롬프트해서 결과에 영향을 주는지를 학습하는 데 있어서요

07:53.230 --> 07:54.910
Get up

07:55.930 --> 08:01.180
좋아요, 운동 얘기를 너무 많이 하기 전에 그만 끝내죠

08:01.180 --> 08:09.010
오늘 우리가 한 건 첫날에 한 걸 확장했어요 웹 사이트를 요약하기 위해 LM 호출을

08:09.010 --> 08:15.700
하나 하는 대신 LM 1에 두 번 호출해 관련 링크를 수집하고 그 모든

08:15.700 --> 08:21.700
데이터 긁어모음에서 하나 회사 브로슈어를 구축했죠

08:22.000 --> 08:28.210
말씀드렸듯이 이건 거대한 인공지능의 장난감 버전과 같습니다 작은 방식으로요

08:28.210 --> 08:31.600
큰 문제를 작은 단계로 나누고 있으니까요

08:31.600 --> 08:38.410
하지만 여러분께 강조하고 싶은 건 이건 많은 종류의 비즈니스 문제에도 적용 가능하다는

08:38.410 --> 08:43.420
겁니다 이런 종류의 정보를 통합하고 그 결과로 생성하는 거죠

08:43.480 --> 08:49.810
이렇게 제품을 생산하기 위한 마케팅 콘텐츠를 작성할 수 있어요

08:49.930 --> 08:57.240
개인 맞춤형 이메일 콘텐츠를 만드는 튜토리얼 같은 거예요

08:57.300 --> 08:59.670
이메일을 많이 읽으면서요

08:59.670 --> 09:05.310
방법은 아주 많아요 이런 2단계는 데이터를 합성하고 JSON에서 요약하는

09:05.310 --> 09:09.930
거죠 일종의 출력을 구축하는 방법으로 사용해요

09:09.960 --> 09:12.120
다양한 응용 프로그램이 있죠

09:12.120 --> 09:17.730
여러분이 매일 하는 일에 이걸 적용할 방법을 찾아보세요

09:17.730 --> 09:19.920
흥미로운 상업적 각도예요

09:19.950 --> 09:24.990
여러분이 가장 큰 영역 지식을 가진 자신의 전문 분야를 생각할 수 있는

09:24.990 --> 09:25.860
그런 거요

09:25.860 --> 09:31.500
새로 얻은 기술을 어떻게 좋은 일에 쓸 건가요? TUZ

09:31.500 --> 09:33.390
그러니 생각해 보세요

09:33.390 --> 09:40.380
언제든 제 아이디어를 듣고 예를 들어서 깃허브에 올려 보세요

09:40.380 --> 09:47.700
정보를 합성하고 콘텐츠를 생성하기 위해 llms에 다중 호출을 사용하는 좋은 예가

09:47.700 --> 09:48.600
있어요

09:48.630 --> 09:50.400
그럼 다음 영상에서 만나요
