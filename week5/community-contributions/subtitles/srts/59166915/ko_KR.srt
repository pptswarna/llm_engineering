WEBVTT

00:00.440 --> 00:03.560
놀라운 유피터랩의 세계에 잘 오셨어요

00:03.560 --> 00:06.830
이제 2주 차예요

00:07.490 --> 00:09.110
3일째예요

00:09.260 --> 00:11.990
이 공책을 꺼내요

00:11.990 --> 00:18.080
대화형 인공지능인 채팅 봇에 대해 알아보도록 하죠.

00:18.110 --> 00:24.680
먼저 일반적인 가져오기와 환경 변수의 일반적인 설정으로 시작하죠

00:24.680 --> 00:27.620
오픈AI를 초기화하죠

00:27.650 --> 00:29.840
이번에는 오픈아이를 쓸 거예요

00:30.020 --> 00:34.310
원한다면 다른 모델로 바꾸는 연습으로 사용할 수 있어요

00:34.670 --> 00:38.510
기본적인 시스템 메시지부터 시작할게요

00:38.510 --> 00:40.340
정말 도움이 되는 조수네요

00:40.970 --> 00:41.480
좋아요

00:41.510 --> 00:45.800
이제 비트 코드의 메시지 구조를 얘기해 볼게요

00:45.980 --> 00:54.200
먼저 오픈AI에 즉각 메시지를 보내는 구조를 다시 알려주세요

00:54.320 --> 00:58.700
이런 건 이제 질리게 봤으니까 제가 설명하는 게 지겹겠죠

00:58.700 --> 00:59.350
저기 있네요

00:59.350 --> 01:00.010
한 번 더요

01:00.010 --> 01:00.730
잘 아시네요

01:00.760 --> 01:07.840
시스템에 사용자를 제공하는 사전 목록이죠 보조가 응답하고 그 다음 사용자가

01:07.840 --> 01:09.220
응답하는 거죠

01:09.220 --> 01:12.910
다른 게 있다고 말씀드렸죠? 지금은 아니에요

01:12.910 --> 01:13.990
시스템 사용자 보조요

01:13.990 --> 01:14.650
사용자 보조요

01:14.680 --> 01:16.960
사용자 보조 사용자 등등이요

01:17.470 --> 01:21.430
이제 채팅이라는 함수를 쓸 거예요

01:21.430 --> 01:27.400
그 함수 채팅은 두 개의 입력 메시지와 역사를 취할 거예요

01:27.430 --> 01:34.930
이 메시지는 현재 채팅방이 답변해야 할 메시지를 나타내죠

01:34.960 --> 01:41.050
모든 이전의 메시지와 교류는 역사가 기록하고 있죠

01:41.050 --> 01:45.520
역사의 구조는 이렇게 생겼을 거예요

01:45.550 --> 01:50.140
목록이 될 겁니다 목록으로 구성된 목록이죠

01:50.140 --> 01:55.810
이런 하위 목록은 사용자가 뭐라고 대답하고 비서가 뭐라고 대답하고 사용자가 뭐라고

01:55.810 --> 01:58.920
대답하고 비서가 뭐라고 대답하는지 등이죠

01:59.340 --> 02:02.730
왜 이런 부탁을 하는 걸까요?

02:02.760 --> 02:08.340
왜 매개 변수가 있는 저런 함수를 써야 하죠? 왜 이런 인수가 있는 거죠?

02:08.340 --> 02:15.870
그 대답은 그러디오가 채팅 유저 인터페이스와 함께 사용하기 위해 기대하는 특정한 유형의 함수이기

02:15.870 --> 02:16.710
때문이죠

02:16.710 --> 02:22.260
그래서 그라디오는 우리가 메시지를 받는 채팅이라는 함수를 쓰길 기대하죠

02:22.260 --> 02:27.630
이 구조에서 히스토리를 선택하고 응답을 반환할 겁니다 이 채팅에 대한

02:27.630 --> 02:28.590
응답이요

02:28.590 --> 02:30.390
그래서 그 형식을 고려하는 거죠

02:30.390 --> 02:39.420
이 함수에 대한 우리 작업은 이런 종류의 메시지를 여기로 변환하는 거죠

02:39.420 --> 02:47.940
이 구조를 통해 한 열씩 반복해야 합니다 위에 보이는 이 구조를 구축하고요

02:47.970 --> 02:49.710
이해가 되면 좋겠네요

02:49.710 --> 02:53.400
그렇지 않다면 제가 보여드릴 때 이해가 될 거예요

02:53.400 --> 02:56.730
채팅이라는 함수를 정의하고 있어요

02:56.760 --> 03:03.450
입력 메시지에 응답해야 하는 메시지가 필요합니다 이전 메시지의 기록도 필요하고요

03:03.480 --> 03:09.090
먼저 메시지 목록을 설정합니다 이 사람이 되겠죠

03:09.090 --> 03:12.870
시작 부분에 시스템 프롬프트로 채우죠

03:12.900 --> 03:17.010
물론 그런 다음 역사를 반복하겠죠

03:17.040 --> 03:20.460
역사의 각 요소는 두 개의 값을 가진 리스트 중 하나죠

03:20.460 --> 03:24.000
사용자 메시지 비서 메시지에 그걸 풀어놓을게요

03:24.000 --> 03:28.470
사용자 메시지와 보조 메시지를 추가해요

03:28.530 --> 03:30.390
매번요

03:30.390 --> 03:38.310
역사에서 각 행은 이 목록에서 두 행으로 바뀌죠

03:38.310 --> 03:40.650
하나는 사용자를 위한 것 하나는 보조를 위한 것이죠

03:40.770 --> 03:42.480
이해가 되면 좋겠네요

03:42.480 --> 03:43.050
지금요

03:43.200 --> 03:44.250
아니면 언제든 괜찮아요

03:44.280 --> 03:45.240
그럴 필요 없어요

03:45.270 --> 03:47.370
언제든 print문을 넣을 수 있다고 말하려 했어요

03:47.430 --> 03:50.160
제가 선견지명이 있어서 인쇄물도 몇 개 넣었어요 TED TED TED TED

03:50.160 --> 03:51.180
곧 보게 될 거예요

03:51.210 --> 03:54.980
히스토리를 프린트하고 메시지를 프린트할 거예요

03:54.980 --> 03:57.170
Get in get 역시 볼 수 있죠

03:57.530 --> 04:05.120
다음 줄은 이 채팅방에서 아주 익숙하실 텐데요 이 시점에서 이 메서드, 이

04:05.150 --> 04:12.110
함수 죄송합니다, 이 시점에서 이 메시지 세트를 가지고 OpenAI를

04:12.110 --> 04:14.300
호출할 거예요

04:14.300 --> 04:17.810
OpenAI 채팅 .완성 .Create를 입력해요

04:17.810 --> 04:22.970
모델에서 전달하고 메시지를 전달하고 결과를 스트리밍해달라고 요청하죠

04:22.970 --> 04:23.810
그렇게 하죠

04:23.810 --> 04:27.200
그런 다음 검토하고 응답을 유도하죠

04:27.440 --> 04:30.170
다시 말씀드리지만 이건 함수가 아니에요

04:30.170 --> 04:35.900
하나씩 반응을 산출하기 때문에 발전기라고 할 수 있죠

04:36.800 --> 04:37.280
네

04:37.280 --> 04:45.500
이제 이걸 좀 전에 슬라이드에서 본 사용자 인터페이스로 바꿀 거예요 인스턴트 메시지 스타일

04:45.500 --> 04:49.850
상호 작용이 있는 사용자 인터페이스요

04:49.850 --> 04:54.580
할 일이 많아요 비트가 계속 오는 메시지를

04:54.580 --> 05:01.360
캔버스로 만들어서 어떻게 만들지 알아내야 하니까요

05:01.420 --> 05:06.430
이 채팅창에 올라온 반응을 보면요

05:06.940 --> 05:10.300
눈치챘는지 모르겠지만 당연히 거짓말이죠

05:10.300 --> 05:11.770
아주 쉬울 거예요

05:11.770 --> 05:12.910
아주 쉬울 거예요

05:12.910 --> 05:14.470
한 줄로 할 거예요

05:15.310 --> 05:21.460
그러디오는 채팅 인터페이스라는 독창적인 걸 내놓는데 채팅 인터페이스는

05:21.460 --> 05:25.540
이런 구조를 가진 단일 함수를 기대하죠

05:25.540 --> 05:31.300
이 특정한 형식으로 메시지와 역사를 취하는 함수를 작성했다면 Gadio에선

05:31.300 --> 05:34.240
코드 한 줄로 끝나죠

05:34.480 --> 05:36.670
그렇게 쉬운지 볼까요?

05:36.670 --> 05:42.610
저걸 실행하는 걸 기억해야 합니다 채팅 생성기를 정의하도록요

05:42.610 --> 05:46.510
이제 인터페이스를 실행할 거예요

05:46.510 --> 05:47.770
여기 있네요

05:47.770 --> 05:49.890
채팅 인터페이스예요

05:50.190 --> 05:53.730
다른 창으로 보여드리죠 그게 더 좋거든요

05:53.730 --> 05:55.830
이렇게 말해요

05:55.830 --> 05:56.970
안녕하세요

05:59.070 --> 06:00.000
안녕하세요

06:00.030 --> 06:01.410
무엇을 도와드릴까요?

06:01.530 --> 06:05.220
넥타이 하나 사려고요

06:06.780 --> 06:09.270
어떤 넥타이를 찾으세요?

06:09.300 --> 06:11.730
특정한 색상, 패턴이나 재료가 있나요?

06:12.210 --> 06:14.160
Get it, get it, get it. 대충 아시겠죠?

06:14.430 --> 06:22.830
하지만 빨간색 넥타이는 고전적인 선택이에요

06:22.830 --> 06:24.510
몇 가지 선택지를 드리죠

06:24.510 --> 06:26.340
답이 나왔네요

06:26.820 --> 06:31.470
빨간색을 고른 이유는 여러분이 이미 아는 걸 보여드리고 싶었기 때문이에요

06:31.470 --> 06:35.940
이 대화의 맥락을 갖고 있고 전에 뭐가 있었는지도 알죠

06:35.970 --> 06:43.800
다시 한번 말씀드리지만 비트가 처음 대화했을 때의 메모리를 가진 것 같아요

06:43.800 --> 06:45.180
넥타이를 사고 싶다고 했어요

06:45.210 --> 06:51.630
우리가 상호 작용할 때마다 채팅 메서드, 함수 생성기가 결국엔 제대로 작동해요 get

06:51.630 --> 06:52.410
it

06:52.440 --> 06:55.290
채팅 생성기가 호출됐어요

06:55.470 --> 06:58.860
지금까지의 역사를 전부 담고 있어요

06:58.860 --> 07:03.720
메시지 집합을 구축하고 오픈AI에 전송하는 거죠

07:03.750 --> 07:07.470
통화 내역이 전부 제공되고 있어요

07:07.470 --> 07:10.980
그래서 이전의 맥락이 있는 거예요

07:10.980 --> 07:17.970
LLM도 아니고 GPT 4도 아닙니다 30년 전에 했던 말을 기억하는 것도 아니죠

07:17.970 --> 07:20.520
출동할 때마다 전부 전달해요

07:20.520 --> 07:22.080
이쯤 되면 눈치채셨겠지만요

07:22.080 --> 07:26.010
장황하게 말해서 미안하지만 염장 지르는 게 중요하다고 생각해요

07:26.400 --> 07:31.650
네, 기억하세요? 아래에 print문이 있는데 지금은

07:31.650 --> 07:35.130
꽤 두툼하죠 마지막 걸 보죠

07:35.130 --> 07:41.700
마지막 건 역사고 이건 그래디오가 보낸 거예요

07:41.730 --> 07:48.500
그럼 보일 거예요 우리가 말한 대로 우리가 말한 대로요

07:48.890 --> 07:56.480
그리고 GPT 40을 위해 올바른 포맷으로 변환했죠

07:56.510 --> 07:57.950
GPT 4 미니요

07:58.100 --> 08:02.000
역할 시스템 콘텐츠 목록으로 변환했어요

08:02.000 --> 08:03.110
정말 도움이 되는 조수네요

08:03.110 --> 08:05.360
사용자가 안녕하세요라고 하죠

08:05.360 --> 08:07.910
그러자 조수가 어떻게 도와드리면 되냐고 물었어요

08:07.910 --> 08:08.540
계속해서요

08:08.540 --> 08:11.450
그래서 이렇게 바꿨죠

08:12.530 --> 08:18.530
좋아요, 시작하기 전에 잠깐 옆길로 새죠 중요한 거예요

08:18.530 --> 08:20.420
나 혼자 떠드는 게 아니에요

08:20.420 --> 08:24.230
당신과 함께 그 씨앗을 뿌리고 싶어요

08:24.230 --> 08:30.200
나중에 다시 얘기하겠지만 중요한 부분이에요 어쩌면 당신이 생각해둔

08:30.200 --> 08:31.670
것일 수도 있고요

08:31.730 --> 08:33.590
그렇지 않다면 그래야겠죠

08:33.800 --> 08:42.020
언급하자면 이렇게 생각하실 수 있어요 시스템 사용자 비서가 이 구조에 대해서요

08:42.140 --> 08:43.480
이것도 그래요

08:43.510 --> 08:49.960
어떤 구조적인 방법으로 LLM에 Get이 전달되나요?

08:49.960 --> 08:56.860
우리가 어떻게든 이 데이터를 LLM에 제공할 때 사전이나 사전 목록

08:56.890 --> 09:00.160
같은 어떤 식으로 제공되나요?

09:00.280 --> 09:04.300
LM은 토큰만 받는 줄 알았거든요

09:04.300 --> 09:08.290
토큰의 리스트를 선택하고 가장 가능성이 높은 다음 토큰을 생성하죠

09:08.290 --> 09:13.990
그럼 이 사전 전체 목록은 어떻게 토큰의 세계로 변환하죠?

09:13.990 --> 09:16.300
그런 생각을 한다면 정말 좋을 거예요

09:16.300 --> 09:17.680
아주 좋아요

09:17.680 --> 09:25.390
답은 간단합니다. 토큰을 전달하는 것입니다. 실제 GPT 4개,

09:25.420 --> 09:29.290
GPT 4개 LLM으로요.

09:29.290 --> 09:39.760
오픈AI는 이것을 토큰의 시리즈로 바꾸어 놓습니다. 특별한 토큰을 가지고 있는데 시스템 프롬프트의

09:39.760 --> 09:44.430
시작이라고 설명하는 방법이죠.

09:44.430 --> 09:47.670
사용자와 보조 대응의 시작이죠

09:47.670 --> 09:55.080
그 말을 하는 마크업이 있고 그 전체 마크업을 토큰화합니다 LLM에 정보를 전달하는

09:55.080 --> 09:59.010
특별한 자리 표시자 토큰을 포함해서요

09:59.010 --> 10:01.410
이제 시스템 프롬프트 모드로 바꿀게요

10:01.410 --> 10:02.880
시스템 프롬프트 텍스트가 있네요

10:02.880 --> 10:04.500
이제 시스템 프롬프트 모드에서 벗어났어요

10:04.530 --> 10:07.410
사용자 메시지 같은 걸 하고 있죠

10:07.410 --> 10:11.460
이 구조가 OpenAI API 전송이에요

10:11.490 --> 10:13.980
패로 변환하죠

10:13.980 --> 10:19.470
이 토큰들이 LLM에 입력되어 get 다음 토큰을 예측하죠

10:19.950 --> 10:24.300
Get it, get it, get it's right, get's right, right.

10:24.300 --> 10:32.760
그런데 LLM은 이 특별한 토큰이 시스템 메시지를 의미한다는 것과 이를 높은 수준의 지시로 해석해야

10:32.760 --> 10:35.340
한다는 것을 어떻게 알까요?

10:35.340 --> 10:39.180
이 토큰이 사용자를 의미하고 이건 비서를 의미한다는 걸 어떻게 알까요?

10:39.210 --> 10:43.740
어떤 식으로든 그런 능력을 아키텍처에 구현한 건가요?

10:44.040 --> 10:46.590
그에 대한 답은 아주 간단해요

10:46.590 --> 10:49.530
아뇨, 그렇게 훈련받았으니까요

10:49.560 --> 10:54.270
많은 데이터와 구조로 훈련되었고 수백만 개의 예로 훈련되었어요

10:54.270 --> 11:00.300
시스템 지침에서 특정 지침을 받았을 때 다음 토큰과 반응은

11:00.300 --> 11:07.440
시스템 프롬프트를 준수하는 것이라는 것을 배우게 되죠

11:07.470 --> 11:09.510
너무 단순화했어요

11:09.510 --> 11:14.940
뉘앙스가 좀 더 있어요 셰프 같은 기술과 관련해서요

11:14.940 --> 11:18.570
비트 박스를 아는 사람들은 너무 단순화됐다고 하겠지만 그게 일반적인

11:18.570 --> 11:19.770
개념이에요

11:19.770 --> 11:21.090
기본 아이디어예요

11:21.090 --> 11:24.540
이 구조는 일종의 API 구조예요

11:24.540 --> 11:27.390
오픈AI에 우리가 원하는 걸 이렇게 전달하는 거죠

11:27.390 --> 11:31.170
오픈아이는 그 구조를 토큰으로 바꾸죠

11:31.170 --> 11:38.390
그럼 이제 처음으로 넘어가서 그라디오는 이런 포맷의 데이터를 주죠

11:38.420 --> 11:47.300
이것을 OpenAI에 보내는 이 형식에 매핑합니다 OpenAI는 이것을 특별한 토큰을 포함한 토큰으로

11:47.300 --> 11:48.680
변환하죠

11:48.680 --> 11:54.740
지금까지의 모든 대화에 해당하는 LLM으로 들어갑니다 대화 전체를

11:54.740 --> 12:01.460
담을 때마다 가장 그럴듯한 다음 토큰 배열을 생성하죠 그다음으로 나올 가능성이

12:01.460 --> 12:04.400
가장 큰 토큰요

12:04.490 --> 12:12.770
그게 우리에게 돌아오는 거고 우린 그걸 원조 대응이라고 생각하죠

12:12.980 --> 12:15.860
그래서 그게 꽤 긴 사이드바라는 걸 깨달았죠

12:15.860 --> 12:18.740
아주 중요한 기본적 이해예요

12:18.740 --> 12:22.190
다시 돌아오죠 특히 오픈 소스 모델을 볼 때요

12:22.190 --> 12:28.190
생성된 토큰들을 직접 볼 것입니다. 특별한 토큰들을요.

12:28.340 --> 12:34.880
다음 비디오까지 잠시 멈추겠습니다 그때 이 챗봇을 만들

12:34.880 --> 12:35.780
거예요
