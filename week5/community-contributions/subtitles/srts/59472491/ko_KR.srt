WEBVTT

00:00.620 --> 00:01.790
잘 돌아왔어요

00:01.790 --> 00:07.370
유피터랩에서 저와 함께 하고 계신다면 커피 마시는 동안 잠시 꺼두세요

00:07.370 --> 00:12.620
모든 데이터셋을 다운로드하는 데 20분 정도 걸리거든요 하지만

00:12.620 --> 00:16.550
이제 정성껏 다운로드해서 다듬어질 거예요

00:16.550 --> 00:17.750
여기 있네요

00:17.780 --> 00:23.810
자동차용은 가장 크고 데이터 포인트와 사무실이 900,000개 이상이죠

00:23.870 --> 00:27.830
전자 제품은 400,000개가 넘어요

00:27.830 --> 00:29.600
총합이요

00:29.600 --> 00:30.980
뭐가 있는지 보죠

00:30.980 --> 00:36.410
총 2마리가 조금 넘어요 데이터 포인트가 8백만 개예요

00:36.410 --> 00:38.120
데이터 포인트가 많네요

00:38.120 --> 00:39.680
데이터 포인트가 너무 많아요

00:39.680 --> 00:43.580
우리가 할 훈련에는 그런 숫자가 필요 없어요

00:43.640 --> 00:50.480
즉, 이 데이터셋을 연마하고 가장 가치 있는 데이터 포인트를 선택하고 가장

00:50.480 --> 00:54.020
많은 신호를 줄 기회가 있다는 거죠

00:54.020 --> 00:59.480
그럼 먼저 패가 얼마나 있는지 분배하는 걸 다시 살펴보죠

00:59.510 --> 01:05.310
지난 번과 같은 도표입니다 훈련 프롬프트에는 180개 이상의

01:05.310 --> 01:10.440
토큰이 없습니다 오픈 소스 라마 모델을 잘 조정하기 위해서

01:10.440 --> 01:17.160
이렇게 설정했습니다 또한 개척자 모델에서는 비용을 절감하기 위해서이기도

01:17.160 --> 01:19.350
하죠

01:19.890 --> 01:22.050
가격을 다시 보죠

01:22.290 --> 01:29.850
이건 2백만 달러 정도에 걸친 전체 가격 분배입니다 보다시피 999달러

01:29.880 --> 01:33.690
이하로 제한돼 있죠

01:33.780 --> 01:39.510
1과 999 사이예요 그게 제약 조건이거든요 관리 가능한 데이터 집합을

01:39.510 --> 01:45.060
확보하려면요 훈련 전체를 왜곡하는 터무니없는 예외 없이요

01:45.450 --> 01:51.150
하지만 여전히 같은 문제가 있어요 데이터 세트가 작은 숫자로 많이 편향돼

01:51.150 --> 01:52.200
있죠

01:52.230 --> 01:55.320
길이 아주 얇아요

01:55.320 --> 01:57.660
이건 300달러까지밖에 안 돼요

01:57.720 --> 02:05.460
1,000까지 올릴 수 있다면 데이터 집합의 끝까지 올릴 수 있어요

02:05.490 --> 02:06.030
여기요

02:06.060 --> 02:06.540
보세요

02:06.540 --> 02:07.110
여기예요

02:07.140 --> 02:14.850
909까지 도달하는 데이터 포인트가 있어요 49개요, 근데 잘 안 보여요

02:14.850 --> 02:18.840
축에 거의 닿지 않아요

02:18.960 --> 02:30.030
데이터 세트가 800,000개 정도에 지배당하기 때문에 낮은 비용 포인트로 접근하는 거죠

02:30.480 --> 02:34.170
한 가지 더 할 일은 카테고리를 빠르게 살펴보는 거예요

02:34.170 --> 02:40.110
이 멋진 막대 차트는 얼마나 많은지 보여줍니다 제품의 다양한 데이터 카테고리에 각각 얼마나

02:40.140 --> 02:40.920
있는지요

02:40.920 --> 02:44.970
다시 900,000점으로 자동차가 우세하네요

02:44.970 --> 02:51.510
그 다음은 도구와 집 꾸미기입니다 전자 제품 번호는 400,000고요

02:51.510 --> 02:59.580
지금 우리가 하고자 하는 것 중 하나는 데이터를 좀 더 균형 잡힌 데이터 집합을 가질 수 있도록 다듬는 겁니다

02:59.580 --> 03:06.810
왜냐하면 하나의 특정 카테고리에서 하나의 가격에 대해 더 왜곡되어 배우는 쪽으로 모델이

03:06.810 --> 03:09.670
편향되는 건 원치 않으니까요

03:09.790 --> 03:15.310
가격이 싼 곳을 선호해도 저희는 괜찮아요 그게

03:15.310 --> 03:17.380
현실이니까요

03:17.530 --> 03:23.110
하지만 훈련에 방해가 될 정도로 너무 멀리 가면 안 돼요

03:23.350 --> 03:31.090
그래서 지금 하려는 건 데이터셋 샘플을 선택하는 겁니다 데이터셋에서 선택해 더 작은

03:31.090 --> 03:37.960
데이터셋을 확보하는 거죠 가격과 카테고리를 더 잘 나타낼 수 있도록요

03:37.960 --> 03:42.910
제가 원하는 데이터 집합 사이즈는 약 400,000개의 데이터 포인트예요

03:42.940 --> 03:48.100
미세 튜닝 목적으로 큰 데이터 세트지만 그렇게 클 필요는 없어요

03:48.130 --> 03:50.290
하지만 전 데이터 모음이 컸으면 했어요

03:50.290 --> 03:52.420
그래서 400,000달러로 정했어요

03:52.510 --> 03:54.910
어떻게 하는지에 대해 얘기해 보죠

03:55.000 --> 04:00.580
먼저 슬롯머신이라는 사전을 만들었어요

04:00.580 --> 04:01.810
이게 뭔지 말씀드리죠

04:01.840 --> 04:04.060
그럼 내가 왜 그랬는지 이해할 거예요

04:04.090 --> 04:12.980
슬롯머신은 사전인데 사전의 키가 제품의 모든 달러 가격이죠

04:12.980 --> 04:17.720
1달러에서 9달러로 늘었어요 99, 1, 2, 3 999까지 쭉 가세요

04:17.720 --> 04:21.830
이 사전의 열쇠는 999개예요

04:21.830 --> 04:29.570
값은 해당 가격이 있는 모든 제품의 목록이 되겠죠

04:29.570 --> 04:36.590
슬롯 사전에 2번 슬롯에 있는 모든 항목이 2달러짜리 목록으로 나와 있어요

04:36.620 --> 04:39.860
모든 걸 이 구멍에 정리하는 거죠

04:39.860 --> 04:43.100
데이터 세트를 버킷으로 만드는 거죠

04:43.370 --> 04:46.010
이해가 되면 좋겠네요

04:46.010 --> 04:47.750
아니면 이 코드를 불러오고요

04:47.750 --> 04:48.380
통과해요

04:48.380 --> 04:54.710
Defaultexpt를 사용하고 있는데 기본적으로 사전이죠

04:54.710 --> 05:00.800
사전에서 빠진 게 있으면 자동으로 초기화해 넘겨주는 형식이 뭐든

05:00.800 --> 05:01.940
돼요

05:01.970 --> 05:06.230
코드에 일종의 if 테스트를 둘 필요가 없죠

05:06.230 --> 05:08.900
멋지고 우아한 코드를 만들죠

05:08.900 --> 05:14.430
비트가 있는 함수가 있는데 제가 설명해 드릴게요

05:14.460 --> 05:14.850
아미티요

05:14.880 --> 05:15.360
아미티요

05:15.420 --> 05:16.170
주피터 공책이에요

05:16.170 --> 05:16.740
휴대폰요

05:17.010 --> 05:21.390
여기 있는 모든 구멍을 통과할 거예요

05:21.420 --> 05:23.760
999개의 슬롯이 있어요

05:23.760 --> 05:30.870
저 슬롯에서 데이터 하위 집합을 샘플로 만들 거예요 훈련에 사용하기에 좋은 대표

05:30.870 --> 05:33.090
샘플이 될 것 같아요

05:33.240 --> 05:40.470
어떤 건 제가 제멋대로 변형했어요 이것 다음에 나올 조직 문자에도 익숙해질

05:40.470 --> 05:41.640
때까지요

05:41.640 --> 05:45.390
특별한 이유 같은 건 없어요

05:45.390 --> 05:50.160
시행착오의 사례에 더 가깝죠 여러분이 생산하는 균형 잡힌 데이터셋에 대해 만족할 수 있는

05:50.160 --> 05:51.330
지점까지 가는 거예요

05:51.330 --> 05:56.460
물론 훈련을 통해 스스로 만족하게 되죠 이렇게 함으로써 더

05:56.460 --> 05:59.040
좋은 결과를 얻을 수 있다고요

05:59.400 --> 06:05.370
그래서 저는 차례대로 칸을 하나씩 통과했어요 240달러 이상의

06:05.370 --> 06:09.930
가치가 있는 물건은 칸 전체를 다 가져갔죠

06:09.960 --> 06:12.870
그 모든 점을 제 샘플에 추가해요

06:13.320 --> 06:13.950
네

06:14.400 --> 06:16.710
적어도 less로요

06:16.710 --> 06:24.930
여기 코드가 있는데 샘플이 1,200개예요

06:24.930 --> 06:29.790
그래서 그 구멍에 수천 개의 공간이 있을 수 있죠

06:29.820 --> 06:37.830
1200개를 골라서 선택이라는 누피 기법을 사용합니다 특정 숫자를 고를 수 있게

06:37.830 --> 06:39.090
해주는 거죠

06:39.090 --> 06:43.920
선택기의 장점 중 하나는 무게라는 걸 입력할 수 있다는 거예요

06:43.920 --> 06:48.870
어떤 물건의 중요성을 다른 물건보다 높일 수 있다는 거죠

06:48.870 --> 06:53.970
무게추가 잘 어우러졌으면 좋겠어요

06:53.970 --> 07:00.330
자동차에 들어가는 모든 건 1kg이고 나머지는 5kg이라고

07:00.330 --> 07:02.160
가정해 보죠

07:02.310 --> 07:07.290
이 부분도 여러 가지로 시도해봤죠 어떤 곡이 나올지 익숙해질

07:07.290 --> 07:08.160
때까지요

07:08.160 --> 07:14.070
너무 멀리 가고 싶진 않았어요 현실 세계에 있는 데이터의 유형을 대략 유지하고

07:14.070 --> 07:15.930
싶었거든요

07:15.930 --> 07:19.700
하지만 데이터 집합의 불균형을 바로잡고 싶었어요

07:19.820 --> 07:23.570
한 줄씩 설명하진 않을 거예요

07:23.570 --> 07:29.900
제가 구상한 걸 보고 만족하셨으면 좋겠어요 제가 말한 대로 되고 결과물이

07:29.900 --> 07:32.900
마음에 들면 좋겠어요

07:32.900 --> 07:37.550
물론 데이터 세트를 약간 다르게 만들고 싶다면 지금이 기회예요 비트

07:37.610 --> 07:43.880
모델 성능 측면에서 제 결과를 이길 가능성도 충분히 있습니다 카테고리마다

07:43.880 --> 07:49.580
다른 무게를 두거나 다른 슬롯을 선택하는 게 낫다고 생각할

07:49.730 --> 07:52.010
수도 있죠

07:52.010 --> 07:57.170
그러니 실험을 해 보고 결과를 봐야죠

07:57.170 --> 07:59.270
하지만 지금은 제가 운영해요

07:59.270 --> 08:07.460
이제 샘플 리스트를 생성했고 그 샘플 안에 408,000개의 데이터 포인트가 있어요

08:07.460 --> 08:10.040
이 정도 크기로 만들 거예요

08:10.460 --> 08:14.360
이제 가격 분배 결과를 보죠

08:14.360 --> 08:18.230
가격 분배 측면에서 훨씬 합리적으로 보이죠

08:18.230 --> 08:24.710
더 저렴한 제품도 많지만 저렴한 제품의 가격은 일정하게 유지돼요

08:24.740 --> 08:32.510
더 비싼 가격으로 넘어가면 더 비싼 데이터 포인트가 완벽하게 갖춰져 있어요.

08:32.540 --> 08:37.160
흥미로운 효과를 보실 거예요 다양한 포인트가 있죠

08:37.160 --> 08:44.420
예상대로 399, 499달러로 가격을 매긴 것들은 데이터 포인트가 얼마나 많은지 측면에서

08:44.420 --> 08:46.100
약간 상승하죠

08:46.130 --> 08:48.530
현실 세계를 반영해서 좋아요

08:48.530 --> 08:51.140
데이터 집합에 있는 게 좋아요

08:51.140 --> 08:53.840
그 문제를 해결하고 싶지 않아요

08:54.230 --> 09:01.760
이 가격 조직도표와 아까 보여드린 가격 조직도표를 비교하면 데이터에서

09:01.760 --> 09:07.220
가격 분배가 얼마나 개선됐는지 바로 아실 거예요

09:07.250 --> 09:12.080
현실 세계는 여전히 삐뚤어져 있어요

09:12.170 --> 09:16.070
하지만 더 비싼 제품을 더 잘 보여주는 곳이 있어요

09:16.070 --> 09:23.220
그러면 품질 좋은 방법으로 배울 수 있고 샘플의 유효성을 더 확인할 수 있죠

09:23.250 --> 09:26.700
그게 만족스럽지 않다면 데이터 세트를 몇 개 생성하세요

09:26.730 --> 09:32.130
훈련할 때 둘 다 시도해보고 균형 잡힌 데이터셋의 영향을 볼 수 있어요.

09:32.130 --> 09:33.120
Get it

09:33.900 --> 09:36.810
카테고리를 다시 보죠

09:36.930 --> 09:38.640
주제별로 나눠요

09:38.640 --> 09:40.500
사실 큰 차이는 없었어요

09:40.500 --> 09:42.030
약간 기울었어요

09:42.210 --> 09:44.760
비트가 더 잘 맞거든요

09:44.820 --> 09:51.990
더 바로잡고 싶지 않았어요 결국 이 그림은 현실을 반영한다고 생각했거든요

09:51.990 --> 09:54.360
너무 왜곡하면 안 돼요

09:54.360 --> 10:00.630
자동차 제품을 파는 곳이 다른 곳보다 많아요

10:00.630 --> 10:04.950
이 정도면 괜찮은 것 같지만 불균형이 약간 수정됐어요

10:05.130 --> 10:08.370
파이 차트를 보는 다른 방법도 있을 것 같아요

10:08.370 --> 10:13.410
일반적으로 파이 도표는 데이터 과학자들에게 인기가 없어요 바

10:13.410 --> 10:18.210
도표가 양을 나란히 보고 정량적으로 보는 데 더 좋거든요

10:18.420 --> 10:23.400
파이 도표는 시각적으로 유용할 때가 있죠, 한번 볼까요?

10:23.490 --> 10:31.470
카테고리별 파이 차트가 있습니다. 이 단어들을 구분하려면 작업을 좀 해야겠지만, 어떤 느낌인지 아시겠죠.

10:31.470 --> 10:33.180
비트 주세요.

10:33.390 --> 10:40.530
자동차 업계의 지분이 가장 크다는 걸 보여주지만 그렇게 압도적이진

10:40.530 --> 10:42.150
않아요

10:42.150 --> 10:45.600
이 두 개를 합치면 자동차 이상의 의미가 있죠

10:45.660 --> 10:47.340
그러니 합리적이죠

10:47.340 --> 10:50.460
여기 작은 건 가전제품이에요

10:50.460 --> 10:57.510
어제 처음 시작한 건 파이에서 1%가 가장 작은 조각이에요

10:57.510 --> 10:59.400
이 경우엔 말 그대로요

11:00.000 --> 11:04.020
이게 우리 데이터 세트 큐레이팅이에요

11:04.020 --> 11:07.170
비트 좀 썼다고 인정할게요

11:07.170 --> 11:13.200
샘플링처럼 가시 돋친 부분을 광택제로 닦았어요

11:13.350 --> 11:19.350
다시 와서 살펴보고 스스로 평가해서 더 나은 데이터 세트를 만들길

11:19.350 --> 11:20.190
바라요

11:20.370 --> 11:25.260
허브에 업로드 하기 전에 마지막으로 분석할 거예요

11:25.260 --> 11:27.630
다음 영상에서 다시 만나요
