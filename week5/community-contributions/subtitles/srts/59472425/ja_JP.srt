WEBVTT

00:00.590 --> 00:03.110
第6週､ 3日目へようこそ｡ 

00:03.140 --> 00:09.950
今日は､ あなたの好みに応じて､ 好きになるか嫌いになるかのどちらかの日になるだろうが､

00:09.950 --> 00:12.470
中間はないだろう｡

00:12.500 --> 00:18.410
あなたが伝統的な機械学習が好きか､ 興味があるかによって､ 素晴らしい一日になるか､

00:18.410 --> 00:24.380
惨めな一日になるかが分かれるだろう｡ 今日は､ 過去に一歩さかのぼって､ 基礎的な機械学習を見て､

00:24.380 --> 00:31.160
昔はどうだったかの実践的な例をいくつか紹介しよう｡

00:31.370 --> 00:36.740
だから､ このイントロで､ しかもたった1日だけなら､ たとえあなたがとても不愉快に思うことであっても､

00:36.740 --> 00:38.270
我慢できるはずだ｡

00:38.420 --> 00:51.020
さて､ ざっと思い出すと､ すでにできることは､ フロンティアモデル､ ツールを使ったAIアシスタントの構築､ パイプラインやトークナイザーやモデルを使ったハグフェイスのようなオープンソースモデルを使った作業だ｡

00:51.020 --> 00:55.520
ロング・チェーンを使えば､ 完全なラグ・パイプラインを構築することができる｡ 

00:55.520 --> 01:01.910
そして実際､ ご覧いただいたように､ ロングチェーンなしでも､ 少なくともかなり､ 完全に可能なのだ｡

01:01.910 --> 01:07.140
ラインチェーンを使えば手っ取り早いが､ ラグに特別なマジックがあるわけではないことはご存知の通りだ｡

01:07.170 --> 01:13.020
そして､ 商業的な問題を解決するための5段階の戦略について話してきた｡ 

01:13.020 --> 01:16.140
そして､ 私たちはデータについて本当に深く知っている｡ 

01:16.140 --> 01:18.030
深く考えすぎなければいいのだが

01:18.120 --> 01:20.430
この経験を乗り越えられたことを願っている｡ 

01:20.430 --> 01:21.750
私たちはデータを使って多くの仕事をした｡ 

01:21.750 --> 01:23.460
たくさんのチャートを見た｡ 

01:23.490 --> 01:31.350
アイテム・クラスとアイテム・ローダーについては､ おそらく意図していた以上に詳しくなっていることだろう｡

01:31.560 --> 01:34.740
しかし､ この時点で我々は自分たちのデータを隅から隅まで把握している｡ 

01:35.010 --> 01:38.250
今日はベースラインについて話そう｡ 

01:38.280 --> 01:41.550
ベースライン・モデルとは何か､ なぜそれが重要なのかについてお話しします｡ 

01:41.550 --> 01:47.790
そして､ ベースラインモデルと､ より伝統的な機械学習で遊んで､

01:47.790 --> 01:55.920
派手なLMのようなものを使わなくても､ どれだけのことができるかを調べるんだ｡

01:56.040 --> 02:00.060
ええと､ 明日､ フロンティアに行く前にね｡ 

02:00.060 --> 02:04.730
それでは早速､ ベースラインについて少し話をしよう｡ 

02:04.730 --> 02:11.540
だから､ 問題に取り組むならシンプルなものから始めるというのが､ ほとんど常識的なことなんだ｡ 

02:12.200 --> 02:22.520
しかし､ 特にデータサイエンスの世界では､ いくつかの理由から根本的に重要なことなのだ｡

02:22.790 --> 02:29.000
明らかなのは､ 私たちが進歩を測るための一種の基準を与えてくれることだ｡ 

02:29.000 --> 02:37.190
シンプルで伝統的なものから始めれば､ 高度なディープ・ニューラル・ネットワークを適切に使っていることがわかる｡

02:37.190 --> 02:43.070
針が動いているのを見たり､ ベースラインなしではるかに大きな高みを目指しているのを見ると､ 素晴らしい結果を得ているのか､

02:43.070 --> 02:50.570
それとも不愉快な方向に小さな一歩を踏み出しているだけなのか､ わからなくなってしまうのだ｡

02:50.750 --> 02:52.970
だから､ その目安になるのは明らかだ｡ 

02:53.090 --> 02:57.920
あ､ でも､ もうひとつあって､ llmsが必ずしも正しい解決策とは限らないんだ｡ 

02:57.920 --> 03:05.100
実際､ 我々が解決しようとしている具体的なビジネス上の問題は､ 商品の価格を予測することなんだ｡

03:05.100 --> 03:11.220
というのも､ 先ほども言ったように､ 説明文から価格や数字を生成するのは､

03:11.250 --> 03:23.970
より伝統的なNLPや線形回帰であり､ 機械学習の分野に属するように思えるからだ｡

03:24.000 --> 03:25.560
伝統的な機械学習｡ 

03:25.590 --> 03:29.850
そうなると､ ベースラインを構築することがより重要になる｡ なぜなら､ そうしてフロンティアモデルを試してみても､

03:29.850 --> 03:33.600
それ以上の結果は得られないからだ｡

03:33.600 --> 03:38.820
だから､ 当たり前のことなんだけど､ なぜこんなことをするのかを説明してくれるんだ｡ 

03:39.000 --> 03:43.140
さて､ 今日はどんなモデルで勝負しようか｡ 

03:43.170 --> 03:44.310
しかもたった1日だけだ｡ 

03:44.310 --> 03:46.860
こんなことに費やすのは一度きりだ｡ 

03:46.860 --> 03:50.550
そして､ あなたがすでにこれらのモデルに精通しているなら､ それは本当に価値がある｡ 

03:50.550 --> 03:55.710
もし､ あなたが初めて商業的な問題に触れるのであれば､

03:55.710 --> 04:02.550
私たちの特定の商業的な問題についての興味深い簡単な実験になるだろう｡

04:02.940 --> 04:06.620
まず最初に､ ビジネス上の問題を取り上げます｡ 

04:06.620 --> 04:09.080
私たちは､ とても古風なことをするつもりだ｡ 

04:09.080 --> 04:11.870
フィーチャー・エンジニアリングと呼ばれることをするつもりだ｡ 

04:11.870 --> 04:21.530
データを理解し､ さて､ 価格に影響を与えそうな重要な要因は何だろう？

04:21.530 --> 04:25.220
そして､ 私たちは機能と呼ぶべきものを考え出そうとする｡ 

04:25.220 --> 04:33.680
そして､ アマゾンのベストセラーランキングの順位はどうなのか､ といったような､ ごく当たり前の特徴を考えていきます｡

04:33.980 --> 04:42.500
そして､ これらの特徴の線形結合が価格を予測するのに有効かどうかを試してみる｡

04:42.500 --> 04:47.720
そして､ 機械学習モデルを扱う場合､ そこから始めることが多い｡ 

04:48.050 --> 04:56.180
これは自然言語処理の最初の試みのひとつだ｡

04:56.210 --> 05:02.240
NLP Bag of Wordsは特に単純化されたアプローチで､ 文字通り単語の数を数え上げ､

05:02.240 --> 05:11.130
この説明文の中で各特定の単語が何回登場するかという小さなベクトルを構築する｡

05:11.130 --> 05:19.620
つまり､ ある単語があったとして､ その単語にはストップワードと呼ばれるものは含まれない｡

05:19.830 --> 05:30.600
しかし､ もしインテルのような単語があるとすれば､ それはラップトップやコンピューターに一定の価値があることを示すかもしれない｡

05:30.600 --> 05:35.580
そして､ それが現れるかどうか､ あるいは現れたとしても何回現れるかによって､

05:35.580 --> 05:37.200
その場所に影響が出る｡

05:37.290 --> 05:44.670
ええと､ この単語袋の中にある､ 各商品に含まれる単語数のリストです｡ 

05:44.850 --> 05:50.250
そして､ その単語の袋を取り出し､ これらの異なる単語を組み合わせたときに､

05:50.250 --> 05:55.470
商品の価格を予測する線形結合があるかどうかをもう一度調べます｡

05:56.220 --> 06:01.980
これは､ 最初の本格的なニューラルネットワークの1つで､

06:01.980 --> 06:13.100
単語のバッグよりも賢い方法でベクトルを生成できるエンコーディング・アルゴリズムだ｡

06:13.100 --> 06:15.950
まずは線形回帰を使ってみよう｡ 

06:16.070 --> 06:22.790
そして､ それをランダムフォレストと一緒に使うのですが､ これはもっと洗練された手法なので､ その時にお話しします｡

06:22.820 --> 06:30.560
しかしそれは､ データのランダムな塊と､ ベクトルのビットの形をした特徴を取り､ それがアンサンブル､

06:30.560 --> 06:40.190
つまりこれらの小さなサンプルの多くの平均を組み合わせた一連のモデルを作成するかどうかを確認することを含む｡

06:40.190 --> 06:53.660
サポート・ベクトル回帰と呼ばれる､ サポート・ベクトル・マシンの一種である｡

06:53.810 --> 06:55.880
だから､ 私たちはこうしたさまざまなテクニックを試してみる｡ 

06:55.880 --> 07:06.710
どれが最も優れているのか､ また､ 説明文だけから商品の価格を予測するという我々の問題を解決する上でどうなのかを見てみよう｡

07:07.010 --> 07:09.410
それでは､ JupyterLabに行ってみよう｡ 
