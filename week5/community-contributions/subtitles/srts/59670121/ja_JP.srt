WEBVTT

00:00.380 --> 00:02.360
だから､ 今はビジネスの時間なんだ｡ 

00:02.360 --> 00:11.780
我々は､ トレーニングデータセットにある類似商品のコンテキストを利用して､ 商品の価格を推定するRagパイプラインを構築しようとしている｡

00:12.110 --> 00:14.510
それで､ 今ここにいる｡ 

00:14.540 --> 00:19.580
2日目 3 GPT4ミニでラグ・パイプラインを構築する

00:19.850 --> 00:22.640
ええと､ 今日はたくさんのコードを手短に説明します｡ 

00:22.640 --> 00:24.860
だから我慢してくれ｡ 

00:24.860 --> 00:30.440
コツは､ 戻って自分でコードを実行し､ 何が起こっているのかをよく理解することだ｡ 

00:30.440 --> 00:37.310
インポートして､ いつものようにログインして､ OpenAIに接続する｡ 

00:37.490 --> 00:41.360
OpenAIのAPIキーを設定したことを利用しています｡ 

00:41.390 --> 00:44.450
テストデータセットをロードする｡ 

00:44.480 --> 00:50.120
クロマ・データ・ストアを使うので､ トレーニング・データセットをロードする必要はない｡

00:50.570 --> 00:51.350
分かった｡ 

00:51.350 --> 00:55.250
そこで､ ファンクション・メイク・コンテクストだ｡ 

00:55.250 --> 01:04.910
この関数を使い､ GPTに送る4つのミニのコンテキストを作成する｡

01:04.910 --> 01:12.120
そこで､ 文脈を説明するために､ 見積もりが必要な項目と類似している可能性のある他の項目をいくつか挙げます｡

01:12.120 --> 01:18.000
そして､ 2つの異なるリストを一緒に反復処理できるこのZIP構造を覚えているだろうか｡ 

01:18.300 --> 01:25.680
そこで､ 渡された類似品と価格を反復処理することで､ 類似品と価格を収集することにする｡

01:26.070 --> 01:32.670
そして､ この価格で似たような関連商品がある可能性があるというメッセージを追加します｡ 

01:33.600 --> 01:35.670
すぐに実行する｡ 

01:35.670 --> 01:37.410
だから､ 実際にどのように見えるかを見てほしい｡ 

01:37.800 --> 01:44.640
しかし､ これまでと同じように､ この関数はアイテム､ それに似たもの､

01:44.640 --> 01:53.160
価格を受け取り､ 私たちがよく知っているディクツの標準的なリストを構築します｡

01:53.520 --> 01:58.170
システムメッセージはこれまでと同じものだ｡ 

01:58.200 --> 02:04.410
あなたはアイテムの価格を見積もり､ 我々は文脈で追加しようとしている価格だけで答える｡ 

02:04.410 --> 02:07.980
先ほど作ったものをここに追加していく｡ 

02:08.040 --> 02:09.300
そして､ こう言うんだ｡ 

02:09.330 --> 02:10.980
そして､ あなたへの質問だ｡ 

02:10.980 --> 02:20.550
これは基本的に､ 6週目にGPT4と呼んでパイプラインを構築したときに使ったものとまったく同じだ｡

02:20.640 --> 02:27.870
ここで注目すべきは､ ラング・チェーンを使わずにラグ・パイプラインを自前で行っていることだ｡ 

02:28.350 --> 02:30.510
そして､ 実はそれほど難しくはない｡ 

02:30.600 --> 02:35.040
ラング・チェーンは､ いくつかのシンプルなオブジェクトの上に､ ちょっとした抽象化を施してくれた｡ 

02:35.040 --> 02:40.890
コード1行とかでできるけど､ 自分たちでやるのはもっと大変なんだ｡

02:40.890 --> 02:49.230
特に今は､ フードの下で何が起こっているかを理解し､ llmsの呼び出し方や類似オブジェクトの検索方法などを知っている｡

02:49.350 --> 02:52.830
それは比較的簡単なことだ｡ 

02:53.010 --> 03:01.260
ええと､ だから､ ええと､ できれば､ あまり難しく考えないでほしいんだけど､ 続けよう｡ 

03:01.290 --> 03:04.020
ええと､ だから私たちは､ ええと｡ 

03:06.060 --> 03:07.830
クロマを集めよう｡ 

03:08.610 --> 03:10.740
うーん､ またやってしまったね｡ 

03:10.770 --> 03:13.920
DB変数を定義したセルを削除した｡ 

03:13.920 --> 03:17.050
アンダースコアの製品であるべきだ｡ 

03:18.460 --> 03:19.780
ベクターストア

03:22.690 --> 03:23.860
ベクターストア

03:23.890 --> 03:25.930
スペルが難しいかもしれない｡ 

03:25.930 --> 03:26.560
これでよし｡ 

03:26.560 --> 03:27.700
そして今､ もう一度それを実行する｡ 

03:27.700 --> 03:28.450
素晴らしい｡ 

03:28.450 --> 03:33.700
ベクター・データ・ストアのproductsコレクションを見てみよう｡ 

03:34.510 --> 03:35.950
うーん､ わかった｡ 

03:35.950 --> 03:38.980
そして､ 我々は今､ 本題に入ろうとしている｡ 

03:38.980 --> 03:46.150
そこで､ アイテムを受け取るメソッド､ 関数の説明を用意する｡ 

03:46.150 --> 03:49.990
そして､ その項目から私たちが気にしないものを取り除くことになる｡ 

03:49.990 --> 03:53.950
だから基本的には､ プロンプトを受け取って､ これを取り出そう｡ 

03:53.950 --> 03:55.810
ドル単位でいくらですか｡ 

03:55.810 --> 04:00.910
そして､ 価格の後に来るものはすべて無視することになる｡ 

04:00.940 --> 04:03.430
ここで何が起こっているのか､ 具体的にお見せしよう｡ 

04:03.610 --> 04:08.380
最初のトレーニングデータを見てみよう｡ 

04:09.430 --> 04:09.910
おっと｡ 

04:09.940 --> 04:10.390
申し訳ない｡ 

04:10.420 --> 04:10.870
私が何をしたというのか？

04:10.900 --> 04:12.250
最初のテストデータ点をテストする｡ 

04:12.250 --> 04:13.780
もうトレーニングデータは見ていない｡ 

04:13.810 --> 04:20.230
最初のテストデータは､ フォードの修理キットで､ 値段が書いてある｡

04:20.560 --> 04:29.040
そのプロンプトを見ると､ 価格と質問がトップに表示されている｡

04:29.040 --> 04:36.390
しかし､ 私ができることは､ テストゼロの説明を記述することだ｡ 

04:36.390 --> 04:41.670
そして今､ 私たちが手に入れるべきものは､ この価格抜きの紹介文だけである｡ 

04:41.670 --> 04:44.130
だから､ それは明らかだろう｡ 

04:44.400 --> 04:44.910
分かった｡ 

04:44.940 --> 04:50.340
それでは､ ハギング・フェイスのセンテンス・トランスフォームのモデルをロードする｡ 

04:50.340 --> 04:53.070
これで単純なベクトル符号化ができた｡ 

04:53.070 --> 04:54.720
ベクタライザーだ｡ 

04:54.840 --> 04:59.430
そしてこのメソッド､ 実はこれがベクター・ライザー関数なのだ｡ 

04:59.430 --> 05:00.840
アイテムが必要だ｡ 

05:00.840 --> 05:04.890
これは､ そのアイテムの説明を呼び出してテキストに変換する｡ 

05:04.890 --> 05:09.420
そしてそれをリストに入れ､ model dot encodeを呼び出す｡ 

05:09.840 --> 05:11.850
単純なことだ｡ 

05:12.690 --> 05:17.790
そして今､ 私たちは類似点を見つける機能にたどり着いた｡ 

05:17.790 --> 05:22.950
アイテムが与えられ､ 似たようなアイテムを返す｡ 

05:22.980 --> 05:29.470
これは､ 以前ラングがやってくれていた一番難しい部分なんだけど､ そんなに難しくはないんだ｡

05:29.590 --> 05:36.490
コレクション（クロマDBコレクション）に対して､ このクエリーを実行する｡ 

05:36.520 --> 05:38.140
これがクエリの埋め込みである｡ 

05:38.140 --> 05:42.880
これは､ このベクトルに基づいているんだ｡ 

05:42.880 --> 05:46.120
numpyの配列から浮動小数点数に変換する必要がある｡ 

05:46.150 --> 05:50.140
それは､ numpyのfloat32だからだ｡ 

05:50.200 --> 05:54.010
そしてそれをnumpyの配列ではなくリストにしなければならない｡

05:54.010 --> 05:59.380
そして､ 単純に､ ええと､ 結果の数､ と言って､ その数だけ返してほしい｡ 

05:59.380 --> 06:04.210
だから､ クエリーの埋め込みとしてベクトルを渡すと､ 5つの結果が返ってくる｡ 

06:04.210 --> 06:05.740
それだけだ｡ 

06:05.740 --> 06:11.560
そして返ってくるのは､ いくつかの類似点だ｡ 

06:11.680 --> 06:18.040
では､ テスト1番のプロンプトを見てみよう｡ 

06:18.040 --> 06:19.840
これがそのプロンプトだ｡ 

06:19.930 --> 06:21.700
1ドル単位でいくらですか？

06:21.700 --> 06:24.160
ファンクラッチパッケージだ｡ 

06:24.490 --> 06:26.860
ええと､ モータークラフトの｡ 

06:26.860 --> 06:28.210
いずれにせよ､ おわかりいただけたと思う｡ 

06:28.210 --> 06:32.020
だから文書も価格も問題ないと言えるようになった｡ 

06:32.020 --> 06:34.020
テスト1からシミラーレを探す｡ 

06:34.020 --> 06:39.030
ここでこの関数を呼び出して､ 似たような結果を5つ見つける｡ 

06:39.060 --> 06:40.440
そうしよう｡ 

06:41.100 --> 06:42.630
そして今､ 考えている｡ 

06:42.630 --> 06:44.190
それを印刷しよう｡ 

06:44.550 --> 06:51.390
そしてここで､ 5つの関連結果が潜在的な関連商品であることがわかります｡ 

06:51.390 --> 06:54.600
そして､ それらはすべて関連商品である可能性がある｡ 

06:54.630 --> 06:59.640
どれもファンのクラッチ的なもので､ 値段も様々だ｡ 

06:59.730 --> 07:04.080
ええと､ 一見すると似たような製品に見えるけど｡ 

07:04.260 --> 07:09.540
もっとテストして､ クロマー・コレクションにクエリーを呼び出すだけで､

07:09.540 --> 07:15.840
似たような関数を見つけることができることを確認してください｡

07:15.840 --> 07:21.720
そして､ クロマーのデータベースから類似商品を集めることができるようになる｡ 

07:21.720 --> 07:23.490
簡単なことだ｡ 

07:23.790 --> 07:31.350
そうしたら､ ラグ・パイプラインのラグ・データ・フローの最終仕上げをして､ それを使ってGPT

07:31.350 --> 07:36.030
four zeroを呼び出すことができる｡

07:36.030 --> 07:38.610
それは次のビデオで｡ 
