WEBVTT

00:00.260 --> 00:02.930
이제 토큰에 대해 잠깐 얘기해 보죠

00:02.960 --> 00:07.700
토큰은 모델로 전환되는 개별 유닛이에요.

00:07.880 --> 00:13.550
신경망을 구축하던 초기에는 캐릭터마다 훈련된

00:13.550 --> 00:16.790
신경망을 자주 사용했어요

00:16.790 --> 00:22.400
일련의 캐릭터를 구성하는 모델이 있어야 해요 그리고 훈련해서 가장

00:22.400 --> 00:28.250
유력한 다음 캐릭터를 예측하는 거죠 이전의 캐릭터를 고려해서요

00:28.280 --> 00:33.020
특별한 기술이었고 어떤 면에선 장점도 많았어요

00:33.020 --> 00:38.210
가능한 입력 수의 숫자는 제한된 숫자라는 의미였죠 가능한 알파벳 문자와

00:38.210 --> 00:39.950
일부 기호의 숫자요

00:39.950 --> 00:43.760
그래서 다루기 쉬운 단어가 많이 생겼죠

00:43.760 --> 00:48.470
그 무게는 입력에 대한 너무 많은 가능성을 걱정할

00:48.470 --> 00:49.910
필요가 없었죠

00:49.940 --> 00:57.200
하지만 문제는 그 모델에 요구되는 게 너무 많다는 거였어요 일련의 다른

00:57.200 --> 01:05.830
캐릭터들이 어떻게 단어로 변하는지 이해해야 했고 단어에 담긴 의미와 관련된 모든

01:05.830 --> 01:12.280
지성이 모델의 무게에 담겨야 했는데 그건 모델 자체에 너무 많은

01:12.310 --> 01:15.550
걸 요구하는 거였죠

01:15.550 --> 01:22.720
그다음에는 거의 다른 극한으로 갔어요 각 단어의 정보를 훈련한

01:22.720 --> 01:25.270
신경망 모형들이었죠

01:25.270 --> 01:29.680
그래서 단어 선택이라는 걸 만들어요 사전 같은 건데 가능한

01:29.680 --> 01:31.840
모든 단어의 인덱스죠

01:31.840 --> 01:37.420
각각의 단어는 토큰이 될 수 있어요 이 중 아무 단어나 될 수 있죠

01:37.420 --> 01:44.470
즉, 모델 자체가 각 단어의 의미가 다르다는 걸 이해하기 시작했다는 거죠

01:44.470 --> 01:49.600
캐릭터의 연속적인 의미를 이해하는 대신에요

01:49.600 --> 01:51.040
그건 좋은 일이었죠

01:51.040 --> 01:55.210
하지만 문제는 그 결과로 엄청난 어휘가 나왔다는 거죠

01:55.240 --> 01:58.740
가능한 모든 단어를 합친 단어가 필요했어요

01:58.740 --> 02:04.140
가능한 단어가 아주 많아요 장소와 사람들의 이름도 있으니까요

02:04.140 --> 02:07.800
그래서 모르는 단어를 위한 특별한 증표가 있어야 했죠

02:07.800 --> 02:10.650
그래서 한계가 생겼죠

02:10.830 --> 02:13.860
희귀한 단어와 특별한 장소는 생략해야 했죠

02:13.860 --> 02:17.370
그래서 좀 이상한 일이 생겼어요

02:17.550 --> 02:25.860
그러다 GPT가 개발될 무렵 돌파구를 찾았습니다 양극단 사이에 적절한 매체가 있다는

02:25.860 --> 02:31.170
사실이었죠 캐릭터별로 모델을 훈련하고 그것들을 조합해

02:31.170 --> 02:36.360
단어를 만드는 법을 배우는 대신에요

02:36.360 --> 02:43.350
각각의 단어가 다른 토큰이라고 말하는 것보다는 하나의 글자를 모아서 완전한 단어를

02:43.350 --> 02:48.600
만들거나 단어의 일부를 토큰으로 만드는 것이 더 좋을 것 같습니다.

02:48.600 --> 02:57.740
그렇게 해서 전달되는 토큰에 기반하여 일련의 토큰과 출력 토큰을 만들도록 하는 거죠.

02:57.740 --> 03:01.250
이 방법에는 흥미로운 장점이 많아요

03:01.250 --> 03:05.630
그중 하나는 토큰으로 나누기 때문에 장소의 이름이나 정식 이름

03:05.630 --> 03:07.880
같은 것도 다룰 수 있다는 거죠

03:07.880 --> 03:10.040
그저 패의 조각에 불과할 뿐이죠

03:10.040 --> 03:15.800
두 번째 흥미로운 효과는 단어 스템 처리에도 좋다는 겁니다

03:15.950 --> 03:23.090
혹은 단어 시작 부분이 같아 여러 잠재적 결말을 하나의 토큰에 인코딩하고

03:23.090 --> 03:27.950
몇 개의 토큰으로 이어질 때요

03:27.950 --> 03:34.310
즉, 말하고자 하는 것의 기저에 깔린 의미는 모델 내에서 쉽게 표현될 수 있다는 것입니다.

03:34.310 --> 03:40.400
왜냐하면 토큰은 약간 추상적으로 들릴 수도 있는 구조로 구성되어 있기 때문이죠.

03:40.400 --> 03:42.380
좀 더 현실적인 비트로 바꿔드리죠

03:43.100 --> 03:51.530
GPT, OpenAI는 플랫폼 OpenAI라는 도구를 제공하죠 comp/토큰라이저입니다 텍스트를

03:51.530 --> 03:58.240
입력하면 어떻게 토큰으로 바뀌는지 볼 수 있죠

03:58.390 --> 04:05.080
그래서 한 문장을 선택했습니다 우리 인공지능 엔지니어 학급에게는 중요한 문장이죠

04:05.350 --> 04:08.650
GPT가 그걸 토큰화한 걸 볼 수 있죠

04:08.650 --> 04:12.700
단어를 증표로 바꿀 때 사용하는 동사죠

04:12.700 --> 04:17.080
그게 어떻게 토큰이 됐는지 색으로 강조하죠

04:17.080 --> 04:24.730
이 경우에는 모두 흔한 단어라서 모든 단어가 토큰 하나에 정확히 그려져

04:24.760 --> 04:26.320
있어요

04:26.590 --> 04:28.480
이게 확실한 예죠

04:28.480 --> 04:29.860
색깔을 보면 알 수 있죠

04:29.860 --> 04:34.060
또 하나 흥미로운 점은 중요한 거예요

04:34.060 --> 04:40.030
색깔 있는 상자 몇 개가 앞에 공간이 있어요

04:40.060 --> 04:41.200
우주 같아요

04:41.200 --> 04:43.570
그리고 for는 표시된 거죠

04:43.660 --> 04:49.330
왜냐하면 표기할 때도 단어 간격이 의미가 있거든요

04:49.330 --> 04:55.440
저 토큰은 격리된 워드를 나타내요 워드의 시작 부분처럼요 그걸 위한 글자들이

04:55.530 --> 05:05.010
토큰의 시작 부분에 매핑되죠 토큰에 대한 워드의 시작 부분에요 그건 잠시 후에 좀 더 중요해질 거예요

05:05.010 --> 05:05.250
하지만요

05:05.250 --> 05:11.970
하지만 단어 사이의 간격도 토큰의 일부로 포함된다는 걸 알아두세요

05:12.780 --> 05:15.120
다른 예를 들어보죠

05:15.150 --> 05:22.320
이 예시에서는 좀 더 흥미로운 문장을 떠올려 봅니다 LM 위치크래프트

05:22.320 --> 05:26.880
몰이꾼들을 위한 정교한 수제 재담이죠

05:26.910 --> 05:30.060
몰이꾼이란 말은 지어낸 말일 거예요

05:30.060 --> 05:34.950
여기 보시면 빨간 구불구불한 선이 가짜라는 걸 알 수 있어요

05:34.950 --> 05:38.010
어떻게 토큰화가 이루어졌는지 보죠

05:38.010 --> 05:48.330
4는 여전히 한 단어로 여기 있는 게 보이시죠 토큰의 앞부분도요

05:48.330 --> 05:54.920
하지만 앤도 마찬가지예요 하지만 여러 토큰으로 정교하게 나뉘어 있죠

05:54.950 --> 05:56.690
아주 정교하게요

05:57.380 --> 06:04.130
희귀한 단어를 쓰면 그 단어가 한 단어로 안 쓰인다는 걸 알 수 있죠

06:04.130 --> 06:08.630
여러 개의 토큰으로 나눠야 했지만 여전히 전달할 수 있었죠

06:08.750 --> 06:11.570
그 단어는 수제품이에요

06:11.570 --> 06:17.000
보다시피 단일 토큰이라는 단어에도 그게 없어요 하지만 그걸

06:17.000 --> 06:19.280
쪼개서 만들 수 있죠

06:19.280 --> 06:25.640
그게 그 의미를 반영해요 어떤 면에서는요 Get it의 의미요

06:25.670 --> 06:28.280
두 가지를 수작업으로 합친 거예요

06:28.280 --> 06:33.320
보다시피 만들어진 토큰은 문장의 시작을 포함하지 않죠

06:33.320 --> 06:38.810
중간에 만들어진 단어를 상징하는 토큰인 셈이죠

06:38.810 --> 06:41.000
그게 그 토큰의 의미죠

06:41.090 --> 06:43.430
그런 농담은 전혀 안 통해요

06:43.430 --> 06:48.700
누군가 침입했고 마스터시스 사진도 있어요

06:48.700 --> 06:52.300
단어 줄기에 대해 말씀드린 좋은 예죠

06:52.300 --> 06:58.900
마스터는 마스터로 바뀌었는데 여기서 중요한 건 동사죠

06:58.900 --> 07:04.720
마스터를 익혔다가 마지막에 실수하는 사람요

07:05.020 --> 07:12.160
보다시피 우리가 말하려는 의미를 반영할 수 있어요 두 개의 토큰으로

07:12.160 --> 07:15.820
쪼개서요 진짜 단어는 아니지만요

07:16.390 --> 07:22.600
마법과 공예가 섞여 들어간 것도 볼 수 있어요 이것도 흥미롭죠

07:23.170 --> 07:25.540
네, 수공예품이에요

07:25.540 --> 07:29.740
스승님, 말씀드렸듯이 현극령에 그 의미가 반영돼 있죠

07:29.740 --> 07:35.980
여러분이 이걸 통해 토큰으로 뭔가를 쪼개는 게 어떤 의미인지 깨달았으면 좋겠네요

07:37.150 --> 07:42.250
여기서 흥미로운 건 이 좀 더 복잡한 예시를 보여드리는 거예요

07:42.280 --> 07:48.130
제가 좋아하는 숫자죠 6534589793238462643383이에요

07:48.160 --> 07:49.030
어쩌고저쩌고 말이죠

07:49.180 --> 07:58.810
이 화면을 보면 이런 게 있을 때 파이처럼 긴 숫자는 토큰 하나로

07:58.840 --> 08:01.750
대응하지 않아요

08:01.930 --> 08:09.550
여기서 벌어지는 일을 보면 모든 일련의 세 자리 숫자가 토큰 하나에 매핑되고

08:09.550 --> 08:11.020
있어요

08:11.260 --> 08:13.030
흥미로운 자산이죠

08:13.030 --> 08:19.000
사실 GPT 2 토큰라이저의 속성입니다 하지만 다른 많은 제품에는 그렇게 많은 케이스가 없죠

08:19.000 --> 08:23.170
여러 개의 토큰을 가지고 있는 것을 볼 수 있어요.

08:24.220 --> 08:32.170
일반적으로 토큰을 볼 때 명심해야 할 경험 법칙이

08:32.170 --> 08:33.670
있어요

08:33.670 --> 08:41.560
경험 법칙에 따르면 토큰 하나는 보통 네 글자로 매핑이 돼요

08:41.860 --> 08:50.060
보통 영어 문학에서 토큰은 평균적으로 단어 4분의 3에 해당해요

08:50.060 --> 08:53.210
토큰 한 장은 0개 정도고요 75단어요

08:53.210 --> 08:54.950
쉽게 생각할 수 있는 방법이죠

08:54.950 --> 09:00.260
쉽게 말하면 천 현은 750글자나 되죠 Put

09:00.260 --> 09:01.880
그게 여러분이 염두에 두셔야 할 지도예요

09:01.910 --> 09:04.820
천 현은 750글자예요

09:04.820 --> 09:11.300
셰익스피어 전작을 예로 들어 볼게요 예를 들어 현실적으로 보면 약

09:11.300 --> 09:16.460
900,000단어로 된 셰익스피어 작품이죠

09:16.460 --> 09:23.510
1명 정도요 200만 토큰이면 셰익스피어 작품 전집과 맞먹는 크기죠

09:23.540 --> 09:26.270
영어를 말하는 거예요

09:26.270 --> 09:33.920
수학 공식이나 과학 용어, 코드 같은 것을 볼 때 토큰의 수는 훨씬 더 많습니다 여기에서

09:33.920 --> 09:39.530
숫자들을 보았듯이 더 많은 토큰으로 쪼개져야 합니다 올바른

09:39.530 --> 09:43.990
심볼 같은 것을 포함하기 위해서요

09:44.290 --> 09:48.790
여기서 또 한 가지 중요한 점은 GPT 토큰라이저를 보여드린다는 거죠

09:48.820 --> 09:52.930
토큰이 어떻게 작동해야 하는지 정해진 규칙은 없어요

09:52.960 --> 09:57.340
조금 전에 토큰라이저를 사용하던 초창기를 살펴봤는데요 모든 글자가

09:57.340 --> 10:02.770
토큰 하나에 매핑되었죠 모델마다 토큰화에 다른 접근법을 갖고 있었어요

10:02.770 --> 10:07.660
나중에 오픈 소스를 살펴볼 땐 다양한 토큰라이저들을 직접 경험해볼

10:07.690 --> 10:08.440
거예요

10:08.470 --> 10:12.280
라마 토큰라이저의 흥미로운 속성도 살펴볼 거예요

10:12.310 --> 10:15.280
각각의 토큰이 다르게 작동할 수 있어요

10:15.280 --> 10:20.170
패가 많거나 적을 때 장단점이 있어요

10:20.380 --> 10:26.350
모델에 매개 변수가 몇 개 있고 어떻게 훈련받았는지에 따라 답이 달라지지

10:26.350 --> 10:27.640
않아요

10:27.820 --> 10:34.930
이번 시간에는 GPT 토큰마이저를 더 자세히 살펴보고 여러분께 명확함과 직관을 얻으셨길

10:34.930 --> 10:41.230
바랍니다 단어와 글자를 토큰의 세계로 바꾸는 게 어떤 의미인지 말이죠
