WEBVTT

00:00.860 --> 00:08.780
JupyterLabのお気に入りの場所に来て､ コーディングの準備をしている｡

00:08.810 --> 00:15.800
まず目につくのは､ 2日目のJupyter Notebookがないことだろう｡ 

00:15.830 --> 00:22.610
実際､ 2日目のJupyterノートブックが5つある｡

00:22.730 --> 00:31.670
また､ いつもよりノートブックを読むスピードが少し速くなるかもしれない｡

00:31.910 --> 00:41.390
さて､ 今日は商品の価格を推定するためのより複雑なアプローチを構築します｡

00:41.630 --> 00:49.970
ええと､ 今日の最大のポイントは､ 同じことをするためのラグ・パイプライン・ソリューションにアプローチしようとすることだ｡

00:50.030 --> 00:55.520
直感的には､ これはラグにとって本当に素晴らしいユースケースだと思う｡ 

00:55.520 --> 01:01.160
トレーニング・データ・セットには40万点の商品の価格がある｡ 

01:01.220 --> 01:08.810
そのすべてをデータストアに置いて､ モデルを呼び出すときに､ 似たような製品をいくつか与えて､ この電動歯ブラシの価格を教えてください､

01:08.810 --> 01:13.460
と言ったらどうだろう？

01:13.460 --> 01:22.070
ちなみに､ ここに学習データから似たような電動歯ブラシを5つ選び､ それをモデルに与えて助けてもらう｡

01:22.070 --> 01:24.890
そのためにフロンティア・モデルを使うのはまったく理にかなっている｡ 

01:24.890 --> 01:32.030
そして､ いくつかの類似点を武器に､ 我々はフロンティアモデルに大きな先鞭をつけていることを想像してほしい｡

01:32.120 --> 01:40.100
正確なデータの宝庫を手に入れたのだから｡

01:40.130 --> 01:44.090
だから､ スウィートスポットにぴったりなんだ｡ 

01:44.180 --> 01:50.030
そこで､ このノート､ 2. 0ノートブックの8週目のフォルダに､

01:50.030 --> 01:57.260
40万トレーニング・データ・ポイントを含むベクトル・データ・ストアを作成する｡

01:57.260 --> 01:58.370
だから､ それは大きなことなんだ｡ 

01:58.370 --> 02:02.060
第5週よりもずっと多い｡ 

02:02.540 --> 02:05.810
次のノートでは2日目｡  1.

02:05.810 --> 02:09.380
2Dで視覚化し､ 次に3Dで視覚化する｡ 

02:09.500 --> 02:10.910
これがクイックノートだ｡ 

02:10.910 --> 02:16.910
でも､ 2日目にこういったことを肌で感じられるのは素晴らしいことだ｡  3.

02:16.940 --> 02:20.330
そしてラグ・パイプラインを構築し､ テストする｡ 

02:20.330 --> 02:25.910
そして2日目｡  4 これが1 in 1ノートで多くのことを行っているところです｡ 

02:25.940 --> 02:31.970
第6週に見たランダムフォレスト・プロセッサーを復活させる｡ 

02:32.270 --> 02:34.760
そして､ しかし､ 我々はその改良版をやるつもりだ｡ 

02:34.760 --> 02:38.780
そして､ すべてのモデルを可能にするアンサンブルと呼ばれるものを構築する｡ 

02:38.780 --> 02:41.660
基本的には､ 一緒に投票するようなものだと考えればいい｡ 

02:41.690 --> 02:47.660
彼らは一緒に問題に取り組んでいて､ その中から最良の結果をもたらす直線的な組み合わせを選んでいるのだ｡

02:47.660 --> 02:49.460
だから､ 乗り切らなければならないことがたくさんある｡ 

02:49.460 --> 02:57.410
私たちはすでに､ 専門のLLMという形で強力な製品プロセッサを構築していることをお伝えしたかったのです｡

02:57.410 --> 03:00.590
それなのに､ なぜこんなに時間をかけているのだろう？

03:00.590 --> 03:02.060
答えは簡単だ｡ 

03:02.090 --> 03:03.620
さっき言ったとおりだ｡ 

03:03.620 --> 03:07.400
これは､ 自分の専門性を確固たるものにすることだと考えている｡ 

03:07.400 --> 03:10.790
ボロ雑巾でもっと練習できるようにするためだ｡ 

03:11.000 --> 03:20.840
同じプロジェクトに携わりながら､ エージェント・ベースの機能を構築する他の種類の側面について､ より多くの練習を積むことができる｡

03:20.840 --> 03:25.370
だから､ 私たちは自分たちが何をしているのかわかっているし､ 満足している｡

03:25.370 --> 03:29.180
だから､ 私たちがこれからやろうとしていることへのモチベーションを高めてもらえればと思う｡ 

03:29.750 --> 03:38.300
さて､ これ以上説明することなく､ いくつかのインポート環境変数を実行し､ 私たちが知っている顔を抱きしめてログインする｡

03:38.300 --> 03:47.930
そしてまた､ トレーニング・データを読み込むつもりだ｡ 単純化するために､ 以前から持っているピックル・ファイルをトレーニング・データに読み込む｡

03:47.930 --> 03:53.180
そこで､ トレーニング・データの最初のポイントである燃料ポンプ・モジュールを見てみよう｡ 

03:53.180 --> 03:56.930
これを覚えていれば､ プロンプトを呼ぶことができる｡ 

03:56.930 --> 04:00.980
そして､ トレーニングでおなじみのプロンプトが表示される｡ 

04:00.980 --> 04:02.660
1ドル単位でいくらかかったか｡ 

04:02.660 --> 04:07.280
そして､ 価格と価値がそこにある｡ 

04:07.280 --> 04:08.210
オーケー｡ 

04:08.240 --> 04:11.760
これでChromaデータストアが完成した｡ 

04:11.760 --> 04:20.010
5週目にこのストアを作ったんだけど､

04:20.010 --> 04:31.740
123個のドキュメントがあったのを覚えているかな｡

04:31.740 --> 04:36.840
そこで今回は､ 400,000ドキュメントのクロマ・データストアを作成する｡ 

04:36.840 --> 04:37.830
多いね｡ 

04:37.890 --> 04:38.940
チャンクアップするつもりはない｡ 

04:38.970 --> 04:39.840
もちろん､ その必要はない｡ 

04:39.870 --> 04:41.610
これらはすでに小さな塊だ｡ 

04:41.760 --> 04:46.530
各製品は､ それぞれのアイテムとしてクロマに入る｡ 

04:46.800 --> 04:56.190
だから､ ラングチェーンをこのボロパイプラインに使うつもりはない｡

04:56.280 --> 05:00.270
ええと､ ラングチェーンは良い､ 有用な抽象化を与えてくれるが､ その必要はない｡ 

05:00.300 --> 05:05.970
そして､ 今のような熟練したレベルになれば､ Llmsを直接扱うだけでよくなり､

05:05.970 --> 05:12.750
その上に構築される抽象化レイヤーは必ずしも必要ではなくなる｡

05:13.110 --> 05:15.900
だから､ そうするつもりなんだ｡ 

05:15.990 --> 05:25.560
クロマデータベースを作成します｡ 

05:26.520 --> 05:30.810
ええと､ 私はもっと早くその定数を外していたかもしれない｡ 

05:30.810 --> 05:32.190
今すぐそうしよう｡ 

05:32.220 --> 05:33.330
謝罪する｡ 

05:33.600 --> 05:42.210
ええと､ ここにもうひとつ､ DBイコール商品アンダースコア・ベクトル・ストアの定数を追加します｡ 

05:42.930 --> 05:47.760
このノートを使いやすくするために整理していたんだけど､ 整理しすぎたんだ｡ 

05:48.150 --> 05:50.070
スペルが正しければ､ 私は製品を持っている｡ 

05:50.070 --> 05:51.090
ベクターストア

05:51.120 --> 05:52.620
これでよし｡ 

05:52.710 --> 05:55.710
よし､ じゃあ戻ろう｡ 

05:55.740 --> 05:57.270
一瞬の気晴らし｡ 

05:57.270 --> 06:00.840
そこで､ そのパスでクロマ・データ・ストアを作成する｡ 

06:00.870 --> 06:02.070
これでよし｡ 

06:02.220 --> 06:06.450
存在するかどうかをチェックし､ すでに存在する場合は削除する｡ 

06:06.540 --> 06:07.680
私はそれを実行するつもりはない｡ 

06:07.680 --> 06:10.950
それは私が作成したこの製品ベクターストアを削除します｡ 

06:10.950 --> 06:13.170
そして少し時間がかかる｡ 

06:13.230 --> 06:15.060
それほど時間はかからなかったけど｡ 

06:15.060 --> 06:17.940
でも､ これはあなた自身に任せるわ｡ 

06:18.450 --> 06:23.670
そこで私たちは､ 新しい別のタイプのエンベッディングを使おうとしている｡ 

06:23.670 --> 06:27.990
私たちはセンテンス・トランスフォーマーというものを使おうと思っている｡ 

06:27.990 --> 06:34.800
これは､ テキストチャンクを384次元にマッピングするハグフェイスの便利なモデルだ｡ 

06:34.920 --> 06:38.310
それに､ セマンティック検索などには理想的だ｡ 

06:38.310 --> 06:41.640
このベクトル埋め込みを生成するのは変換モデルだ｡ 

06:41.640 --> 06:47.130
以前､ ラグ・パイプラインを構築したときにOpenAIのエンベッディングを使ったことを覚えているかもしれない｡ 

06:47.130 --> 06:52.980
だから､ この2つを一緒に比べてみると､ このハグしている顔のほうは､ あー､

06:52.980 --> 06:54.330
次元が違う｡

06:54.330 --> 07:00.240
だから､ OpenAIのエンベッディングほど正確ではないだろう｡ 

07:00.240 --> 07:03.690
でも､ 無料だし､ 速いし､ ローカルで動かせる｡ 

07:03.690 --> 07:09.420
この最後のポイントは非常に重要だ｡

07:09.420 --> 07:19.220
例えば､ 5週目に私が指定したプロジェクトに取り組んでいて､ Eメールなど自分のものを使って自分だけのラグ・データベースを構築しようとしているとする｡

07:19.220 --> 07:28.220
OpenAIにすべてを送信するのは､ 安全であるべきとはいえ避けたいかもしれない｡

07:28.220 --> 07:31.100
そこで､ ハギング・フェイスのモデルをロードする｡ 

07:31.130 --> 07:36.740
これは､ 将来的には無視してもいいような警告を与えている｡

07:37.010 --> 07:42.920
このモデルを作成したら､ model dot encodeを呼び出すことができます｡ 

07:42.950 --> 07:47.000
テキスト文書のリストを渡す｡ 

07:47.000 --> 07:49.220
返ってくるのはnumpyの配列だ｡ 

07:49.220 --> 07:54.590
そして､ その中から最初の1枚を抜き取るだけで､ 私のベクトルを得ることができる｡ 

07:54.590 --> 07:55.550
そして､ かなり早かった｡ 

07:55.550 --> 07:57.680
そして､ バルクでもうまく機能する｡ 

07:57.680 --> 08:06.080
このベクトルの長さを見ると､ 384次元あることがわかる｡ 

08:06.110 --> 08:08.450
印刷すればいい｡ 

08:08.450 --> 08:09.920
大きな古いベクトルになるだろう｡ 

08:09.920 --> 08:10.490
あれだ｡ 

08:10.490 --> 08:18.260
だから､ そのベクトルは､ ある意味では､ 多次元的な反映である方法で､ 数字でうまくハイそこに表している

08:18.260 --> 08:21.260
従った LMに｡

08:21.470 --> 08:27.770
だから､ それは......その......遊んで､ 感覚をつかむ価値がある｡ 

08:28.430 --> 08:33.920
つまり､ これから書くユーティリティ・メソッドの説明は､ アイテム（項目のひとつ）を受け取り､

08:33.920 --> 08:36.950
それを単なるテキストの塊に変えるものだ｡

08:36.950 --> 08:41.600
最初のトレーニングポイントを見て､ そのプロンプトを見ると､

08:41.600 --> 08:45.320
プロンプトはこのように表示されます｡

08:45.350 --> 08:54.320
その代わりに､ その商品の説明を呼び出すと､ 同じものが表示されるだけだが､

08:54.320 --> 08:59.870
前面に何も表示されず､ 価格も表示されない｡

09:00.050 --> 09:05.660
そのデータをベクター・データ・ストアに格納する｡ 

09:05.900 --> 09:08.720
そのコードを実行すると､ しばらく時間がかかる｡ 

09:08.720 --> 09:13.910
そして､ それが完成する頃には､ ベクター・データ・ストアに登録され､ ビジネスの準備が整う｡ 

09:13.910 --> 09:16.820
すでに実行したので､ ベクター・データ・ストアが作成されている｡ 

09:16.820 --> 09:18.380
左側に見える｡ 

09:18.380 --> 09:19.760
今すぐそうすべきだ｡ 

09:19.760 --> 09:22.580
それが終わったら､ また次のビデオで会おう｡ 
