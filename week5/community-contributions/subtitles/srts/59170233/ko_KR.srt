WEBVTT

00:00.560 --> 00:04.160
토큰이들과의 활약에 돌아오신 걸 환영해요

00:04.160 --> 00:09.830
지금 볼 것은 모델 지시 변수라는 건데요

00:09.830 --> 00:18.650
채팅용으로 특별히 설계된 모델도 많습니다 사용자와의 채팅을 수행하기 위해서죠

00:18.650 --> 00:28.430
GPT4 채팅도 마찬가지입니다 얼굴을 끌어안는 모델이 등장할 경우 베이스 모델과

00:28.520 --> 00:33.830
이름이 같지만 끝에 지시 사항이 추가됩니다 이

00:33.830 --> 00:43.310
지시 사항 사용 사례에 적절하게 사용되도록 설계됐다는 뜻이죠

00:43.610 --> 00:50.870
특정 구조에서 특정 토큰으로 시스템 메시지와

00:50.900 --> 01:00.920
사용자 메시지 지원 답변을 식별해 채팅을 하도록 훈련받았죠

01:00.920 --> 01:06.270
많은 예시를 들면서 훈련된 방식의 일부일 뿐이죠

01:06.270 --> 01:13.260
이 포맷에서 기대하죠 여러분께 뭔가 제공하면 좋겠네요 이제 루프를

01:13.260 --> 01:19.830
닫을 테니까요 한참 전에 메시지 구조의 이유에 대해 시드를

01:19.830 --> 01:28.290
심었던 거죠 독재 목록은 프론티어 모델을 할 때 아주 익숙해졌어요

01:28.290 --> 01:37.470
이번엔 토큰라이저를 만들게요 메타 lemma 3을 이용해서요 180억 개요

01:37.470 --> 01:39.720
그러니 낯익을 거예요

01:39.720 --> 01:48.420
이것은 우리가 오픈AI나 클로드에서 많이 사용하는 독촉 목록 중 하나입니다 역할과 콘텐츠를

01:48.420 --> 01:56.790
지정하는 거죠 역할 시스템은 시스템 메시지 사용자는 사용자 메시지에요

01:56.880 --> 02:06.570
H깅페이스가 제공하는 토큰라이저는 특별한 기능을 수행해 채팅 템플릿을 적용하고 OpenAI

02:06.570 --> 02:16.170
API 포맷의 이 포맷 메시지를 취합니다 올바른 구조로 전환해 이 모델이 기대하는 특정

02:16.170 --> 02:24.960
프롬프트 유형에 사용되죠 훈련된 방식에 따라 토큰라이즈 = true 함수를

02:24.960 --> 02:31.470
입력하면 일련의 숫자만 나올 뿐 무슨 일이 일어나는지 알 수

02:31.470 --> 02:34.290
없어요

02:34.290 --> 02:35.910
토큰화 = false라고 적었죠

02:35.910 --> 02:39.750
Get in get은 텍스트 버전이에요

02:39.750 --> 02:46.770
프린트해서 여러분이 보실 수 있도록 하겠습니다 이게 무엇으로 변환되었는가

02:46.770 --> 02:53.820
하는 거죠 이 특정 대화에 대한 추론 시간에 모델로 펌프질되었어요

02:53.820 --> 03:00.360
여기 있네요, 특별한 토큰 비긴즈 오브 텍스트와 헤더로 시작하네요

03:00.360 --> 03:04.380
워드 시스템과 end 헤더도 있어요

03:04.560 --> 03:10.780
그리고 절단 연도와 오늘 날짜에 대한 정보도 있어요

03:10.780 --> 03:12.160
정말 특별하네요

03:12.160 --> 03:14.260
라마 3 같아요 하나만요

03:14.260 --> 03:17.830
이전 라마 가족들은 그런 적이 없었는데 제가 틀렸을 수도 있어요

03:18.280 --> 03:25.840
그리고 이건 물론 우리가 제공한 시스템 메시지예요

03:26.860 --> 03:31.870
User와 헤더를 위한 또 다른 스타트 헤더가 있어요

03:31.870 --> 03:35.170
이건 사용자 메시지예요

03:35.620 --> 03:41.800
또 다른 start 헤더와 보조란 단어가 있고 end 헤더가 있어요 모델이

03:41.800 --> 03:44.590
보조 응답을 생성해야 하니까요

03:44.590 --> 03:50.800
이 모델은 다음 순서로 이어집니다 이 시스템

03:50.800 --> 03:58.720
지침을 신속히 따르는 지원군에 대한 대응이죠

03:59.590 --> 04:07.000
이번 기회에 깨달으셨으면 좋겠어요 어떻게 이런 구조물을 지었는지요

04:07.000 --> 04:10.120
모델과의 대화도 그렇게 생각해야 해요

04:10.120 --> 04:15.570
하지만 결국 모델에는 이런 프롬프트가 들어갑니다 특별한 토큰이 들어

04:15.600 --> 04:16.980
있는 프롬프트죠

04:16.980 --> 04:22.470
그런 구조와 특별한 토큰으로 훈련했기 때문에 다음에 뭐가 필요한지

04:22.470 --> 04:23.490
알아요

04:23.520 --> 04:25.410
지원팀 응답요

04:27.210 --> 04:30.990
채팅 인터페이스를 설명하는 거죠

04:30.990 --> 04:34.140
get it의 경험을 쌓기 위해 모델 몇 명과 더 일해 보죠

04:34.140 --> 04:36.360
전 특별히 세 가지 모델을 고를 거예요

04:36.480 --> 04:40.290
파이 3은 마이크로소프트 모델이에요

04:40.680 --> 04:45.150
퀸 2는 알리바바 클라우드에서 계속 언급했던 강력한 모델이에요

04:45.150 --> 04:49.800
스타 코더 2는 코드 생성을 위해 설계된 모델이죠

04:49.890 --> 04:57.210
세 회사가 협력해서 만든 회사로 서비스나우와 포옹하는

04:57.240 --> 05:05.340
얼굴 그리고 엔비디아입니다 이 세 회사가 파트너십을 맺어

05:05.340 --> 05:11.450
그룹스타 코더와 이 모델을 만들었죠

05:11.450 --> 05:12.560
네

05:12.560 --> 05:18.060
그럼 피3을 불러 볼까요?

05:18.060 --> 05:24.300
오토 토큰라이저와 똑같은 접근법을 사용합니다 미리 훈련받은 모델이죠

05:24.300 --> 05:27.750
지금은 저도 같은 문자를 보내고 있어요

05:27.750 --> 05:31.470
LLM 엔지니어들에게 토큰라이저의 작동을 보여 줄 생각에 신나요

05:31.470 --> 05:40.020
라마 3을 재인쇄할 거예요 토큰라이저 1개 토큰의 모습을 다시 보여드리죠

05:40.050 --> 05:44.070
빈 선이 하나 있고 피3을 프린트할 거예요

05:44.070 --> 05:49.500
결국 중요한 질문은 이겁니다 기본적으로 같은 토큰을 생산하나요? 아니면

05:49.500 --> 05:50.490
다른가요?

05:50.520 --> 05:52.200
한번 보죠

05:53.700 --> 05:57.150
보면 아시겠지만 완전히 달라요

05:57.270 --> 05:58.200
달라요

05:58.230 --> 06:05.250
생성된 텍스트만 다른 게 아니라 메시지 특별 토큰의 시작인 이 첫 번째

06:05.280 --> 06:07.620
것도 완전히 달라요

06:07.830 --> 06:11.070
그걸 볼 수 있게 배치 디코딩을 하죠

06:16.980 --> 06:17.760
토큰자이예요

06:17.790 --> 06:21.930
닷 배치 해독법이에요

06:24.450 --> 06:27.030
토큰이라고 해야겠네요

06:27.030 --> 06:28.110
동등하게요

06:31.770 --> 06:32.970
토큰요

06:33.780 --> 06:35.280
get in the right 한번 볼까요?

06:36.360 --> 06:40.800
Get in get은 완전히 달라요

06:40.860 --> 06:44.520
사실, 흥미롭게도 조금 전에 한 말은 틀렸어요

06:44.550 --> 06:52.350
53번의 경우 문장 시작 특별 토큰이 없어요 그냥 바로 들어가죠

06:53.250 --> 06:56.850
아주 색다른 접근법이죠

06:58.830 --> 06:59.670
좋아요

06:59.700 --> 07:07.350
채팅 템플릿 적용을 이용해 53명이 채팅 템플릿을 어떻게 사용하는지 보죠

07:07.380 --> 07:09.900
라마를 위해 다시 해 보죠

07:09.900 --> 07:11.250
라마도 볼 수 있겠네요

07:11.250 --> 07:17.070
그런 다음 나란히 같은 채팅 템플릿을 출력할 겁니다 같은 대화, 같은 53에 대한 같은

07:17.070 --> 07:18.990
프롬프트를 위해서요

07:19.020 --> 07:20.160
어떤지 보죠

07:20.160 --> 07:26.260
이게 라마에게 필요한 거고 이건 피3에 해당하는 거예요

07:26.290 --> 07:28.450
훨씬 짧죠

07:28.450 --> 07:31.270
날짜에 안 들어가요

07:31.510 --> 07:38.230
흥미롭게도 라마라는 단어는 헤더가 기본이었어요 워드 시스템과 엔드

07:38.260 --> 07:42.730
헤더가 사용자와 엔드 헤더로 이어졌죠

07:42.730 --> 07:51.310
파이 3의 경우 시스템을 위한 특별한 태그와 사용자를 위한 특별한 태그 보조를 위한 특별한

07:51.310 --> 07:52.720
태그가 있어요

07:52.720 --> 07:55.870
접근 방식이 완전히 달라요

07:56.110 --> 08:02.020
흥미로운 점은 두 토큰라이저, 두 모델이 프롬프트를 get으로 보내는 방법에

08:02.020 --> 08:04.240
다른 접근법을 취한다는 거죠

08:04.240 --> 08:07.870
만약 잘못된 토큰라이저를 잘못된 모델로 사용한다면 가비지가

08:07.870 --> 08:12.940
된다는 것을 아셔야 합니다. 왜냐하면 토큰이 다르고 구조가 다르다면 llama3에는

08:12.940 --> 08:15.430
의미가 없기 때문이죠.

08:16.120 --> 08:18.850
이제 퀸 2호도 똑같이 해 보죠

08:18.880 --> 08:23.020
라마의 원조 버전을 볼 거예요

08:23.020 --> 08:26.870
파이3 버전을 보여드리고 두 가지 버전을 보여드릴게요

08:27.050 --> 08:28.460
저기 오네요

08:29.120 --> 08:35.690
보시다시피 토큰라이저 세 개는 완전히 다른 결과를 볼 수 있죠

08:35.750 --> 08:38.720
하이라이트 한 번 더 할게요

08:38.720 --> 08:41.810
모델에 맞는 토큰라이저를 골라야 해요

08:43.370 --> 08:49.430
채팅 템플릿을 적용해 보죠 같은 메시지를 전달하는 채팅 템플릿이

08:49.430 --> 08:51.170
또 있어요

08:51.170 --> 08:52.400
곧 알게 되겠죠

08:52.400 --> 08:56.330
다섯, 셋, 퀸, 둘 이렇게 나란히요

08:56.330 --> 08:57.350
어떻게 생겼는지 보죠

08:57.380 --> 08:59.000
라마 사진은 이미 봤어요

08:59.000 --> 09:01.010
53편은 이미 봤어요

09:01.010 --> 09:03.560
그리고 이건 퀸의 두 번째예요

09:03.560 --> 09:06.650
보시면 알겠지만 그 중간쯤에 있어요

09:06.680 --> 09:08.840
비트도 라마랑 비슷해요

09:08.840 --> 09:14.030
시작과 끝이라는 시스템도 있고요

09:14.210 --> 09:16.850
그 다음은 사용자, 그 다음은 조수죠

09:16.850 --> 09:19.250
그 둘 사이의 어디쯤이죠

09:19.250 --> 09:23.870
그 어정쩡한 단어가 없어요

09:23.870 --> 09:26.000
헤더 스페셜 태그가 없어요

09:26.000 --> 09:28.440
이런 식으로 접근해요

09:28.440 --> 09:36.810
흥미로운 제3의 접근법이죠 또 다른 변종으로 특별한 토큰을 사용해요

09:37.740 --> 09:38.370
좋아요

09:38.370 --> 09:41.580
마지막으로 스타 코더 2를 보여드릴게요

09:41.610 --> 09:44.520
코드 생성 모듈이에요

09:44.520 --> 09:46.440
토큰라이저를 가져갈 거예요

09:46.440 --> 09:49.470
이 코드를 저기에 Put 할게요

09:49.500 --> 09:54.570
안녕 세계, 안녕 세계 변수를 선택하는 거죠

09:54.570 --> 09:55.980
그러면 hello를 출력하죠

09:55.980 --> 09:57.090
그리고 그 사람도요

09:57.090 --> 10:02.220
그런 다음 같은 인코드를 사용해 토큰으로 바꾸죠

10:02.220 --> 10:09.000
이제 해야 할 일은 각각의 토큰을 프린트하는 것입니다. 그리고 무엇이 get이 되었는지, 어떤 텍스트를

10:09.030 --> 10:11.730
나타내는지 매핑하는 것이죠.

10:11.730 --> 10:18.840
여기 보시면 처음에 뭔가 있었어요 데프가 토큰 하나에 들어갔고

10:18.840 --> 10:25.110
hello_ world와 Person이 나왔죠

10:25.110 --> 10:33.210
여기 이건 탭을 반영할 겁니다 그런 다음 hello, 사람 괄호 닫기를 인쇄하죠

10:33.210 --> 10:42.660
대충 감이 오실 겁니다 스타 코더 2 토큰라이저는 토큰라이저로 영어보다는 토큰라이저

10:42.660 --> 10:46.140
코드를 중심으로 디자인됐죠

10:46.500 --> 10:48.120
실험할 수 있는 게 있어요

10:48.150 --> 10:54.060
먼저, 다양한 토큰라이저를 사용해보고 텍스트에서 토큰으로의 매핑을 탐색해보세요

10:54.180 --> 10:55.590
어떤 단어인지 찾아봐요

10:55.590 --> 11:02.040
라마 안에 토큰이 하나 있는 가장 희귀한 단어를 찾아보세요

11:02.040 --> 11:06.360
토큰이거나 가장 긴 단어였을 거예요

11:06.360 --> 11:09.720
실험도 좀 하고 여러분을 만족시켜 드릴게요

11:10.170 --> 11:15.210
꽤 복잡한 코드를 가지고 있다면 이 스타 코더의 토큰라이저 토큰화가

11:15.240 --> 11:22.260
더 효율적으로 이루어질 것입니다 토큰라이저의 영어 버전보다 더 효율적이죠

11:22.650 --> 11:30.570
그때쯤이면 여러분은 오픈 소스 토큰라이저의 전문가가 되어 다음 단계인 모델에

11:30.570 --> 11:33.180
도전할 준비가 될 거예요

11:33.180 --> 11:35.160
먼저 슬라이드로 돌아가죠
