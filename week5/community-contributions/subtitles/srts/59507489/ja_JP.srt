WEBVTT

00:01.610 --> 00:06.140
トレーニングのためのハイパーパラメータについての冒険を続ける｡ 

00:06.140 --> 00:11.660
次はかなり重要で､ 学習率と呼ばれるものだ｡ 

00:11.660 --> 00:16.220
そしてまた､ 皆さんの中の多くのデータサイエンティストは､ このことをよくご存知だろう｡ 

00:16.460 --> 00:26.690
トレーニングの目的は､ モデルを作成し､ トレーニング・データを取得することです｡

00:26.690 --> 00:32.150
フォワード・パスと呼ばれる推論で､ モデルを通して次に来るはずのトークンを予測し､

00:32.150 --> 00:38.780
予測された次のトークンを予測する｡

00:39.110 --> 00:44.330
あるいは実際には､ 次のトークンの可能性をすべて確率で示す｡ 

00:44.360 --> 00:49.610
そして､ そのトークンを使って､ 実際にあるべき次のトークンを手に入れる｡ 

00:49.610 --> 00:54.380
そして､ この2つ､ 予想と実際を総合して､ 負けを導き出すことができる｡ 

00:54.500 --> 01:01.460
次にできることは､ そのロスを利用して､ バックプロパゲーション（逆伝播法）と呼ばれる､

01:01.460 --> 01:13.910
モデルを遡り､ 次回はもう少し良い結果を出すために､ 各ウェイトをどれだけ上下に微調整すれば良いかを割り出すことだ｡

01:14.120 --> 01:17.570
そして､ その方向に一歩踏み出すんだ｡ 

01:17.570 --> 01:23.060
ウェイトを移動させ､ 次はもっとうまくやるための一歩を踏み出すのだ｡ 

01:23.060 --> 01:29.990
その一歩､ その一歩が､ ウェイトを良い方向にシフトさせ､ 次回はもう少し良い結果が出るようにする｡

01:29.990 --> 01:35.420
まさにその学習データに直面したとき､ ええと､ 学習率と呼ばれる｡ 

01:35.570 --> 01:42.470
典型的なのは0か0かだ｡  0001 または 0. 00001.

01:42.530 --> 01:45.350
ええと､ いくつか例を挙げればわかるだろう｡ 

01:45.440 --> 01:51.290
学習レート・スケジューラーと呼ばれる機能もあります｡ これは､ 学習レートをある数値で開始し､

01:51.290 --> 01:57.470
数回のエポックにわたって実行する間に､ 学習レートを徐々に下げていくものです｡

01:57.470 --> 02:02.720
モデルがより訓練されるにつれて､ 学習レート､ つまり学習ステップをどんどん短くしていき､

02:02.720 --> 02:11.300
ネットワークにわずかな調整を加えるだけにしたいからです｡

02:11.330 --> 02:15.050
なぜなら､ あなたは自分が正しい場所にいると確信しているからだ｡ 

02:15.050 --> 02:17.540
それが学習率というわけだ｡ 

02:17.570 --> 02:21.440
繰り返しになるが､ データ・サイエンスのバックグラウンドを持つ多くの人々にとっては､ 古くからある話だろう｡ 

02:21.440 --> 02:23.450
他の人にとっては初めてのことかもしれない｡ 

02:24.050 --> 02:27.920
グラデーションの蓄積は一つの方法だ｡ 

02:27.950 --> 02:35.210
トレーニングの中で､ よし､ これからやるのは普通に前方へのパスだ､

02:35.210 --> 02:40.760
と言ってスピードを向上させるテクニックなんだ｡

02:40.970 --> 02:46.340
私たちは､ 今私が説明したような喪失感を味わうことになる｡ 

02:46.370 --> 02:52.400
そして逆算して勾配を計算し､ 正しい方向に一歩を踏み出す｡ 

02:52.400 --> 02:58.790
そして､ グラデーションの累積を繰り返すのだが､ おそらくできることは､ フォワードパスをしてグラデーションを取得し､

02:58.790 --> 03:03.800
一歩も動かずに､ 2回目のフォワードパスをしてグラデーションを取得し､ それらのグラデーションを加算して､

03:03.800 --> 03:07.040
さらに数回繰り返すことだ｡

03:07.040 --> 03:13.790
勾配を積み重ね､ 一歩を踏み出し､ ネットワークを最適化する｡ 

03:14.060 --> 03:19.170
そしてそれは､ これらのステップを行う頻度が少ないということであり､ つまり､ もう少し速く走ることができるということだ｡ 

03:19.350 --> 03:21.900
ある意味､ バッチサイズに似ている｡ 

03:21.900 --> 03:30.060
それは､ ある意味､ 概念的な類似性があるんだ｡

03:30.330 --> 03:35.070
私が設定したハイパーパラメーターでは､ 勾配累積を使っていません｡ 

03:35.070 --> 03:36.540
私はそれを1に設定している｡ 

03:36.690 --> 03:39.480
でも､ 過去に試したことがあるんだ｡ 

03:39.480 --> 03:44.220
だから､ それを試してみて､ どんな効果があるか見てみるのもいいかもしれない｡ 

03:44.220 --> 03:46.710
これがグラディエントの蓄積だ｡ 

03:47.100 --> 03:50.700
そして最後がオプティマイザーだ｡ 

03:50.730 --> 03:57.780
オプティマイザーは､ 勾配が決まったら､ 学習率が決まったら､ 時間になったら使う計算式だ｡

03:57.780 --> 04:05.730
そして今､ ニューラルネットワークにアップデートを加え､ すべてを良い方向に少しずつシフトさせ､

04:05.730 --> 04:11.730
次回､ 正しい次のトークンを予測する可能性を少しでも高めるのだ｡

04:11.730 --> 04:14.550
そして､ そのためのプロセスをオプティマイザーと呼ぶ｡ 

04:14.550 --> 04:22.860
その方法については有名な計算式がたくさんあり､ それぞれに長所と短所がある｡

04:22.860 --> 04:27.180
性能的には少し高価なものだ｡ 

04:27.180 --> 04:31.050
それは少し大変な仕事だが､ 良い結果につながる｡ 

04:31.050 --> 04:33.840
だから､ まずはそこから始めることをお勧めする｡ 

04:33.990 --> 04:42.150
そして､ もしメモリに何らかの問題が生じても､ より少ないメモリ消費で済む代替手段がある｡

04:42.300 --> 04:44.820
しかし､ そのプロセスは最適化と呼ばれている｡ 

04:44.820 --> 04:49.410
そのために選ぶアルゴリズムがオプティマイザーと呼ばれるものだ｡ 

04:49.410 --> 04:54.210
これもハイパーパラメーターのひとつで､ いろいろなものを試して､ その結果を見ることができる｡ 

04:54.540 --> 04:57.390
だから､ すごくたくさんのことを話しているんだ｡ 

04:57.390 --> 05:04.860
また､ ハイパーパラメーターについての会話を使って､ トレーニング・プロセスについても少し説明した｡ 

05:04.950 --> 05:17.340
GoogleColabに戻り､ SFTトレーナーをセットアップして､

05:17.340 --> 05:24.120
自分たちの専門的なLMを微調整する｡
