WEBVTT

00:00.740 --> 00:08.330
이제 랙의 가장 중요한 측면에 대해 얘기할 때가 됐습니다 벡터 개념이죠

00:08.360 --> 00:11.750
벡터와 벡터 내장법에 익숙하시다면 잠시만요

00:11.750 --> 00:13.610
빨리 훑어보도록 하죠

00:13.610 --> 00:17.570
몰랐던 걸 알게 될 수도 있어요 제가 설명한 대로요

00:17.570 --> 00:21.290
먼저 중요한 배경 정보가 있습니다 이 과정을 통해 다양한

00:21.290 --> 00:26.210
LMS에 관해 얘기해왔는데요 우리가 얘기한 거의 모든 LMS는 하나의

00:26.210 --> 00:30.380
종류였습니다 자동적 허용 LM이라고 불리는 거죠

00:30.380 --> 00:35.300
LM에는 완전히 다른 범주가 있습니다 자동 코드화라고 하죠

00:35.300 --> 00:36.500
차이가 뭐죠?

00:36.530 --> 00:44.990
LMS 자동 이탈 LMS는 과거의 토큰 세트를 받고 시퀀스에서 다음 토큰을 생성해야

00:44.990 --> 00:49.070
합니다 미래 토큰이요 과거가 주어지죠

00:49.070 --> 00:52.400
계속 반복해서 다음 토큰을 생성하죠

00:52.400 --> 00:56.300
토큰의 역사를 보면 자동적 차별적인 LM이에요

00:56.300 --> 00:58.100
물론 그게 대세죠

00:58.100 --> 01:00.710
우리가 함께 일하는 대부분의 사람들이죠

01:00.710 --> 01:04.270
GPT 4호와 클로드 제미니 계획도 있고요

01:04.690 --> 01:11.380
자동 코드 형식이라는 것도 있습니다 과거와 현재, 미래를 모두 나타내는 완전한

01:11.380 --> 01:12.700
입력을 하죠

01:12.700 --> 01:18.670
입력 비트가 가득하고 입력 전체를 반영하는 출력 비트를 생성하죠

01:19.090 --> 01:22.120
그걸 현실화하려면 몇 가지 확실한 예가 있죠

01:22.120 --> 01:26.620
감정 분석은 문장을 보고 긍정인지 부정인지 판단하는 거예요

01:26.770 --> 01:30.940
분류 구역에서는 문장을 양동이에 담아 Put을 해요

01:31.420 --> 01:36.790
2주 전에 어깅페이스 파이프라인과 관련해 잠깐 탐구한 것들이죠

01:36.850 --> 01:40.360
둘 다 자동 코드 llms의 예죠

01:41.260 --> 01:46.300
또 다른 방법으로 사용되기도 합니다 벡터 내장이라는 것을 생성할 때 사용되죠

01:46.300 --> 01:48.700
오늘 얘기할 게 바로 그거예요

01:48.730 --> 01:54.520
벡터 엠베딩은 텍스트의 문장이나 다른 여러 가지를 취하는 방법인데 보통은 텍스트의

01:54.520 --> 01:55.570
문장이죠

01:55.570 --> 02:02.620
그걸 일련의 숫자로 바꾸는 거죠 어떤 면에선 그 텍스트의 의미를 반영하는

02:02.620 --> 02:04.360
일련의 숫자요

02:04.360 --> 02:07.000
그게 무슨 뜻인지 잠시 후에 살펴보죠

02:07.000 --> 02:13.640
지금은 좀 추상적으로 들리지만 아이디어는 텍스트를 숫자로 변환하는 겁니다

02:13.640 --> 02:17.960
그 숫자들은 공간의 한 점을 나타내는 비트죠

02:17.960 --> 02:22.670
텍스트를 세 개의 숫자로 바꾼다고 해보죠 엑스나 Y, Z로

02:22.670 --> 02:28.190
생각할 수 있어요 이건 공간에서 무언가가 있는 위치를 나타내죠

02:28.370 --> 02:33.800
보통 이렇게 하면 수백, 수천 개의 숫자로 변환돼요

02:33.800 --> 02:37.760
천 차원 공간에 있는 한 지점을 나타내는 거예요

02:37.760 --> 02:41.690
시각화하기가 좀 어렵죠 우린 3차원으로만 생각할 수 있으니까요 하지만

02:41.690 --> 02:42.620
생각은 같죠

02:42.620 --> 02:49.580
공간의 점을 반영하고 어떤 의미에서든 그 점은 자동 인코딩의

02:49.580 --> 02:55.250
예로 생성된 텍스트의 의미를 나타내죠

02:55.280 --> 02:58.640
구글의 버트예요

02:58.670 --> 03:02.540
첫 주에 버트 얘기를 했던 거 기억하시죠?

03:02.570 --> 03:05.240
버트는 꽤 오래 출연했어요

03:05.390 --> 03:11.110
OpenAI의 오픈 인공지능 엠베딩도 있는데 자동 오토 젠코더 모델로

03:11.110 --> 03:14.680
이번 주에 래그 프로젝트에 사용할 거예요

03:15.160 --> 03:19.960
비트 코어의 의미에 대해 좀 더 얘기해 보죠

03:19.990 --> 03:28.690
먼저, 여러분은 단일 문자에 대한 벡터 중 하나를 만들 수 있습니다 토큰이나 다수의 문자

03:28.930 --> 03:34.660
단어, 문장, 단락, 전체 문서에 대한 것 혹은 추상적인 것에

03:34.660 --> 03:36.490
대한 것에요

03:36.490 --> 03:44.020
제 회사, 네뷸라처럼 재능이나 일자리 같은 것의 벡터를 만들어요

03:44.680 --> 03:49.930
이런 벡터들을 작업할 때 수백, 수천 개의 차원이 있는 경우가 많아요

03:49.930 --> 03:54.700
텍스트 한 덩어리를 나타내는 수천 개의 숫자처럼요

03:55.030 --> 04:01.420
이 숫자들이 입력값의 의미를 반영한다고 여러 번 말씀드렸죠

04:01.420 --> 04:03.010
그게 무슨 뜻이죠?

04:03.040 --> 04:10.060
간단히 말해서, 이 말은 여러 단락의 텍스트가 서로 가까운 공간의

04:10.060 --> 04:14.720
비슷한 지점으로 매핑이 된다는 거죠.

04:14.720 --> 04:18.800
이 텍스트 블록들은 비슷한 의미를 가져야 해요

04:18.800 --> 04:21.500
같은 단어를 쓸 필요는 없어요

04:21.500 --> 04:25.790
완전히 다른 단어일 수도 있지만 의미는 같아요

04:25.790 --> 04:32.090
벡터 공간에서 서로 가까워질 거예요 숫자로 바뀔 때 서로 가까워진다는

04:32.090 --> 04:35.540
건 비슷한 걸 의미하죠

04:35.540 --> 04:38.630
그게 기본 아이디어죠

04:38.630 --> 04:44.630
이 이면에는 좀 더 정교한 아이디어가 있어요 이 점을 포함해서요 이런 것들의

04:44.660 --> 04:49.400
의미 뒤에 숨은 벡터 수학이라고 불리는 걸 할 수 있어요

04:49.400 --> 04:54.050
그리고 이 예시가 있습니다. 아주 오래된 예시죠.

04:54.050 --> 04:59.750
들어 보셨을 수도 있는데 킹이라는 단어가 있다고 가정해 봅시다 킹이라는

04:59.750 --> 05:05.720
단어를 가지고 벡터 인코딩을 이용해서 킹이라는 단어를 나타내는 공간의

05:05.720 --> 05:07.880
점을 찾는다고 해보죠

05:07.910 --> 05:11.990
인간이란 단어를 반영하는 벡터도 찾을 수 있죠

05:11.990 --> 05:14.510
여성이라는 단어를 반영하는 벡터도요

05:14.600 --> 05:21.790
킹이라는 단어에서 남자를 빼면 남자가 있는 방향으로

05:21.790 --> 05:28.750
뒤로 가고 여자가 있는 방향으로 전진하는 거예요

05:29.110 --> 05:36.160
당신은 왕이라는 개념을 받아들여서 남자를 여자로 대체하고

05:36.160 --> 05:41.470
싶다고 했어요 즉, 왕이라는 뜻이죠

05:41.470 --> 05:49.210
그리고 놀랍게도 이렇게 하면 벡터 공간에 들어가게 됩니다 퀸이라는

05:49.210 --> 05:53.890
단어가 있는 위치와 같은 위치죠

05:53.920 --> 06:00.220
그러니까 왕이라는 단어에서 왕의 의미를 따지고 남자 측면을 여자로

06:00.220 --> 06:06.850
대체하면 여왕이라는 단어의 의미를 반영하는 무언가가 되는 거죠

06:06.850 --> 06:13.780
그런 점에서 벡터들은 벡터들이 나타내는 단어의 의미를 반영하는 것

06:13.780 --> 06:19.660
같아요 비슷한 단어들이 서로 가까이 있다는 점과 벡터 수학을

06:19.660 --> 06:26.420
수행하는 능력도요 덕분에 개념 간의 관계를 이해할 수 있죠

06:27.860 --> 06:30.860
이게 래그랑 무슨 상관이죠?

06:30.950 --> 06:32.930
여기서 모든 게 합쳐져요

06:32.930 --> 06:35.510
래그의 핵심 아이디어죠

06:35.540 --> 06:38.570
아까와 같은 도표예요

06:38.570 --> 06:40.550
비트보다 더 많은 걸 할 거예요

06:40.850 --> 06:43.970
상단엔 LM 인코딩이라는 새 상자가 있죠

06:44.000 --> 06:48.650
어떤 텍스트를 벡터로 바꿀 수 있는 거죠

06:48.650 --> 06:52.070
맨 밑에는 벡터 데이터 저장소가 있어요

06:52.100 --> 06:55.250
지식 기반 이전에 있던 데이터 저장소 같아요

06:55.250 --> 07:03.800
텍스트와 함께 텍스트를 나타내는 벡터도 저장할 수 있어요 텍스트의 의미를

07:03.800 --> 07:05.750
나타내는 벡터요

07:06.260 --> 07:07.130
좋아요

07:07.130 --> 07:08.990
이렇게 하죠

07:09.080 --> 07:12.260
사용자가 질문을 던지죠

07:12.290 --> 07:19.550
가장 먼저 할 일은 질문을 벡터로 바꾸는 겁니다 벡터화라고도 하죠

07:19.550 --> 07:22.360
에이미 미가 누구냐는 질문이라면요

07:22.360 --> 07:23.260
랭커스터요

07:23.260 --> 07:30.160
에이미 랭커스터가 누구인지를 질문의 의미로 해석하는

07:30.160 --> 07:31.870
거예요

07:33.100 --> 07:34.990
제가 다음에 할 말은 아마 짐작이 가실 거예요

07:35.020 --> 07:43.120
이제 벡터 데이터베이스로 가서 벡터 데이터베이스에서 벡터들이 에이미 랭커스터에 가까운

07:43.120 --> 07:49.180
곳에 있는 정보를 요청합니다 에이미 랭커스터가 누구인가요?

07:49.180 --> 07:51.760
저 안에 있는 다양한 문서들을 보세요

07:51.760 --> 07:53.530
전부 벡터로 만들었어요

07:53.530 --> 07:58.000
에이미 랭커스터가 누구인지 궁금해할 벡터들이 있을 거예요

07:58.030 --> 08:04.630
벡터들을 제공하고 벡터로 바뀐 원래 정보와 텍스트를 제공하죠

08:04.630 --> 08:11.890
에이미 랭커스터의 항공 문서가 벡터와 가까운 곳에 있을 가능성이 높습니다

08:11.890 --> 08:15.910
에이미 랭커스터가 누구죠?

08:16.810 --> 08:20.860
그래서 정보를 얻으면 텍스트를 get 하면 되죠

08:20.860 --> 08:26.570
이전의 장난감 예제처럼 그걸 LLM 프롬프트에 밀어넣으면 응답을 얻습니다

08:26.570 --> 08:29.870
아마도 추가적인 컨텍스트를 이용하겠죠

08:29.870 --> 08:32.210
그게 사용자에게 돌아가는 거죠

08:32.300 --> 08:38.600
장난감 예제와 같지만 관련 데이터를 찾는 데 훨씬 더 강력한 기술을

08:38.600 --> 08:45.620
사용합니다 벡터를 이용해 우리의 지식 중 어떤 것이 질문의 의미와 가장

08:45.620 --> 08:49.010
유사한지 이해하는 거죠

08:49.010 --> 08:51.410
그게 다인 것 같아요

08:51.410 --> 08:56.120
이번 주의 마무리가 되었네요. 왜냐하면 다음 시간에는 이것을 action에 넣고

08:56.120 --> 08:58.910
데이터베이스에서 벡터를 볼 것이기 때문이죠.

08:58.940 --> 09:04.160
다음엔 랭 체인이라는 것도 살펴볼 겁니다 프레임워크가 훌륭하죠

09:04.160 --> 09:08.780
이런 응용 프로그램을 쉽게 만들도록 디자인됐어요

09:08.780 --> 09:10.550
전부 수동으로 할 수 있어요

09:10.550 --> 09:15.860
벡터를 생성해 다양한 API를 이용해 벡터 데이터베이스에 저장할 수 있죠

09:16.160 --> 09:19.610
랑 체인은 아주 간단해요 곧 보시겠지만요

09:19.640 --> 09:24.230
그래디오 경험과 좀 비슷할 겁니다 코드 두어 줄로 아주

09:24.230 --> 09:26.450
강력한 걸 하는 거죠

09:26.450 --> 09:28.160
그래서 기대돼요

09:28.160 --> 09:29.090
당신도 그랬으면 좋겠네요

09:29.090 --> 09:30.260
그때 봐요
