WEBVTT

00:00.950 --> 00:06.440
그래서 이번 주에 여러분께 소개할 프로젝트를 소개하게 되어 기쁘군요

00:06.440 --> 00:08.810
정말 두툼한 고기예요

00:08.840 --> 00:11.930
이 코스 최고의 프로젝트예요

00:11.930 --> 00:14.120
가격 맞히기 게임이에요

00:14.120 --> 00:17.060
지금까지 해온 일을 하나로 묶어주는 거죠

00:17.090 --> 00:18.890
일단 집을 지을 거예요

00:18.890 --> 00:26.420
우리에게 주어진 과제는 인터넷에 게시된 거래를 찾고 RSS 피드를 구독할 수 있는

00:26.420 --> 00:31.970
플랫폼을 만드는 겁니다 게시된 거래를 스팟팅할 수 있도록요

00:31.970 --> 00:38.780
잠재적 거래를 찾으면 유망해 보이는 거래를요 그걸 읽고 해석해 다수의 LMS를

00:38.780 --> 00:45.200
사용합니다 지난주에 우리가 만든 소유권을 포함해서요 그게 얼마나 가치 있는지

00:45.200 --> 00:51.290
추정하기 위해서요 그리고 좋은 기회를 찾으면 자동적으로 텍스트 메시지나

00:51.290 --> 00:58.310
푸시 알림을 여러분이나 제게 보냅니다 우리가 알아야 할 거래가 있다고 알려주는 거죠

00:58.310 --> 01:03.830
자율적으로 항상 실행될 겁니다 백그라운드에서 실행되는 거죠 가끔

01:03.830 --> 01:10.940
푸시 알림을 받게 됩니다 온라인에 포스팅된 새 거래가 있다는 거죠 모델이 이 가격이

01:10.940 --> 01:18.170
정말 좋다고 결정하는 거죠 아이템은 훨씬 더 비싸야 하니까요

01:18.380 --> 01:24.110
동의하시길 바랍니다 우리가 해낼 수 있다면 플랫폼을 구축할 수 있다면 특별한

01:24.110 --> 01:26.720
걸 구축한 겁니다 고급 플랫폼이죠

01:26.720 --> 01:31.190
다양한 기능성 요소들을 한데 합친 것입니다. 제가 자랑스러워할

01:31.190 --> 01:36.350
만한 것이었으면 좋겠고 여러분도 자랑스러워 하실 수 있었으면 좋겠어요.

01:36.770 --> 01:38.780
요원은 7명이 될 거예요

01:38.780 --> 01:40.340
아까도 말했지만 다시 말할게요

01:40.370 --> 01:42.650
7명의 요원이 협력할 거예요

01:42.800 --> 01:45.500
전부 LMS에 설치된 건 아니에요

01:45.500 --> 01:50.780
파이썬 을 사용하는 과정도 있지만 퍼즐의 일곱 조각 같은 것들이 서로 협력하고

01:50.780 --> 01:52.010
있어요

01:52.280 --> 02:01.430
GPT 4, 또는 GPT for 미니를 이용해 RSS 피드에서 정보를 취하고 분석하고 이해한

02:01.430 --> 02:05.060
후 잠재적 거래로 바꿀 거예요

02:05.060 --> 02:11.630
개척지 급습 모델을 쓸 거예요 GPT 4보다 뛰어나죠

02:11.840 --> 02:15.500
클로드는 그걸로 물건의 가치를 추정할 거예요

02:15.500 --> 02:16.520
그게 다가 아니에요

02:16.520 --> 02:18.650
다른 모델도 사용할 거예요

02:18.650 --> 02:23.960
또 다른 래그 파이프라인을 만들 거예요 래그 기반 모델이죠

02:24.140 --> 02:26.300
하지만 이번에는 랑그 체인을 쓰지 않을 거예요

02:26.300 --> 02:27.470
직접 말 거예요

02:27.470 --> 02:29.420
아주 쉬울 거예요

02:29.510 --> 02:37.580
하지만 400,000가지 제품을 모두 사용할 거예요 전에 아마존 부족에게서 가져온 것들이죠

02:37.580 --> 02:45.680
전부 메가 크로마 데이터베이스에 넣고 개척자 모델의 래그 파이프라인에 컨텍스트를

02:45.680 --> 02:48.080
추가할 거예요

02:48.170 --> 02:51.020
이미 생각해 두신 게 아닌가 궁금해지실 거예요

02:51.020 --> 02:59.330
여러분은 이미 궁금하실 겁니다 비슷한 제품의 비슷한 가격으로 비슷한 제품을 제공하는 새로운

02:59.330 --> 03:05.670
모델이 지난주에 우리가 미세 조정했던 모델을 능가할 수 있을지 말이죠

03:05.700 --> 03:06.510
알게 될 거예요

03:06.510 --> 03:07.320
두고 봐야죠

03:07.470 --> 03:11.670
하지만 두 모델이 협업해서 최대한 좋은 가격을 얻도록 노력할 거예요 Get up!

03:11.670 --> 03:14.940
다른 모델도 공개할 거예요

03:15.390 --> 03:17.820
아주 중요한 한 주가 될 거예요

03:17.850 --> 03:22.080
가장 중요한 건 이 캡스톤 프로젝트가 모든 걸 하나로 합치는 아주 만족스러운

03:22.080 --> 03:26.070
방법으로 설계됐다는 거예요 손에 잡히고 진짜처럼 느껴질 수 있게요

03:26.070 --> 03:32.160
하지만 핵심은 우리가 배운 모든 것을 수정할 기회가 생긴다는

03:32.190 --> 03:40.290
겁니다 전문성과 경험을 쌓고 생산 수준의 모델을 직접 만들 수 있죠

03:40.380 --> 03:42.510
그게 이 강의의 핵심이죠

03:42.540 --> 03:47.910
재미있는 컨텍스트에서 하고 있어요 푸시 알림을 실제로 보낼

03:47.910 --> 03:54.510
뭔가가 있죠 유용한 제품이 있을 때요 하지만 학습에 관한 겁니다 지난 7주 동안

03:54.510 --> 03:57.930
우리가 한 학습을 확고히 하는 거죠

03:59.550 --> 04:05.670
잠시 말씀드리자면 에이전트 플랫폼의 아키텍처는 사용자 인터페이스를 갖게

04:05.670 --> 04:06.780
될 거예요

04:06.780 --> 04:09.060
물론 그라디오에서 지을 거예요

04:09.390 --> 04:15.840
우리가 작성할 에이전트 프레임워크를 사용할 겁니다 단순한 종류의 환경이죠 메모리가 있어

04:15.930 --> 04:21.150
에이전트는 과거에 권장했던 걸 알 수 있어요 로깅 같은 것도 지원하고요 그래서

04:21.150 --> 04:24.930
프레임워크에서 무슨 일이 벌어지는지 알 수 있죠

04:25.260 --> 04:27.900
계획을 담당하는 요원이 있을 거예요

04:27.900 --> 04:31.770
다른 요원들 간의 활동을 조율하는 거죠

04:31.770 --> 04:33.960
그럼 에이전트들이 생기죠

04:33.960 --> 04:38.160
스캐너 요원이 유망한 거래를 확인할 거예요

04:38.160 --> 04:40.590
RSS 피드를 보면요

04:40.620 --> 04:46.650
앙상블 에이전트라는 걸 만들 거예요 기술적인 앙상블이라고

04:46.680 --> 04:47.910
부르는 거죠

04:47.910 --> 04:52.560
여러 모델을 조합할 때 이 에이전트는 제품의 가격을

04:52.590 --> 04:57.240
예측할 수 있는 다양한 모델을 조합하는 역할을 하죠

04:57.720 --> 05:01.830
그리고 푸시 알림을 보내주는 메시징 에이전트가 있어요

05:01.890 --> 05:05.250
이건 단지 높은 수준의 아키텍처입니다 이것보다 에이전트가 더 많기 때문이죠

05:05.250 --> 05:10.740
앙상블 에이전트 자체가 다른 세 명의 에이전트와 협업하게 되니까요

05:10.740 --> 05:13.230
그게 우리 요원 3명이 될 거요

05:13.410 --> 05:16.230
하지만 이 다이어그램에선 안 보여줄 거예요 너무 어수선해질 테니까요

05:16.230 --> 05:19.440
하지만 언젠가는 꼭 할 거예요 get get get it

05:19.530 --> 05:23.610
우리가 뭘 만들 건지 감을 잡기 위한 고급 아키텍처예요

05:23.760 --> 05:28.140
오늘은 이 중 하나에 집중할 거예요

05:28.170 --> 05:30.210
이 아키텍처는 많이 보지 않을 거예요

05:30.210 --> 05:35.340
지난 시간에 만든 모델을 인터넷에 올리는 것에 대해 얘기할 겁니다 Modal이라는

05:35.340 --> 05:38.130
멋진 서비스를 이용해서요

05:38.850 --> 05:45.030
모드 얘기를 하기 전에 한 가지 더 언급하고 싶은 게 있어요 이제 더 진지한 코드를 작성하는

05:45.030 --> 05:52.050
쪽으로 나아가고 있으니 JupyterLab은 훌륭한 플랫폼이에요 반복적이고 실험적이며

05:52.050 --> 05:55.170
다양한 솔루션을 빠르게 내놓을 수 있죠

05:55.170 --> 06:02.310
하지만 연구 개발에서 생산 준비가 된 제품으로 발전할 때 코딩에

06:02.340 --> 06:06.270
몇 가지 변화가 있을 거예요

06:06.600 --> 06:10.560
우선, 코드에 힌트를 입력해 보도록 하죠

06:10.740 --> 06:13.470
이미 아주 익숙한 것일 수도 있죠

06:13.470 --> 06:15.660
안 되면 제가 설명할게요

06:15.870 --> 06:16.860
이유를 알게 될 거예요

06:16.860 --> 06:22.800
이런 생산 규격 코드를 만들 때 좋은 최선의 관행이죠

06:23.280 --> 06:25.830
댓글도 더 달 거예요

06:25.860 --> 06:29.610
Jupyter 노트북이 있으면 텍스트나

06:29.640 --> 06:34.800
설명을 넣을 시간이 많죠 주석 처리 방식은 다를지 몰라도

06:34.800 --> 06:40.080
적어도 함수 수준의 메서드에서 주석을 달아요

06:40.500 --> 06:44.190
로깅도 좋은 일이고 앞으로도 그럴 거예요

06:44.400 --> 06:49.800
다른 것도 있어요 아주 최선의 관행으로 단위 테스트를 작성하는 거죠

06:49.830 --> 06:54.570
프로덕션으로 가는 코드에 대해 좋은 단위 테스트를 작성하는 건 물론 아주 중요하죠

06:54.570 --> 06:58.170
전 카우보이라서 그런 짓은 안 해요

06:58.290 --> 07:00.990
네, 당연히 그래야죠

07:01.020 --> 07:03.960
하지만 좋은 운동이라고 말씀드릴 수 있어요

07:03.960 --> 07:09.580
우리가 제작하고 있는 일부 코드 뒤에서 단위 테스트를 작성하고 싶다면요

07:09.580 --> 07:10.600
그럼 정말 좋죠

07:10.630 --> 07:11.920
정말 감사해요

07:11.920 --> 07:18.370
물론 Git push를 원하신다면 기쁘게 합병해 단위 테스트를 작성하는 데에

07:18.400 --> 07:23.350
대한 어휘 기여도와 크레딧을 모두 알려드리겠습니다 당연히 제가

07:23.350 --> 07:24.910
해야 할 일이죠

07:25.210 --> 07:27.850
최선의 관행이라고 할 수 있죠

07:29.020 --> 07:30.160
네

07:30.250 --> 07:37.510
모듈을 소개하게 됐네요 오늘 사용할 플랫폼이죠

07:37.540 --> 07:44.110
모달은 서버에서 원격으로 코드를 실행할 수 있는 플랫폼으로 사용 시간당만

07:44.110 --> 07:45.460
지불할 수 있죠

07:45.490 --> 07:47.410
아주 강력한 플랫폼이죠

07:47.410 --> 07:52.930
인공지능 세계에서 프로덕션 모델 배포에 많이 사용되고 있죠

07:52.960 --> 07:58.900
하지만 다양한 목적에 사용될 수도 있어요 CPU 사용이나 클라우드에

07:58.900 --> 08:01.960
어떤 함수든 배포하는 데요

08:02.260 --> 08:06.730
그럼 지체 없이 다음 비디오에선 모듈로 가서 시도해 보죠

08:06.760 --> 08:07.660
거기서 봐요
