WEBVTT

00:01.040 --> 00:10.460
さて､ ここでJupyter Labに戻り､ フロンティア・モデルの次の使用に備える｡

00:10.460 --> 00:12.320
これはごく自然なことのはずだ｡ 

00:12.710 --> 00:18.470
いつものように､ システムのプロンプトを検討し､ モデルをどのようにプロンプトさせるかを考えることから始める｡

00:18.800 --> 00:25.610
つまり､ 最も詳細で質の高い説明があり､ 価格が明確で､ JSONで厳密に応答する案件を選択することで､

00:25.610 --> 00:37.820
リストから最も詳細な5つの項目を特定し､ 要約するのです｡

00:37.910 --> 00:42.740
ええと､ 最も重要なのは､ 最も詳細な商品説明がある5つの案件を回答することです｡ 

00:42.740 --> 00:44.810
用語について言及することは重要ではない｡ 

00:45.110 --> 00:49.940
それから､ JSONの構造もここに書きました｡ 

00:49.940 --> 00:54.020
構造化されたアウトプットを使うのだから､

00:54.020 --> 01:01.940
これは必須ではないことは言っておくべきだろう｡

01:02.120 --> 01:04.650
だから､ これは実験できることなんだ｡ 

01:04.650 --> 01:08.700
しかし厳密に言えば､ JSONをこのように指定する必要はないはずだ｡ 

01:09.420 --> 01:11.640
これが私のシステム・プロンプトだ｡ 

01:11.670 --> 01:16.740
ユーザーには､ このリストの中から最も有望な5つの取引を回答するよう促される｡ 

01:16.740 --> 01:17.700
それらを選ぶ｡ 

01:17.730 --> 01:18.510
ブラブラ､ ブラブラ､ ブラブラ｡ 

01:18.540 --> 01:19.470
最後まで読んでほしい｡ 

01:19.470 --> 01:20.610
でもね､ こういうことなんだ｡ 

01:31.410 --> 01:31.800
オーケー｡ 

01:31.830 --> 01:32.310
簡単なことだ｡ 

01:32.310 --> 01:36.660
それでは､ ユーザー・プロンプトの冒頭をプリントしてみよう｡ 

01:36.660 --> 01:39.720
そこで､ ユーザー・プロンプトの最初の2000文字を表示することにする｡ 

01:39.720 --> 01:41.310
それで感覚をつかむんだ｡ 

01:41.340 --> 01:42.270
これだ｡ 

01:42.270 --> 01:43.290
見てみよう｡ 

01:43.290 --> 01:48.270
だから､ ユーザーのプロンプトは､ ブラブラ､ ブラブラ､ ブラブラ､ ブラブラと答えるんだ｡ 

01:48.270 --> 01:50.370
そしてお得な情報だ｡ 

01:50.370 --> 02:00.960
そして､ これはdescribeメソッドの前に見たdescribe関数から取り出した記述です｡

02:00.960 --> 02:12.650
つまり､ GPT4に課している仕事は､ この案件リストを消化し､ その中から50件を選び出すことだ｡

02:12.650 --> 02:19.220
最も明確な説明があり､ 価格がわかる5つを選ぶ｡ 

02:19.250 --> 02:24.950
最も明確な方法でこの価格を解析する｡ 

02:25.100 --> 02:29.240
そしてそれはもちろん､ 考えなければならないファジーな種類の問題である｡ 

02:29.240 --> 02:33.680
ほんの1､ 2年前なら考えられなかったようなことだ｡ 

02:33.770 --> 02:38.180
エンジニアリング・コードだけを使って､ 信頼性の高い方法でそれを行うにはどうしたらいいのだろう｡ 

02:38.180 --> 02:44.990
フロンティア・モデルには最適な問題だ｡ このようなニュアンスの理解や､ 何かまでは価格を意味し､

02:44.990 --> 02:52.190
何かから離れることまでは価格と同じではないことを理解することができるからだ｡

02:52.190 --> 02:54.620
そういうロジックは本当に難しい｡ 

02:54.620 --> 03:00.680
しかし､ フロンティア・モデルは､ それを理解し､ これらの表現の背後にある意味を理解し､ それをインテリジェントに使ってアウトプットを出すという点で､

03:00.680 --> 03:05.630
驚くほど効果的なのだ｡

03:05.630 --> 03:12.950
だから､ これらのプロンプトに基づいて､ オーケー､ 推薦状をもらおう､ と言えるようになった｡ 

03:12.950 --> 03:18.290
そして今､ 構造化出力を使っているため､ 通常とは異なるAPIを見ることになる｡ 

03:18.710 --> 03:23.300
だから､ 私の推薦文を完成させる機能はOpenAIだ｡ 

03:23.300 --> 03:24.800
そして､ ここはちょっと違う｡ 

03:24.800 --> 03:31.160
少なくとも現時点では､ これはOpenAIのベータ版である｡ 

03:31.190 --> 03:34.310
でも､ もうすぐ完全生産化されるんだろうね｡ 

03:34.310 --> 03:39.110
OpenAIのベータ版､ あるいはアメリカ人にとってはベータ版ということですね｡ 

03:39.170 --> 03:44.870
OpenAIのベータ版､ ドットチャット､ ドット補完､ ドット解析｡ 

03:44.960 --> 03:52.520
そうやって､ いつものようにモデルを提供するんだ｡ 

03:52.520 --> 03:57.620
そして､ これはGPT4とミニ､ GPT4､ フロンティア・バージョン2でサポートされている｡ 

03:57.770 --> 04:02.120
ええと､ いつものように､ メッセージは､ ほら､ 言わないでおこうと思ってるんだ｡ 

04:02.120 --> 04:02.870
知っているはずだ｡ 

04:02.870 --> 04:04.100
私が言うまでもないだろう｡ 

04:04.130 --> 04:07.310
確かに､ あー､ ここが違う｡ 

04:07.310 --> 04:14.000
過去に､ JSONを要求することを指定する方法として､ このレスポンス・フォーマットを使用したことを覚えているだろう｡

04:14.030 --> 04:16.700
さて､ 今回はJSONとは言わない｡ 

04:16.730 --> 04:20.900
私たちがすることは､ 取引選択クラスをクラスに渡すことだ｡ 

04:20.900 --> 04:25.490
これが今見ていたクラスで､ 私がJSONをスクラップしたものだ｡ 

04:25.520 --> 04:30.020
そのクラスを応答フォーマットとして渡す｡ 

04:30.500 --> 04:35.810
そして､ 結果を得るときには､ 通常のAPIコールは呼び出さない｡ 

04:35.810 --> 04:43.340
完了はいつものようにドット・メッセージでゼロ､ そして内容ではなくドット・パースされたものとする｡ 

04:43.340 --> 04:49.970
そして､ その応答を解析して､ ディールセレクションのインスタンスにする｡ 

04:50.000 --> 04:52.100
そして､ それが返ってくる｡ 

04:52.400 --> 04:54.710
だから､ その積み重ねで返した方がいい｡ 

04:54.740 --> 04:59.780
このコードを実行し､ 何が起こり､ 何が返ってくるか見てみよう｡ 

04:59.780 --> 05:05.150
だからGPTはゼロ､ GPTはミニと呼んでいる｡ 

05:05.180 --> 05:09.830
特定の構造化された出力形式を指定しているのだ｡ 

05:09.830 --> 05:10.820
戻ってきた｡ 

05:10.850 --> 05:17.390
では､ どのような結果が出たのかプリントしてみよう｡ 

05:17.390 --> 05:19.520
どんなものが戻ってきたのか見てみよう｡ 

05:19.520 --> 05:23.210
エージェントのお得な契約セレクションだ｡ 

05:23.210 --> 05:26.150
それこそ､ 私たちが取り戻したいと願っていたものだ｡ 

05:26.150 --> 05:31.760
実際にどうなのか､ 見たほうがいいと思う｡ 

05:31.790 --> 05:34.490
セットだろう｡ 

05:34.610 --> 05:38.780
ええと､ これはディールの選択で､ その中にディールというフィールドがあります｡ 

05:38.780 --> 05:39.350
覚えているかな？

05:39.380 --> 05:40.850
ディールは私たちが設定したものだ｡ 

05:40.850 --> 05:42.140
そして､ こちらがお得な情報だ｡ 

05:42.140 --> 05:45.830
では､ どれだけのディールが戻ってきたかを見てみよう｡ 

05:46.460 --> 05:49.730
もちろん､ 5つの契約を取り戻したいと思っている｡ 

05:50.000 --> 05:50.870
見てみよう｡ 

05:50.900 --> 05:53.870
確かに5つの契約を取り返すことができた｡ 

05:53.870 --> 05:57.020
そして､ その最初の取引を印刷しよう｡ 

05:57.020 --> 06:02.780
そして､ トップクラスのスマートウォッチ､ サムスン・ギャラクシー・ウォッチ・ウルトラを手に入れた｡ 

06:02.960 --> 06:06.710
ええと､ これをうまくまとめたものがあるんだ｡ 

06:06.710 --> 06:10.010
そして､ これが実際､ 我々にとって素晴らしいものに見えていることにお気づきだろう｡ 

06:10.010 --> 06:22.250
GPT4ミニが価格とURLを出してきた｡

06:22.250 --> 06:26.060
もちろん､ そのURLをクリックすれば､ その取引が開かれる｡ 

06:26.060 --> 06:27.020
あれだ｡ 

06:27.020 --> 06:28.160
素晴らしい｡ 

06:28.310 --> 06:32.690
僕らにとってはうまくいっているよ｡ 

06:32.960 --> 06:34.790
ああ､ わかった｡ 

06:34.820 --> 06:46.850
さて､ 最後にスキャナ・エージェントをインポートしてみましょう｡ 

06:46.850 --> 06:51.380
1､ 2分かかるだろうから､ もう一度､ キックオフをやってみるよ｡

06:51.770 --> 06:57.950
その間に､ スキャナー・エージェントがどんなものかをお見せしましょう｡ 

06:57.950 --> 07:01.370
スキャナー係はこっちだ｡ 

07:01.640 --> 07:08.180
ええと､ これは前に見たコードとよく似たコードの束です｡ 

07:08.540 --> 07:18.620
それで､ 今､ コメントを入れて､ よりよい構成で書いている｡

07:18.620 --> 07:18.620
ご覧ください｡ 

07:18.890 --> 07:21.710
でも､ さっき見たようなシステムプロンプトがあるんだ｡ 

07:21.710 --> 07:28.880
ユーザープロンプトがあり､ それを見ると､ 5つのディールを厳守してください｡ 

07:28.880 --> 07:33.890
そして init メソッドがセットアップされ､ OpenAI に接続される｡ 

07:33.920 --> 07:45.020
fetch dealsは今見ていたメソッドで､ scrape deal fetchを呼び出してスクレイピングされたディールのリストを取得します｡

07:45.050 --> 07:52.820
しかし､ ここでもやっていることは､ 潜在的にURLのリストであるメモリー・オブジェクトを取得し､

07:52.820 --> 08:00.200
以前の検索ですでに表示されたと記憶しているものを結果から削除することである｡

08:00.200 --> 08:05.030
こうして､ すでに見たことのある案件ではなく､ 新しい案件を獲得するようにしている｡ 

08:05.030 --> 08:10.850
そしてもちろん､ エージェント・フレームワークを構築する上で重要な要素のひとつであるメモリーについては､

08:10.850 --> 08:12.860
今後さらに検討していくつもりだ｡

08:13.790 --> 08:20.510
そして､ ユーザー・プロンプトを作成し､ そして､ これは前と同じコードだ｡ 

08:20.510 --> 08:25.100
そして､ スキャンは基本的に､ 先ほど見た機能そのものである｡ 

08:25.130 --> 08:30.920
ユーザーのプロンプトを作成し､ OpenAIベータにドットチャット､ ドット補完､ ドット解析を呼び出します｡ 

08:30.920 --> 08:32.390
我々はモデルにパスを出す｡ 

08:32.390 --> 08:39.260
レスポンス・フォーマットが取引選択クラスである必要があることを指定し､ それが返されることを確認し､

08:39.260 --> 08:43.250
それをパースしてresultに戻す｡

08:43.250 --> 08:46.130
そして､ それが今ここにある｡ 

08:46.340 --> 08:53.000
そうしたら､ えーと､ えーと､ まず､ どんな取引も排除する｡ 

08:53.000 --> 08:57.860
価格がゼロより大きくない場合､ 価格がゼロの案件を返したくありません｡ 

08:58.010 --> 09:00.020
そしてその結果を返す｡ 

09:00.020 --> 09:05.750
そして､ もし何の取引も返ってこなかったら､ うーん､ おそらく､ すでにすべて表面化していたのだろうから､ 何も返さない｡

09:05.750 --> 09:08.930
そして､ それは一番上のオプションで示されている｡ 

09:08.990 --> 09:10.640
それがこのクラスだ｡ 

09:10.670 --> 09:13.340
ということで､ 3日目に戻ろう｡ 

09:13.340 --> 09:16.790
そして､ 結果が戻ってきたことを確認しなければならない｡ 

09:17.900 --> 09:22.190
さて､ 私が気づいたことのひとつに､ 皆さんもお気づきかもしれませんが､

09:22.190 --> 09:27.020
私がこの作業をしているときに､ 皆さんもお気づきかもしれませんが､

09:27.020 --> 09:36.230
私はこのことを考えながら話をするのに夢中でした｡

09:36.230 --> 09:45.860
でも､ このウェブサイトを見たとき､ 下取りで最大350ドル引きと書いてあった気がする｡

09:45.860 --> 09:48.830
他のデバイスをお持ちの場合､ 最大で350ドル節約できます｡ 

09:48.860 --> 09:55.280
フロンティア・モデルがいかにこのようなことに長けているかということをお見せした後で､

09:55.280 --> 10:03.530
これはモデルが実際に犯したミスの例である｡

10:03.530 --> 10:06.020
だから､ 私は自分の言葉を食べなければならない｡ 

10:06.020 --> 10:07.940
そして､ 実際にそれは間違っていた｡ 

10:07.940 --> 10:09.620
そして面白くなりそうだ｡ 

10:09.650 --> 10:13.400
つまり､ それを学び､ それを見たことは有益なのだ｡ 

10:13.670 --> 10:20.630
システム・プロンプトにそれを追加して､ そのパフォーマンスを改善できるかどうか試してみるかもしれない｡

10:20.630 --> 10:23.360
今､ 私たちはそれがミスを犯す可能性があることを知った｡ 

10:23.360 --> 10:27.380
とにかく､ スライドはまた次回に｡ 
