WEBVTT

00:00.980 --> 00:06.350
파이썬에서 C++로 변환하는 간단한 사용자 인터페이스를 만들고 있었습니다

00:06.350 --> 00:09.290
다양한 프론티어 모델을 이용해서요

00:09.290 --> 00:11.000
그래서 제가 그랬죠

00:11.000 --> 00:15.380
프로토타입 UI를 만들어 봅시다 그렇게 해 보죠

00:15.380 --> 00:22.340
다시 Jupyter 노트북으로 돌아오면 메서드를 몇 개 더 쓸 거예요

00:22.340 --> 00:31.100
먼저 실행 파이썬 을 코드로 이용합니다 이것과 비슷하게 약간 위험한 일을 하죠

00:31.130 --> 00:32.510
코드를 실행하세요

00:32.510 --> 00:35.480
이 프로토타입은 여러분을 위한 거예요

00:35.480 --> 00:40.550
이건 공유가 안 돼요 다른 사람과 공유하면 파이썬 코드를 여러분 박스에서 직접 실행할

00:40.550 --> 00:42.200
방법이 생기거든요

00:42.200 --> 00:43.370
그건 나쁜 일이죠

00:43.370 --> 00:50.270
이 특정 그래디오 앱에서 공유는 항상 거짓이어야 해요

00:50.360 --> 00:53.600
하지만 작업하기에는 훌륭한 프로토타입이에요

00:53.960 --> 00:57.170
이게 하는 일은 코드를 실행하는 거죠

00:57.170 --> 01:02.600
주변에 잡동사니가 있는 이유는 파이썬 코드에서 나온 표준을

01:02.600 --> 01:09.840
캡처해 반환하기 위해서입니다 코드를 취하고 실행하는 함수가 되고 결과물을 반환합니다

01:09.840 --> 01:15.030
그러데이션에서 디스플레이하고 싶기 때문이죠

01:15.030 --> 01:17.700
그게 실행 파이썬 이죠

01:17.910 --> 01:24.510
이제 C++를 실행하기 위한 약간 더 무거운 코드입니다 코드에 따라서요

01:24.510 --> 01:28.830
가장 먼저 할 일은 아까 만든 함수를 호출하는 겁니다 파일

01:28.830 --> 01:31.260
최적화에 쓰기 위해서요

01:31.590 --> 01:39.330
제가 하는 건 컴파일 명령 실행이 포함돼 있어요

01:39.360 --> 01:46.350
저는 subprocess.lon이라는 것을 사용합니다. 이것은 당신이 무언가 수행하기 위해 subprocess를

01:46.350 --> 01:48.180
생성할 수 있어요.

01:48.480 --> 01:49.920
그게 제 일이죠

01:49.920 --> 01:53.370
아까보다 약간 더 길어졌죠

01:53.370 --> 01:59.520
아까 우리가 뭘 할 건지 언급했었죠 플래그를 모두 사용해 코드를 컴퓨터에

01:59.520 --> 02:02.430
맞게 최적화하는 거예요

02:02.430 --> 02:06.750
이런 걸 잘 아는 사람들에겐 아직 시작에 불과해요

02:06.760 --> 02:11.050
추가할 수 있는 깃발이 정말 많아요

02:11.080 --> 02:16.000
이 정도면 충분하다 싶어서 깃발을 많이 달았어요 Put it

02:16.150 --> 02:28.720
그런 다음 최적화된 프로그램을 실행하고 표준을 캡처해 그걸 반환하죠

02:28.750 --> 02:30.970
오류가 있으면 표준 오류를 리턴하고요

02:31.210 --> 02:38.140
C++ 코드를 실행하고 응답을 반환하는 방법이죠

02:38.140 --> 02:41.200
컴파일과 실행이 더 정확하겠죠

02:41.470 --> 02:48.520
여기 CSS 문자열이 있어요 왜냐하면 제가 하려는 건 약간의 색칠하기거든요 곧 보시겠지만요

02:48.850 --> 02:50.440
비트

02:50.440 --> 02:53.740
이건 사용자 인터페이스의 확장이고요

02:53.740 --> 02:55.240
코딩은 이제 안 해요

02:55.240 --> 02:55.990
그냥 이거요

02:55.990 --> 03:02.410
짧게 말씀드릴게요 GR 블록을 사용하고 있어요 하위 레벨 Gadio API죠 사용자

03:02.410 --> 03:07.570
인터페이스에서 더 유연성을 제공합니다 라디오의 기성품 UI를

03:07.600 --> 03:09.070
쓰지 않고요

03:09.280 --> 03:12.770
자신만의 CSS를 통과시킬 수 있어요 저도 그렇게 하고 있죠

03:12.800 --> 03:15.140
CSS는 이 변수와 같아요

03:15.320 --> 03:18.740
비트를 좀 더 맞춤형으로 바꿀 수 있어요

03:18.860 --> 03:22.100
점무늬가 있어서 상단에 헤딩이 잘 나왔어요

03:22.100 --> 03:26.510
그리고 위젯이 하나, 둘, 셋, 넷 다섯 줄이에요

03:26.690 --> 03:30.110
파이썬 코드와 C++ 코드를 인식할 수 있어요

03:30.110 --> 03:35.000
그게 제가 파이 코드로 설정하기 전에 갖고 있던 기본값이죠

03:35.510 --> 03:39.800
그럼 아까처럼 GPT나 클로드를 뽑으러 내려가죠

03:40.040 --> 03:42.680
코드 변환 버튼요

03:42.680 --> 03:45.050
단추가 더 있어요

03:45.050 --> 03:51.770
파이썬 을 실행하기 위한 CP+CP+CP를 실행하는 거죠

03:51.770 --> 03:58.580
그리고 파이썬 아웃이 있습니다 파이썬의 CPOut CPOut C++ OUTPUT를 위해서요

03:58.610 --> 04:02.720
잘 따라오셨길 바랍니다 사용자 인터페이스를 보시면 아주 명확하게

04:02.750 --> 04:03.650
보일 거예요

04:03.650 --> 04:07.580
그리고 다시 보면 정말 간단하다고 생각하실 거예요

04:08.000 --> 04:13.000
버튼이 3개 있습니다 파이썬 실행과 C++ 실행이죠

04:13.000 --> 04:16.600
버튼 3개를 누르면 어떻게 되는지 물어봐야겠네요

04:16.630 --> 04:19.120
변환 버튼을 누르면 아까와 똑같아요

04:19.120 --> 04:25.810
메서드 함수 최적화를 실행하고 입력, 파이썬 코드와 모델을 전달하죠

04:25.840 --> 04:30.640
결과물은 C++ 코드로 갑니다 변환을 누르면 파이썬 코드를 가져오는 거죠

04:30.640 --> 04:35.290
모델을 이용해 변환하고 C++로 입력할 거예요. Tool karaoke, Tool karaoke.

04:35.500 --> 04:42.910
파이썬 실행 버튼을 누르면 파이썬 코드로 파이썬 아웃을 실행할 거예요

04:42.940 --> 04:49.270
C++ 실행을 누르면 C++ 코드를 실행합니다 C++ 입력을 가지고요

04:49.300 --> 04:51.310
C 플러스 출력요

04:51.610 --> 04:53.140
그게 다예요

04:53.170 --> 05:00.850
스파게티 같은 걸 만드는 것처럼 들렸다면 이제 곧 보게 될 걸 보면 아주

05:00.880 --> 05:04.510
잘 풀리고 선명해질 거예요

05:04.780 --> 05:06.520
이걸 실행하죠

05:06.550 --> 05:08.470
이게 사용자 인터페이스예요

05:08.470 --> 05:11.080
다채로운 사용자 인터페이스에 잘 오셨어요

05:11.290 --> 05:14.830
파이썬 코드가 있고 C++ 코드가 있네요

05:14.830 --> 05:20.600
모델 변환 코드를 선택해야 합니다 파이썬을 실행하고 get C++를 실행할 수 있어요

05:20.600 --> 05:22.100
그럼 시작하죠

05:22.100 --> 05:25.640
이 코드를 실행하려면 파이썬 실행을 눌러요

05:25.790 --> 05:28.520
이 사용자 인터페이스에서 바로요

05:28.550 --> 05:31.460
지금 바로 그 메서드를 호출하고 있어요

05:31.460 --> 05:33.530
그 결과가 여기 있어요

05:33.680 --> 05:35.060
저기 있네요

05:35.210 --> 05:37.640
파이가 있긴 하죠

05:37.640 --> 05:39.890
8시간 걸렸어요 4초요

05:40.070 --> 05:45.950
이제 이걸 C 플러스로 변환할 거예요

05:45.950 --> 05:46.670
더 있어요

05:46.820 --> 05:47.930
여기 있네요

05:47.960 --> 05:50.930
이제 C 플러스 실행할 수 있어요

05:51.800 --> 05:55.550
C 플러스도 있네요

05:55.550 --> 06:00.890
아까보다 훨씬 빨라진 걸 보실 수 있어요 제 기억이 맞는다면 0 정도였죠 2초 남았어요

06:00.920 --> 06:08.090
이 코드를 최적화하는 추가 플래그가 있기 때문이죠

06:08.120 --> 06:15.410
두 가지 구현 간격이 100배 이상 빠른 걸 보실 수 있어요

06:15.410 --> 06:24.270
그리고 일종의 반복되는 수학 수학 코드는 일반적으로 컴파일된 C++가 이것처럼 기본적으로

06:24.300 --> 06:30.450
컴파일된다면 적어도 100배는 더 빠를 거예요.

06:30.450 --> 06:33.690
놀랍지 않은 건 아니지만 좋은 결과예요

06:33.960 --> 06:39.420
물론 비트는 아주 조금 빗나갔는데 아마도 플로팅 포인트 회전이

06:39.420 --> 06:41.550
원인일 거예요

06:41.550 --> 06:43.980
클로드가 어떻게 하는지 보고 확인해 보죠

06:46.830 --> 06:50.460
클로드의 C 플러스 플러스 코드를 실행해 보죠

06:50.760 --> 06:53.520
물론 아주 비슷하죠

06:53.520 --> 06:58.350
같은 숫자지만 마찬가지로 엄청나게 빠르죠

06:58.500 --> 07:05.010
그리고 아주 유사한 C 플러스 플러스 코드를 생성합니다 제가 기대하는 동일한 머신

07:05.040 --> 07:07.260
코드에 컴파일되는 것이죠

07:07.530 --> 07:08.400
좋아요

07:08.400 --> 07:14.850
한 번만 더 다음 영상으로 넘기고 어려운 문제를 해결하러 달려갈게요

07:14.850 --> 07:17.730
오늘은 여기까지 하죠 오늘은 여기까지예요

07:17.730 --> 07:19.620
여러분도 저만큼 즐거우셨길 바라요

07:19.650 --> 07:21.780
이건 정말 좋은 제품이에요

07:21.810 --> 07:22.770
이따 봐요
