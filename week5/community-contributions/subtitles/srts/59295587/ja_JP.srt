WEBVTT

00:00.980 --> 00:09.290
私があなたと別れたとき､ 私たちはPythonからCに変換するためのシンプルなユーザーインターフェイスを作ったばかりだった｡

00:09.290 --> 00:11.000
私はこう言った｡ 

00:11.000 --> 00:15.380
これをちゃんとしたプロトタイプUIにしよう｡ 

00:15.380 --> 00:22.340
このJupyterノートブックに戻ったら､ もう少しメソッドを書いてみよう｡

00:22.340 --> 00:31.100
まず第一に､ このPythonのテイク・コードの実行は､ ここでも同じように少し危険なことをしようとしている｡

00:31.130 --> 00:32.510
そのコードを実行する｡ 

00:32.510 --> 00:35.480
だから今回も､ この特別なプロトタイプは本当にあなたのためだけのものなんだ｡ 

00:35.480 --> 00:42.200
もしこれを誰かと共有したら､ 彼らはあなたのボックス上で直接Pythonコードを実行する方法を手に入れることになるからだ｡

00:42.200 --> 00:43.370
それは悪いことだ｡ 

00:43.370 --> 00:50.270
だから､ このグラディオのアプリでは､ シェアは常に虚偽であるべきなのだ｡ 

00:50.360 --> 00:53.600
ええと､ でも､ あなたにとっては素晴らしいプロトタイプだよ｡ 

00:53.960 --> 00:57.170
つまり､ このコードを実行するんだ｡ 

00:57.170 --> 01:02.600
Pythonのコードから出力される標準出力をキャプチャして､

01:02.600 --> 01:15.030
それを返すことで､ コードを受け取って実行し､ gradioに表示するための出力を返す関数にしたいからだ｡

01:15.030 --> 01:17.700
これがパイソンの実行だ｡ 

01:17.910 --> 01:24.510
そして今度は､ Cプラス・プラス・ウムのコードを実行するための､ 少し重いコードだ｡ 

01:24.510 --> 01:31.260
それで､ 最初にすることは､ 少し前に書いた関数を呼び出して､ 実際に最適化されたファイルに書き出すことだ｡

01:31.590 --> 01:39.330
それから､ コンパイルコマンドを実行するんだ｡ 

01:39.360 --> 01:48.180
私はサブプロセスのドットランというものを使っている｡ これは､ 何かを実行するためにサブプロセスをスポーンさせる方法だ｡

01:48.480 --> 01:49.920
それが僕の仕事なんだ｡ 

01:49.920 --> 01:53.370
さて､ 以前より少し長くなっていることにお気づきだろうか｡ 

01:53.370 --> 01:59.520
これは､ コードが私のコンピュータに最適化されていることを確認するために､

01:59.520 --> 02:02.430
すべてのフラグを使用するものです｡

02:02.430 --> 02:06.750
このようなことを知り尽くしている人たちにとっては､ ほとんど表面をなぞるようなものだ｡ 

02:06.760 --> 02:11.050
追加できるフラッグは山ほどある｡ 

02:11.080 --> 02:16.000
しばらくして､ これで十分だと思ったので､ そのためのフラッグをたくさん入れた｡ 

02:16.150 --> 02:28.720
そして､ 最適化されたプログラムを実行し､ 標準出力をキャプチャしてそれを返す｡

02:28.750 --> 02:30.970
エラーがあれば標準エラーを返す｡ 

02:31.210 --> 02:38.140
これが､ Cプラス・プラス・コードを実行し､ レスポンスを返す方法である｡ 

02:38.140 --> 02:41.200
本当はコンパイルして実行した方が正確なんだけどね｡ 

02:41.470 --> 02:50.440
ここではCSSの文字列を少し使っている｡

02:50.440 --> 02:53.740
そして､ これがユーザーインターフェースの範囲であり､ すべてである｡ 

02:53.740 --> 02:55.240
もうコーディングはしない｡ 

02:55.240 --> 02:55.990
ただこれだけだ｡ 

02:55.990 --> 03:02.410
GRブロックを使っていますが､ これはGradioの下位APIで､

03:02.410 --> 03:09.070
ユーザーインターフェースの柔軟性を高めることができます｡

03:09.280 --> 03:12.770
自分のCSSを渡すこともできる｡ 

03:12.800 --> 03:15.140
CSSはこの変数に等しい｡ 

03:15.320 --> 03:18.740
それで､ もう少しカスタマイズできるんだ｡ 

03:18.860 --> 03:22.100
このドットマークダウンは､ トップに素敵な見出しをつけてくれる｡ 

03:22.100 --> 03:26.510
そして､ ウィジェットが1列､ 2列､ 3列､ 4列､ 5列と並んでいる｡ 

03:26.690 --> 03:30.110
あの......PythonのコードとCプラスアルファのコードはわかると思う｡ 

03:30.110 --> 03:35.000
デフォルト値を円周率コードに設定する前は､ まさにそうだった｡ 

03:35.510 --> 03:39.800
ええと､ これは前と同じで､ GPTかClaudeを選ぶドロップダウンです｡ 

03:40.040 --> 03:42.680
コードを変換するボタンだ｡ 

03:42.680 --> 03:45.050
それからもういくつかボタンがある｡ 

03:45.050 --> 03:51.770
Pythonの実行はPythonを､ CPの実行はC plus plusを実行する｡ 

03:51.770 --> 03:58.580
そして､ Pythonの出力CPをCプラスプラス出力のためにPythonのアウトを持っている｡ 

03:58.610 --> 04:03.650
もしそうでなければ､ ユーザーインターフェイスをご覧になれば､ すべてが明らかになるでしょう｡

04:03.650 --> 04:07.580
そして､ これを振り返って､ ワオ､ これはとてもシンプルだと言うだろう｡ 

04:08.000 --> 04:13.000
変換､ Python実行､ Cプラスプラス実行の3つのボタンがあります｡ 

04:13.000 --> 04:16.600
では､ この3つのボタンのどれかをクリックしたらどうなるのか？

04:16.630 --> 04:19.120
変換ボタンを押しても以前と同じだ｡ 

04:19.120 --> 04:25.810
optimizeメソッド関数を実行し､ 入力､ Pythonコード､ モデルを渡す｡ 

04:25.840 --> 04:30.640
出力はC＋＋のコードになるので､ 変換を押すとPythonのコードが出力される｡ 

04:30.640 --> 04:35.290
モデルを使って変換し､ それをCプラスプラスに入れる｡ 

04:35.500 --> 04:42.910
Pythonの実行ボタンを押すと､ PythonコードをPythonに出力してPythonを実行する｡

04:42.940 --> 04:49.270
Cプラスプラス実行を押すと､ Cプラスプラスの入力でCプラスプラスのコードが実行される｡ 

04:49.300 --> 04:51.310
Cプラスプラス出力｡ 

04:51.610 --> 04:53.140
それだけだ｡ 

04:53.170 --> 05:00.850
もしそれが､ あー､ たくさんのスパゲッティみたいなものに聞こえたとしたら､ それは､ きれいに解けて､

05:00.880 --> 05:04.510
これから見るものを見れば超明確になる｡

05:04.780 --> 05:06.520
ええと､ これを実行しよう｡ 

05:06.550 --> 05:08.470
これがユーザー・インターフェースだ｡ 

05:08.470 --> 05:11.080
よりカラフルなユーザーインターフェースへようこそ｡ 

05:11.290 --> 05:14.830
ここにはPythonのコードとC＋＋のコードがある｡ 

05:14.830 --> 05:20.600
そして､ モデル変換コードを選択し､ Pythonを実行し､ Cプラスプラスを実行することができる｡ 

05:20.600 --> 05:22.100
では､ 始めよう｡ 

05:22.100 --> 05:25.640
ここでPythonの実行を押して､ このコードを実行することができる｡ 

05:25.790 --> 05:28.520
このユーザー・インターフェイスから｡ 

05:28.550 --> 05:31.460
今まさにそのメソッドを呼び出している｡ 

05:31.460 --> 05:33.530
その結果がここにある｡ 

05:33.680 --> 05:35.060
あ､ あった｡ 

05:35.210 --> 05:37.640
確かに円周率はある｡ 

05:37.640 --> 05:39.890
そして8人かかった｡  4秒｡ 

05:40.070 --> 05:45.950
そして､ Cプラスに変換する｡ 

05:45.950 --> 05:46.670
それに

05:46.820 --> 05:47.930
これだ｡ 

05:47.960 --> 05:50.930
そして､ Cプラスプラスを走らせることができるようになった｡ 

05:51.800 --> 05:55.550
これでCプラス・プラスだ｡ 

05:55.550 --> 06:00.890
私の記憶が正しければ､ 約0だった以前よりかなり速くなっているのがわかるだろう｡  2秒｡ 

06:00.920 --> 06:08.090
それは､ このコードを最適化するための追加フラグがあるからなんだ｡ 

06:08.120 --> 06:15.410
それで､ 2つの実装の間で100倍以上速くなったことがわかるだろう｡ 

06:15.410 --> 06:24.270
そして､ ループするような数学的なコードでは､ 通常､ C＋＋＋のネイティブ・コンパイルの方が､

06:24.300 --> 06:30.450
少なくとも100倍は速くなると予想される｡

06:30.450 --> 06:33.690
だから､ それほど驚くような結果ではないが､ 良い結果だ｡ 

06:33.960 --> 06:41.550
ええと､ もちろん､ 数字は､ ええと､ ほんの少しずれているんだけど､ それはたぶん､ 浮動小数点の丸め方のせいだと思う｡

06:41.550 --> 06:43.980
クロードの様子を見て､ 確認しよう｡ 

06:46.830 --> 06:50.460
そして､ クロードのCプラスプラスのコードを実行してみよう｡ 

06:50.760 --> 06:53.520
もちろん､ とてもよく似ている｡ 

06:53.520 --> 06:58.350
同じ番号､ 同じように超高速｡ 

06:58.500 --> 07:07.260
その結果､ 非常によく似た......C＋＋＋のコードが生成され､ それが同じマシンコードにコンパイルされているのだと思う｡

07:07.530 --> 07:08.400
分かった｡ 

07:08.400 --> 07:14.850
もう1つ､ 次のビデオに移ってから､ ここを通してハードな問題に取り組むことになる｡ 

07:14.850 --> 07:17.730
ええと､ それで今日は終わりにしよう｡ 

07:17.730 --> 07:19.620
僕と同じように楽しんでもらえたら嬉しい｡ 

07:19.650 --> 07:21.780
これは素晴らしい小さな製品だ｡ 

07:21.810 --> 07:22.770
すぐに会おう｡ 
