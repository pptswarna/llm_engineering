WEBVTT

00:00.500 --> 00:01.460
お帰りなさい｡ 

00:01.460 --> 00:08.330
最後のパートでは､ 円周率を計算するシンプルなPythonプログラムを効率的なCプラスアルファのコードに変換するという課題にGPTの4人とクローを与えたが､

00:08.330 --> 00:14.630
どちらのフロンティアモデルもうまくいった｡

00:15.050 --> 00:21.620
GPT4ではもう少しヒントを出しただけだったが､ 次はもっと難しい問題に移る｡ 

00:21.890 --> 00:29.210
このコードは､ Python hardと呼ばれるPythonのコードで､ もうちょっとだけ仕事がある｡ 

00:29.300 --> 00:37.040
最大サブアレイ和と呼ばれるものを計算するんだ｡ 

00:37.040 --> 00:39.170
そして､ これがその結果だ｡ 

00:39.200 --> 00:45.590
つまり､ ランダムな､ あるいは擬似的にランダムな正負の数の配列､

00:45.590 --> 00:49.820
リストが与えられたとする｡

00:49.820 --> 00:59.590
この質問で問われているのは､ 大きな配列の中にある連続した数字のサブ配列の集合をすべて取り出して足し合わせれば､

00:59.590 --> 01:06.520
その部分の和が得られるということだ｡

01:06.520 --> 01:11.920
可能なサブアレイの最大の合計は？

01:11.920 --> 01:17.200
配列の任意の始点と終点を選び､ 最大の部分配列が得られるように選び､

01:17.200 --> 01:24.460
その最大の数､ 最大の部分配列の数を返す｡

01:25.000 --> 01:28.630
そしてもちろん､ ここにはマイナスの数字があることを念頭に置かなければならない｡ 

01:28.630 --> 01:31.690
だから､ 明白な答えがあるわけではない｡ 

01:31.960 --> 01:36.820
そして､ このコードが実際に機能する方法は､ 単純にすべてを試してみることだ｡ 

01:36.820 --> 01:48.580
ループの中のループで､ 開始点をループし､ 終了点をループし､ 現在の合計と最大合計を比較してその合計を返す｡

01:49.330 --> 01:51.340
つまり､ この機能はそういうことなのだ｡ 

01:51.340 --> 01:52.960
それがこのコードの肝だ｡ 

01:52.960 --> 01:55.180
ここにはもう2つのことがある｡ 

01:55.300 --> 02:12.620
Pythonの乱数メソッドやrandomライブラリのようなものは使いたくない｡

02:12.740 --> 02:21.530
その代わりに､ ここではごく一般的な､ ごく単純な擬似乱数発生器を実装した｡

02:21.530 --> 02:24.890
これは線形合同発生器として知られている｡ 

02:24.890 --> 02:27.680
公式を見たければググればいい｡ 

02:27.770 --> 02:28.670
それが私のしたことだ｡ 

02:28.940 --> 02:45.650
これは､ シードに基づいて予測可能な乱数のストリームを生成する簡単な方法である｡

02:46.070 --> 02:55.040
このジェネレーターが乱数を生成する｡ 

02:55.040 --> 03:02.410
フロンティア・モデルにとって､ それをC＋＋＋のコードに変換する方法を見つけるのは難しいだろうから｡

03:02.410 --> 03:04.330
アプローチしなければならないだろう｡ 

03:04.450 --> 03:09.670
うーん､ 簡単には変換できないけど､ 円周率関数のようなものは与えられない｡ 

03:09.880 --> 03:12.610
ええと､ これはループの中でループを行うものです｡ 

03:12.910 --> 03:18.760
そして､ これを20回繰り返す｡ 

03:18.760 --> 03:28.810
そして......別のシードで行った20回の合計を取る｡ 

03:28.870 --> 03:37.090
ここでいくつかのセッティングを行うことで､ すべての走行で一貫した走りができるようになる｡

03:37.270 --> 03:45.760
ええと､ それからこれを20回やって時間を計っているんだけど､

03:45.790 --> 03:52.570
これも実行しながら話すべきだったかもしれない｡

03:52.570 --> 03:56.880
だから､ これから1分間､ どうすれば君に興味を持って待ってもらえるか考えなければならない｡ 

03:57.000 --> 04:04.890
ええと､ 繰り返しになるけど､ exacは､ 誰かが何かにexacを実行するように言うたびに､

04:04.890 --> 04:07.920
眉をひそめたくなるようなものだ｡

04:08.040 --> 04:13.800
でも､ もちろん､ ここで私のコードを注意深く見て､ 何も悪賢いことは起きていないし､

04:13.800 --> 04:20.070
数学の束しかないことを自分で納得することができる｡

04:20.160 --> 04:23.160
それに､ 僕にはイギリス訛りがあるんだ｡ 

04:23.160 --> 04:24.840
それは私が信じられるということに違いない｡ 

04:25.170 --> 04:25.440
ええと｡ 

04:25.440 --> 04:26.010
分かった｡ 

04:26.040 --> 04:28.350
とにかく､ おしゃべりはここまでだ｡ 

04:28.470 --> 04:29.880
ああ､ 役目は終わったよ｡ 

04:29.880 --> 04:33.960
たった27秒だったから､ あんなにジャブジャブ喋る必要はなかった｡ 

04:34.110 --> 04:43.110
そして､ 全20回を通したサブアレイの最大合計は､ 10,980というかなり大きな数字になった｡ 

04:43.140 --> 04:48.780
もちろん､ プラスもマイナスもあり､ そのバランスが取れているからだ｡

04:49.320 --> 04:50.460
分かった｡ 

04:50.460 --> 04:57.880
だから今､ GPTにそのバージョンを作ってもらう時なんだ｡ 

04:57.910 --> 04:59.680
今､ そうしよう｡ 

05:05.140 --> 05:12.190
ここでGPTバージョンが登場したので､ それをコンパイルしてみよう｡ 

05:14.140 --> 05:19.030
そして､ 暗黙の変換という警告が出た｡ 

05:19.240 --> 05:22.690
そしてそれを実行したところ､ 間違った答えが返ってきた｡ 

05:48.280 --> 05:52.060
休憩の後､ クロードがどのようなプレーを見せるか見てみよう｡ 
