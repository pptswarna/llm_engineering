WEBVTT

00:00.500 --> 00:01.460
잘 돌아왔어요

00:01.460 --> 00:08.330
마지막 부분에서 GPT 4를 제공했고 파이썬 을 이용한 간단한 파이 계산 프로그램을 효율적인 C++

00:08.330 --> 00:14.630
코드로 전환하는 어려운 과제를 잘 해냈습니다 두 가지 미개척 모델 모두 좋은 결과를 거뒀죠

00:15.050 --> 00:21.620
GPT 4는 힌트를 몇 개 더 줬을 뿐입니다 이제 더 어려운 문제로 넘어가죠

00:21.890 --> 00:29.210
파이썬 코드의 경우, 파이썬 하드라고 불리는 이 코드는 좀 더 많은 작업을 수행하죠 비트

00:29.300 --> 00:37.040
최대 저금액이라는 걸 계산하는 거예요

00:37.040 --> 00:39.170
그 결과가 이거예요

00:39.200 --> 00:45.590
배열을 받았다고 가정해 보죠 양수와 음수가 여러 개 있는 난수

00:45.590 --> 00:49.820
혹은 양수와 음수가 나열된 배열이에요

00:49.820 --> 00:59.590
여기서 나오는 질문은 get a-aray, 혹은 더 큰 배열에서 연속되는 숫자 집합을

00:59.590 --> 01:06.520
가져다가 더하면 해당 섹션의 합계가 나온다는 거죠

01:06.520 --> 01:11.920
가능한 가장 큰 자금은 얼마일까요?

01:11.920 --> 01:17.200
배열에서 원하는 시작점과 끝점을 선택해 그걸 선택해 가장 큰

01:17.200 --> 01:24.460
서브 라이가 나오게 하고 가장 큰 숫자를 반환하는 거죠 가장 큰 서브 라이의 숫자요

01:25.000 --> 01:28.630
물론 음수가 있다는 걸 명심해야 해요

01:28.630 --> 01:31.690
확실한 답은 없어요

01:31.960 --> 01:36.820
이 코드가 작동하는 방법은 모든 걸 시도하는 거죠

01:36.820 --> 01:43.390
루프 안의 루프예요 시작점과 끝점을 통과하는 루프죠 현재 합계와

01:43.390 --> 01:48.580
최대 합계를 비교해서 합계를 반환해요

01:49.330 --> 01:51.340
이 함수가 하는 일이 그거죠

01:51.340 --> 01:52.960
그게 이 코드의 핵심이에요

01:52.960 --> 01:55.180
두 가지 문제가 더 있어요

01:55.300 --> 02:02.180
그 중 하나는 다수의 의사 난수들을 생성하는 것입니다 파이썬의 난수 메서드 같은

02:02.180 --> 02:09.980
것을 사용하고 싶지 않습니다 즉, 난수 라이브러리를 이용하지 않습니다 C++ 라이브러리와는

02:09.980 --> 02:12.620
맞지 않기 때문이죠

02:12.740 --> 02:21.530
그래서 여기서 우리가 한 건 아주 흔하고 아주 간단한 의사 난수 생성기를 구현했어요

02:21.530 --> 02:24.890
선형 통합 발생기라고 하죠

02:24.890 --> 02:27.680
공식이 궁금하면 구글에서 찾아보세요

02:27.770 --> 02:28.670
그렇게 했어요

02:28.940 --> 02:36.260
예측 가능한 난수의 흐름을 만드는 간단한 방법입니다 시드에 기반해서요

02:36.260 --> 02:43.610
C 플러스 플러스 코드가 파이썬 코드와 동일한 결과를 내는지 일관성을 유지하기

02:43.610 --> 02:45.650
위해서죠

02:46.070 --> 02:55.040
이 생성기가 값을 생성해서 난수들을 생성해요

02:55.040 --> 02:59.560
물론 저로서는 교묘한 방법이죠 왜냐하면 프런티어 모델에서는 C 플러스 플러스 코드로

02:59.560 --> 03:02.410
변환하는 방법을 알아내기가 어려울 테니까요

03:02.410 --> 03:04.330
접근해야 할 거예요

03:04.450 --> 03:09.670
쉬운 변환이 아니진 않지만 파이 함수 같은 걸 주진 않아요

03:09.880 --> 03:12.610
이건 루프 안의 루프를 만드는 거예요

03:12.910 --> 03:18.760
이 과정을 20번 반복해요

03:18.760 --> 03:28.810
그리고 다른 씨앗으로 20번의 합계를 계산하는 거죠

03:28.870 --> 03:36.070
get으로 가기 위한 설정이 있습니다 일관되게 실행되도록요 매 실행마다 일관적으로

03:36.070 --> 03:37.090
하도록요

03:37.270 --> 03:45.760
그리고 20번 정도 반복합니다 실행할 때 미리 말씀을 드렸어야 하는 또 다른 경우입니다

03:45.790 --> 03:52.570
파이썬 에서 실행되는 데 1분 정도 걸리기 때문이죠

03:52.570 --> 03:56.880
어떻게 해야 흥미를 느끼실지 고민해 볼게요 1분 정도 기다려 주세요

03:57.000 --> 04:04.890
다시 말씀드리지만 EXAC은 확실히 눈썹이 휘둥그레질 만한 기능이에요 누가 EXAC을

04:04.890 --> 04:07.920
실행하라고 할 때마다요

04:08.040 --> 04:13.800
물론 제 코드를 자세히 살펴보시고 기만적인

04:13.800 --> 04:20.070
일은 없다는 걸 확인하세요 수학만 잔뜩 있어요

04:20.160 --> 04:23.160
게다가 전 영국 억양도 쓰잖아요

04:23.160 --> 04:24.840
그럼 내가 믿을 만하다는 뜻이겠죠

04:25.170 --> 04:25.440
네

04:25.440 --> 04:26.010
좋아요

04:26.040 --> 04:28.350
잡담은 그만하죠

04:28.470 --> 04:29.880
다 됐어요

04:29.880 --> 04:33.960
27초밖에 안 되는데 그렇게 떠들 필요는 없잖아요

04:34.110 --> 04:43.110
그럼 총 20번의 시도에서 최고 수익이 10,980개로 꽤 큰 건가요?

04:43.140 --> 04:47.460
물론 엄청난 숫자는 아니에요 장단점이 있으니까요 모두

04:47.460 --> 04:48.780
균형을 이루죠

04:49.320 --> 04:50.460
좋아요

04:50.460 --> 04:57.880
이제 GPT에 버전 제작을 요청할 때예요

04:57.910 --> 04:59.680
지금 하죠

05:05.140 --> 05:12.190
GPT 버전이 있는데 컴파일을 해볼게요

05:14.140 --> 05:19.030
경고를 생성했어요 암묵적 변환이죠

05:19.240 --> 05:22.690
그런데 실행했더니 틀린 답이 나왔어요

05:22.690 --> 05:28.750
이 경우 힌트가 있고 그런 사실에도 불구하고 그것이 저지른

05:28.750 --> 05:37.870
실수에 대해 경고했어요 꽤 빨리 실행되는 코드를 생성했지만 슬프게도 문제가 발생하죠

05:37.870 --> 05:44.650
숫자가 넘쳐서 C 플러스 전문가가 확인해야 할 거예요 결국

05:44.650 --> 05:48.190
숫자 0이 되죠

05:48.280 --> 05:52.060
광고 후에 클로드가 어떻게 하는지 보죠
