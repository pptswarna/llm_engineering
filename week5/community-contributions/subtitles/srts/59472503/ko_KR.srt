WEBVTT

00:01.010 --> 00:02.810
주피터 연구소에 잘 오셨어요

00:02.810 --> 00:09.050
지난 시간에는 바보 같은 모델을 살펴봤죠 제품의 가격을 예측해서 기본 기준을 설정하는

00:09.050 --> 00:10.520
방법이었죠

00:10.550 --> 00:14.270
이제 좀 더 흥미로운 기본 모델을 살펴보죠

00:14.270 --> 00:20.150
이건 물론 도표입니다 아주 간단한 모델로 평평한 평균 가격을 예측할

00:20.150 --> 00:20.900
수 있죠

00:21.230 --> 00:26.810
여기서 아주 작은 변화가 보이실 겁니다 제가 색을 바꿨죠 원래 여기 있던 노란색이 더 보기

00:26.810 --> 00:30.740
좋은 주황색으로 바뀌었어요 노란색이 잘 안 보이거든요

00:30.740 --> 00:34.370
하지만 그렇지 않다면 익숙한 사진일 거예요

00:34.460 --> 00:39.950
평균적으로 145달러가 빠져나갔어요

00:40.010 --> 00:45.470
앞서 다이어그램을 봤을 때 말씀드리고 싶은 게 있는데 이걸 봤는지 모르겠는데

00:45.470 --> 00:49.610
평균적으로 340달러나 차이가 나요

00:49.610 --> 00:55.610
즉, 평균보다 무작위로 추측하면 상당히 나쁜 결과가 나온다는

00:55.610 --> 00:56.420
거죠

00:57.170 --> 01:02.980
네, 물론 데이터 세트가 균등하게 분배되지 않았기 때문이죠

01:02.980 --> 01:06.220
노드는 평균 500달러예요

01:06.940 --> 01:08.170
네

01:08.170 --> 01:15.640
그럼 이제 이 시점에서 기능 공학으로 넘어가겠습니다 전통적인 머신

01:15.640 --> 01:20.230
러닝 기술의 가장 근본적인 것 중 하나죠

01:20.230 --> 01:23.470
데이터 과학이 예전에 쓰던 방식이죠

01:23.470 --> 01:25.060
우리라면 이렇게 했을 거예요

01:25.060 --> 01:31.120
이런 문제가 발생하면 이런 문제를 해결할 양상은 무엇인지 생각해

01:31.120 --> 01:38.560
보게 됩니다 아마존 제품의 각 제품에서 가격을 예측하는 데 가장 적합한 양상은

01:38.560 --> 01:40.570
무엇인지 말이죠

01:40.570 --> 01:47.830
기능 엔지니어링이라는 걸 하려고 많은 시간을 들였어요 특정 아이템의 어떤

01:47.830 --> 01:54.010
속성이 가격을 예측하는 데 가장 중요한지 알아내는 거죠

01:54.190 --> 01:59.530
심층 신경망이 그 모든 걸 가능하게 하기 전까진 많은 시간을

01:59.530 --> 02:00.790
투자했죠

02:00.910 --> 02:07.360
어쨌든, 이제 기능 공학에 대해 공부할 겁니다 다시 한 번 말하지만 기능 공학이나

02:07.360 --> 02:12.370
전통적인 머신 러닝이 훌륭하게 작동할 때도 있어요

02:12.370 --> 02:14.860
가끔은 그게 문제가 될 수도 있어요

02:14.860 --> 02:19.630
아마존 제품의 경우 우리가 그런 영역에 있다고 생각할 수도 있어요

02:19.690 --> 02:21.970
하지만 성능은 봐야죠

02:21.970 --> 02:24.370
먼저 한 가지 상기시켜 드리죠

02:24.370 --> 02:29.590
제 훈련 데이터를 보면 기억하실 거예요

02:29.590 --> 02:31.630
디테일이라는 게 있어요

02:31.630 --> 02:36.280
아마존 데이터 세트에서 우리가 빨아들인 필드 중 하나예요

02:36.430 --> 02:41.230
이건 파이썬 사전처럼 생긴 비트인데요

02:41.260 --> 02:42.790
언뜻 보면요

02:42.910 --> 02:44.800
키와 가치가 보이죠

02:44.860 --> 02:48.280
그러면 전체적인 것이 문자열이라는 것을 알 수 있죠

02:48.280 --> 02:50.380
하나의 큰 문자열이죠

02:50.380 --> 02:53.980
사전을 나타내는 JSON 블롭이에요

02:54.190 --> 03:00.640
이 상세 필드를 읽을 수 있다면 좋을 것 같아요 트레이닝과 테스트에서 모든 데이터

03:00.640 --> 03:07.040
세트 포인트를요 그리고 텍스트에서 파이썬 사전으로 전환하는 거죠

03:07.040 --> 03:10.160
다행히 표준 라이브러리가 그걸 가능하게 하죠

03:10.160 --> 03:19.430
JSON 패키지를 이용해 JSON을 할 수 있어요 Loadstring을 하면 이런 문자열을 개체로 변환하죠

03:19.430 --> 03:22.880
그걸 실행하고 그걸 실행할 거예요

03:22.910 --> 03:25.190
몇 초면 돼요

03:25.190 --> 03:30.830
이제 트레인0.com 특징을 입력할 수 있어요

03:30.830 --> 03:36.830
그리고 이 문자열이 파이썬 사전에 변환된 걸 보게 될 거예요

03:37.010 --> 03:37.550
어디 보죠

03:37.550 --> 03:38.540
실행해 보죠

03:38.570 --> 03:39.680
됐어요

03:39.710 --> 03:40.820
보면 알잖아요

03:40.850 --> 03:41.180
미안해요

03:41.210 --> 03:46.220
사전을 확대해 보면 그 텍스트와 같은 걸 볼 수 있죠

03:46.430 --> 03:50.900
.키를 입력하면 여기 키가 있는 게 보이죠

03:51.380 --> 03:59.120
우리 데이터에 문제가 있어요 이 사전들은 다른 제품들에 대해 다르게 채워져 있다는

03:59.120 --> 04:00.320
거죠

04:00.320 --> 04:05.320
어떤 제품은 기능이 전혀 없어요

04:05.440 --> 04:09.700
어떤 건 특징이 거의 없어요

04:09.700 --> 04:11.950
일관성이 없는 포집이죠

04:11.950 --> 04:13.630
get get get을 해 보죠

04:13.720 --> 04:21.520
또 다른 유용한 파이썬 표준 라이브러리 도구를 사용할 수 있습니다 컬렉션 패키지에서 counter를요

04:21.550 --> 04:26.470
counter로 할 수 있는 건 숫자를 세는 겁니다 그런

04:26.470 --> 04:35.290
다음 기능 카운트, 가장 흔한 것 .40 같은 걸 말할 수 있죠 가장 흔한 걸 보여달라고 요청하는 거예요

04:35.290 --> 04:37.990
실행해보죠 뭐가 나오는지 보세요

04:38.200 --> 04:44.740
가장 일반적인 기능은 40개입니다 모든 훈련 데이터 포인트에 대항해

04:44.740 --> 04:46.450
채워져 있죠

04:46.690 --> 04:51.340
날짜 먼저 사용 가능은 많이 채운다는 거죠

04:51.370 --> 04:52.180
거의요

04:52.180 --> 04:52.810
네

04:52.840 --> 05:02.260
인구의 90%가 데이터 집합에 있는 400,000명 중 360,000명 정도에

05:02.260 --> 05:03.970
해당하죠

05:04.090 --> 05:07.190
품목의 무게는 아주 많이 차 있어요

05:07.220 --> 05:08.990
제조사 브랜드예요

05:09.020 --> 05:10.820
비슷한 베스트셀러예요

05:10.820 --> 05:14.780
랭크도 가득 찼다가 사라지기 시작하죠

05:15.050 --> 05:19.910
그럼 어떤 특징을 사용하면 좋을까요?

05:19.910 --> 05:22.520
많이 들어찬 걸 찾고 있어요

05:22.520 --> 05:23.600
시작이 좋네요

05:23.630 --> 05:30.110
지속적으로 채워지길 원하고 가격과 의미 있게 연관될 가능성이

05:30.110 --> 05:33.350
있는 뭔가가 되길 원해요

05:34.040 --> 05:38.600
이 아이템의 무게를 보면 꽤 확실한 후보 같아요

05:38.630 --> 05:44.840
당신 생각에는 확실하진 않지만 무게와 가격 사이에 상관관계가

05:44.840 --> 05:47.300
있을 거예요

05:47.510 --> 05:56.180
더 크고 무거운 제품이나 평균적으로 더 가치 있는 제품요 브랜드가 기능과 정확히

05:56.360 --> 06:01.100
일치하진 않겠지만 베스트셀러 순위에 들 수

06:01.100 --> 06:03.920
있는 방법이 있을 거예요

06:03.950 --> 06:04.880
중요한 단서일 수도 있어요

06:04.880 --> 06:07.360
베스트셀러로 잘 팔릴 것 같아요

06:07.390 --> 06:08.980
이것부터 시작하죠

06:09.010 --> 06:12.430
이런 것들은 처음부터 합리적인 기능으로 느껴졌어요

06:12.430 --> 06:16.990
한 가지만 더 추가할게요 아까 얘기했던 것으로 되돌아가는 거죠

06:17.320 --> 06:21.850
약간 조잡한 비트부터 시작할게요

06:21.880 --> 06:25.090
여기 비트를 보면 좀 진부해요

06:25.210 --> 06:34.510
이 사전에 채워진 무게는 아주 더러운 데이터예요

06:34.510 --> 06:40.450
파운드 단위로도 나오고 온스 단위로 나오기도 하고 100g 단위로

06:40.450 --> 06:45.490
나오기도 해요 1mg이나 킬로그램 등 다양하죠

06:45.490 --> 06:52.000
여기 if문이 있는데요 어떤 웨이트 단위를 입력했는지

06:52.000 --> 06:58.720
알아내고 파운드로 변환한 다음 그 양을 반환하죠

06:58.720 --> 07:00.100
그런 거였군요

07:00.100 --> 07:03.100
이게 효과가 있다는 걸 꼭 설득할 필요는 없어요

07:03.100 --> 07:04.270
내 말을 믿어요

07:04.270 --> 07:09.330
아니면 날 못 믿겠으면 들어와서 이걸 써봐요

07:09.510 --> 07:16.170
그리고 제 운동 기구에 쓸 웨이트도 전부 get 할 거예요

07:16.350 --> 07:25.230
그리고 이 선은 0을 걸러내는 거예요 단위를 인식하지 못하는 게 있으면

07:25.230 --> 07:31.290
0을 반환하기 때문에 훈련 데이터 집합의 평균

07:31.290 --> 07:36.030
무게를 계산할 수 있어요

07:36.030 --> 07:40.800
평균 체중은 13파운드예요 6개요

07:40.950 --> 07:44.430
왜 평균 무게를 재야 하냐고 하실 수도 있겠네요

07:44.430 --> 07:49.350
약간 기술적인 이유에서죠 이런 선형 퇴행 과정을

07:49.350 --> 07:55.290
다룰 때는 중량 인구가 없는 아이템을 어떻게 다룰지 결정해야

07:55.290 --> 07:59.880
합니다 훈련 아이템 중량 없는 10%를요

07:59.880 --> 08:04.770
다양한 기법을 사용할 수 있어요 데이터 과학자들도

08:04.770 --> 08:11.180
알 텐데 하중이 있는지 없는지를 나타내는 기능을 활용할 수 있어요

08:11.300 --> 08:16.880
그리고 모델의 몸에 그걸 어떻게 적용할지 어설프게 표현해야 해요

08:16.940 --> 08:22.880
완벽하게 신뢰할 수 있는 접근법이 하나 있는데 무게가 없는

08:22.880 --> 08:26.420
건 평균을 골라서 집어넣는 거예요

08:26.420 --> 08:34.700
기본값으로 함수 get-tier를 설정했는데 항목을 취하고 그 가중치를 얻으려 하죠

08:34.700 --> 08:41.360
가중치를 반환하거나 가중치가 없거나 0이면요 문제가 될 테니까요

08:41.360 --> 08:46.040
무게가 없는 건 평균 무게로 바꿔요

08:46.580 --> 08:49.940
기본값 get 웨이트고요

08:50.690 --> 08:55.100
기능 공학에서 꽤 지저분한 작업이 되었어요

08:55.100 --> 08:58.760
잠시 쉴 테니 다른 기능들을 잘 생각해 보세요

08:58.790 --> 09:03.830
잠시 후에는 베스트셀러 순위에 오르겠습니다 기능 엔지니어링과 모델을 실행하기

09:03.830 --> 09:04.880
전에요

09:04.880 --> 09:06.650
가격 예측도 하고요

09:06.680 --> 09:07.910
이따 봐요
