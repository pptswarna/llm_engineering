WEBVTT

00:00.920 --> 00:06.650
そこで､ 前日に構築したソリューションをもう一度見直して､ 測定基準について話をしよう｡ 

00:06.650 --> 00:15.020
今申し上げたように､ 私たちは非常にシンプルなビジネス中心の指標で業績を測定し､ 業績を評価しています｡

00:15.020 --> 00:17.180
単純にコードのパフォーマンスだ｡ 

00:17.180 --> 00:19.100
コードはどれだけ速くなったか？

00:19.100 --> 00:27.500
そして明らかにクロード3だ｡  5ソネットはそれを打ち砕き､ トップランナーとして､

00:27.740 --> 00:37.670
GPTフォーゼロがミッションに失敗することもあったが､ 成功することもあった｡

00:38.030 --> 00:45.320
そして残念なことに､ コード・クワンは､ 私が言うように､ まともな努力をしたが､ システム・プロンプトを通して強制的に結果を出そうと何度か試みたものの､

00:45.320 --> 00:50.000
正しい結果を得ることはできなかった｡

00:50.030 --> 00:52.610
わずかなズルも十分ではなかった｡ 

00:52.760 --> 01:04.370
クインには70億のパラメータがあり､ クローズドソースでは1兆をはるかに超えるパラメータがライバルになる｡

01:04.370 --> 01:09.050
だから､ それができたという事実そのものが､ 信じられないほど印象的なんだ｡ 

01:09.050 --> 01:18.920
それとは別に､ 運営費､ つまり0ドルであることを忘れないでほしい｡  80､ 私は推論エンドポイントとして稼働するために1時間を支払っていた｡

01:18.920 --> 01:20.540
それはさておき､ 無料である｡ 

01:20.540 --> 01:21.800
オープンソースだ｡ 

01:21.920 --> 01:25.070
だから､ APIのコストは払っていない｡ 

01:25.070 --> 01:37.790
特にGPUを持っている場合は､ GPUを動かすための電気代以外にコストはかからない｡

01:38.030 --> 01:42.110
とても印象的なモデルだよ｡ 

01:42.110 --> 01:48.350
たった70億のパラメーターを持つオープンソースのモデルが､ 円周率を計算するためにそのコードを変換するようなことができるのは､

01:48.350 --> 01:51.380
率直に言って異常なことだ｡

01:51.440 --> 01:56.060
そこで､ この時点で皆さんに課題を紹介したい｡ 

01:56.060 --> 02:01.540
そして今週､ 私はそのいくつかを手に入れた｡ それはとてもハードなものだが､

02:01.540 --> 02:05.770
とても充実し､ 満足のいくものだ｡

02:05.890 --> 02:07.390
時間があることを願うよ｡ 

02:07.390 --> 02:12.460
この数日間のレクチャーは､ 時間を空けるために比較的簡潔なものにした｡ 

02:12.460 --> 02:16.060
これで､ これまで学んできたことの多くがより確かなものになるだろう｡ 

02:16.090 --> 02:18.010
微調整すべき点がいくつかある｡ 

02:18.010 --> 02:19.690
解決策はすでにある｡ 

02:19.720 --> 02:33.220
クローズドソースのモデルにジェミニを追加することで､ ジェミニはクロードとジェミニのGPTとなり､ さらにオープンソースのモデルを追加することもできる｡

02:33.220 --> 02:43.390
私が提案したように､ コード・ラマとスターコーダーを加えれば､ コード・ジェンマを強制的に働かせることができるかどうかがわかるだろう｡

02:43.420 --> 02:52.660
乱数ジェネレーターを書き換えないように､ 積極的なプロンプトを出すことで､ そうならないように説得できるかもしれない｡

02:52.660 --> 02:54.580
ええと､ 僕より運があるかどうか見てみて｡ 

02:54.580 --> 02:57.600
もしそうなら､ どうかコードをプッシュしてほしい｡ 

02:57.660 --> 02:58.680
見せてくれ｡ 

02:58.710 --> 03:00.840
他の人たちにも教えてあげよう｡ 

03:00.840 --> 03:03.390
そうすれば､ 私たち全員がその恩恵を受けることができる｡ 

03:03.390 --> 03:04.290
そしてそれは

03:04.320 --> 03:04.710
そうだね｡ 

03:04.740 --> 03:05.940
本当に素晴らしい｡ 

03:05.940 --> 03:09.240
ぜひ試して､ 結果をシェアしてほしい｡ 

03:09.240 --> 03:10.470
でも､ それなら

03:11.190 --> 03:19.380
しかし､ そんなあなたには､ コードを生成する能力を必要とする3つの難題がある｡

03:19.380 --> 03:21.030
それは次のレベルに進むことになる｡ 

03:21.270 --> 03:24.630
そこで､ 本当に素晴らしいアイデアをいくつか紹介しよう｡ 

03:24.630 --> 03:33.900
そのひとつは､ コードにコメントやdocstringを自動的に追加できるコーディング・ツールを書くことだ｡

03:34.080 --> 03:38.490
すでにそれを実現する製品がいくつかあることは知っているが､ 自分でやってみて､ それが機能しているのを確認し､

03:38.490 --> 03:42.180
自分のためにこれを実行するのに十分なコードかどうかを確認するのは素晴らしいことだ｡

03:42.600 --> 03:47.610
もうひとつは､ ユニットテストを書けるツールだね｡ 

03:47.610 --> 03:53.340
ユニットテストは､ 私たちの人生の悩みの種だ｡ 

03:53.400 --> 03:55.620
ああ､ とても過酷なものだよ｡ 

03:55.870 --> 04:02.170
また､ ユニットテストが単に関数の入出力を複製するだけで､ 何か賢明なことをするわけではない場合､

04:02.170 --> 04:06.190
ユニットテストは非常に稚拙に書かれることがある｡

04:06.190 --> 04:17.410
そこで､ 特定のPythonモジュールのユニットテストケースを生成するために､ フロンティアモデルや､ もしかしたらオープンソースモデルを使うことができるかどうかを見てみましょう｡

04:17.620 --> 04:21.220
そして最後に､ これは本当に楽しいものだ｡ 

04:21.220 --> 04:21.940
そして､ 私はこれをやった｡ 

04:21.940 --> 04:26.980
だから､ 私自身はエンターテインメントとしての価値だけでこれを持っている｡ 

04:27.160 --> 04:28.330
そして素晴らしい｡ 

04:28.330 --> 04:29.320
素晴らしいよ｡ 

04:29.440 --> 04:41.590
そして､ シミュレートされた環境で株式の売買を決定するコードを書くコード・ジェネレーターを書くことを試すべきだ｡

04:41.590 --> 04:43.420
もっと大きなプロジェクトなんだ｡ 

04:43.420 --> 04:47.050
でも､ コードを生成させるだけで､ 少しずつステップを踏んでいくことができる｡ 

04:47.050 --> 04:49.810
必ずしもシミュレートされた環境が必要なわけではない｡ 

04:49.900 --> 04:52.090
APIを提供するわけだ｡ 

04:52.120 --> 04:58.120
株価を調べるために利用できる一般的なAPIを探すこともできる｡

04:58.120 --> 05:03.430
あるいは､ APIを考案し､ それをプロンプトで提供するだけで､ モデルが特定の日付のティッカーの価格を取得するためにどのメソッドを呼び出すことができるかを知り､

05:03.430 --> 05:14.530
売買の決定を行う関数を生成できるようにすることもできる｡

05:14.530 --> 05:17.710
そうそう､ これはすごく楽しかった｡ 

05:17.710 --> 05:26.380
フロンティア・モデルとオープンソース・モデルの両方を使って､ たくさんの異なる売買シグナルを構築することができた｡

05:26.380 --> 05:31.960
ひとつ言っておきたいのは､ 何をするにしても､ もしこれをやったとしても､ 実際に売買の意思決定に使わないでほしいということだ｡

05:31.960 --> 05:36.970
私は､ この種のモデルを使って取引を決定しないことを強く勧める｡ 

05:36.970 --> 05:41.770
実際､ フロンティアモデルにこのような手法を生成するように頼もうとすれば､ そうしてくれるだろうが､

05:41.770 --> 05:47.440
どんなことがあっても実際の取引判断に使うべきではないと警告されるだろう｡

05:47.440 --> 05:49.720
だから､ これは厳重注意だ｡ 

05:49.930 --> 05:59.050
クローズドソースであろうとオープンソースであろうと､ LMの気まぐれで名声と富を実際に危険にさらすためではなく､

05:59.080 --> 06:05.950
純粋に自分自身の楽しみのため､ そして関係する能力を確認するために使ってください｡

06:06.250 --> 06:08.530
しかし､ これは素晴らしいプロジェクトだ｡ 

06:08.530 --> 06:09.820
きっと楽しめると思うよ｡ 

06:09.820 --> 06:16.150
もし誰もやらなかったら､ 僕のコードを共有するかもしれない｡ でも､ まず第一に､ 僕は君に挑戦状を出したんだ｡

06:16.180 --> 06:19.420
もしあなたが売買シグナルを出したのなら､ 私はあなたに挑戦する｡ 

06:19.420 --> 06:25.930
もちろん､ シミュレートされた環境においてのみですが､ 私たちが生成したさまざまな取引機能のうち､

06:25.930 --> 06:32.980
どちらが偽の市場でより多くのお金を稼ぐことができるのか､ あなたと対決してみます｡

06:33.070 --> 06:34.030
そうだ｡ 

06:34.030 --> 06:38.500
それはあなたにとって本当に楽しいプロジェクトになるはずだし､ みんながどんなものを考え出すのか見るのが待ちきれないよ｡ 

06:38.530 --> 06:41.050
それで､ あなたはそれを信じるだろうか？

06:41.080 --> 06:42.490
信じられるか？

06:42.520 --> 06:51.680
私たちは､ 熟練したLMエンジニアになるための旅の50％地点に到達したところです｡ 

06:51.710 --> 06:53.510
もう半分まで来ている｡ 

06:53.540 --> 06:57.230
少なくとも､ いくつかの宿題をこなし､ いくつかのプロジェクトを作り上げた後では､ その道半ばだ｡ 

06:57.230 --> 07:01.100
というのも､ 私が言うように､ 学ぶための最善の方法は実践することだからだ｡ 

07:01.130 --> 07:08.120
それができたら､ 自分を褒めて､ 50％は達成できたと言える｡

07:08.480 --> 07:19.040
そして次回は､ ラグ・スーパーホットトピックについて､ そしてラグの背後にある大きなアイデアについてお話しする予定です｡

07:19.040 --> 07:35.900
そして､ Ragのおもちゃバージョン､ つまりRagの背後にある大きな考え方であるベクトル・データベースと呼ばれるものを導入しないシンプルなバージョンを実装します｡

07:35.900 --> 07:38.480
だから､ そのすべてにたどり着くのが待ちきれない｡ 

07:38.480 --> 07:41.300
来週は本当に､ 本当にエキサイティングになりそうだ｡ 

07:41.390 --> 07:50.990
そしてもう一度､ LLMSマスターへの道のりの半ばにいることを心から祝福したい｡
