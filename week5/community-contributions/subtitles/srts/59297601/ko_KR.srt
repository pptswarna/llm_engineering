WEBVTT

00:01.130 --> 00:05.450
솔직히 지금 저한테 짜증 낼 이유가 충분하죠

00:05.480 --> 00:10.340
우린 라가 얘기를 한참 했는데 아직 라가를 써 본 적이 없네요

00:10.340 --> 00:11.840
벡터에 대해 얘기했죠

00:11.840 --> 00:16.520
프롬프트와 컨텍스트 래그의 저렴한 버전에 관해 얘기했죠

00:16.910 --> 00:18.890
드디어 본격적인 시작이죠

00:18.920 --> 00:22.100
오늘은 Put 파이프라인을 실행할 거예요

00:22.100 --> 00:23.330
바보 같은 짓이죠

00:23.330 --> 00:23.750
진정해요

00:23.750 --> 00:25.250
두고 봐요

00:25.280 --> 00:27.440
오늘은 어떻게 될까요?

00:27.440 --> 00:32.480
긴 사슬로 된 대화 사슬을 만들 거예요 긴 사슬이 모여서

00:32.480 --> 00:38.720
여러 조각을 접착제로 붙이는 거죠 걸레 회수와 대화를 할 수 있게요

00:38.750 --> 00:44.840
전문가의 이해를 보여주는 질문을 하고 답을 얻을 겁니다 채팅 UI로 궁극적으로

00:44.870 --> 00:48.410
지식 작업자 비서를 만들고요

00:48.410 --> 00:51.560
이미 훌륭한 것들을 배웠기 때문에 아주

00:51.560 --> 00:53.870
쉽다는 걸 알게 될 거예요

00:54.050 --> 01:00.080
먼저 간략히 말씀드리자면 긴 연결의 추상화가 있어요 긴 연결의

01:00.080 --> 01:03.920
개념이 일을 쉽게 만들어주죠

01:03.920 --> 01:07.490
이건 오늘 사용할 3가지예요

01:07.520 --> 01:10.250
우선 LLM에는 추상적인 게 있어요

01:10.250 --> 01:13.730
LLM은 오픈아이를 의미해요

01:13.760 --> 01:15.350
다른 사람을 상징할 수도 있죠

01:15.350 --> 01:20.690
량청은 모델을 둘러싼 추상적인 객체를 대표해요

01:20.870 --> 01:23.750
레트리버라는 추상화도 있어요

01:23.750 --> 01:28.130
벡터 스토어 같은 인터페이스 같은 거죠

01:28.130 --> 01:32.420
우리 경우엔 크로머예요 걸레 회수용으로 사용되죠

01:32.420 --> 01:38.090
벡터를 가지고 프롬프트를 강화할 수 있는 레트리버 인터페이스죠

01:38.150 --> 01:41.090
세 번째 추상화는 메모리예요

01:41.090 --> 01:48.470
챗봇과 토론한 역사를 보여주는 거죠 어떤 식으로든 메모리요

01:48.470 --> 01:55.040
실제로 여기서 사용되는 건 독감 목록이에요 상단의 시스템 메시지 같은 걸

01:55.070 --> 01:59.090
구성한 목록이죠 다음은 사용자 보조예요

01:59.360 --> 02:05.990
하지만 긴 연결을 위한 메모리라는 개념으로 추출되었어요. 이 커버 아래에서 리스트를

02:05.990 --> 02:11.390
처리하거나 다른 모델이 필요로 하는 다른 형식을 처리하죠.

02:11.390 --> 02:19.090
이 세 가지가 핵심 래퍼입니다. Get-Tuck Season 2 닙턱 시즌 2 긴 체인에서 얻는 기능성 중에서요.

02:19.090 --> 02:26.020
이것을 명심하고 얼마나 간단한지 보세요. Get 파이프라인을 만드는 것이요.

02:26.080 --> 02:29.650
4줄의 코드로 완료될 거예요

02:29.650 --> 02:33.070
지금 여러분 앞에 있는 코드 4줄이에요

02:33.310 --> 02:37.720
첫 번째 줄의 우수함이 이거예요

02:37.900 --> 02:42.280
LM은 채팅방개 인공지능으로 랑 체인 ln 객체를 생성하죠

02:42.370 --> 02:46.120
개방형 인공지능을 위한 LM 객체죠

02:46.450 --> 02:50.890
다른 어떤 것을 위해 만들 수 있는 비슷한 오브젝트가 있다고 상상할 수 있죠

02:51.670 --> 02:53.860
그게 첫 번째 줄이자 첫 번째 추상화예요

02:53.890 --> 02:55.480
두 번째 줄에 LM을 넣어요

02:55.480 --> 02:56.470
두 번째 추상화요

02:56.470 --> 02:57.130
메모리 말이에요

02:57.160 --> 03:01.210
대화 버퍼 메모리라는 랑 체인 객체를 생성해요

03:01.630 --> 03:03.580
몇 가지 사항을 제공해야 해요

03:03.580 --> 03:10.660
핵심은 어떻게 정리되느냐죠 메모리와 채팅 기록을 검색하는 데 뭘 쓸 수 있느냐예요

03:10.660 --> 03:16.210
나중에 예상되는 게 그거니까요 반송 메시지는 랭에게 이걸

03:16.210 --> 03:21.040
저장할 거라고 말해요 일련의 메시지로 저장될 거라고요

03:21.040 --> 03:26.020
대화를 나타내는 큰 텍스트 블록 말고요

03:26.020 --> 03:30.910
이런 종류의 채팅 응용 프로그램에 이걸 사용해야 한다는 것만 아시면 돼요

03:31.810 --> 03:40.720
다음 줄은 간단히 벡터 스토어가 있는데 크로마를 생성했고 이것을 불러오기

03:40.720 --> 03:44.290
메서드로 부르겠다고 하네요

03:44.290 --> 03:48.100
레트리버라는 인터페이스 객체로 감싸게 되죠

03:48.100 --> 03:56.710
그게 랭 체인이 기대하는 객체예요 래그 워크플로우가 가능하려면요

03:56.980 --> 04:01.570
세 가지 추상화입니다 LM, 메모리 그리고 리트리버죠

04:01.600 --> 04:02.680
전부 만들어진 거예요

04:02.680 --> 04:07.600
마지막 구절은 그걸 하나로 모아 대화 사슬을 형성해요

04:07.900 --> 04:14.470
그건 여러분이 만든 대화 회수 사슬로 호출을, 그 음 LM으로부터의

04:14.500 --> 04:20.170
메서드를 호출해 생성합니다 여러분은 3가지만 넘기면 돼요

04:20.170 --> 04:25.030
LM, 레트리버, 메모리 방금 만든 3가지요

04:25.030 --> 04:26.920
그렇게 간단한 거예요

04:26.920 --> 04:32.620
코드 네 번째 줄로 방금 래그 파이프라인을 만들었어요

04:33.490 --> 04:34.450
못 믿겠어요?

04:34.450 --> 04:37.150
유피터랩으로 가서 직접 해 보죠
