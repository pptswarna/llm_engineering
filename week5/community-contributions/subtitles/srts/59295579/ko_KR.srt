WEBVTT

00:00.470 --> 00:01.040
좋아요

00:01.040 --> 00:02.750
어떻게 될지 기대돼요?

00:02.780 --> 00:04.130
한번 해 보죠

00:04.160 --> 00:12.890
다음 섹션에서 파이 문자열을 생성합니다 그 코드 안에는 시리즈 1에서 3번째를 더하고 5번째를 더하고

00:12.890 --> 00:15.890
7번째에 9번째를 더하죠

00:15.890 --> 00:17.420
직접 보세요

00:17.450 --> 00:18.770
몇 개 틀렸는지 봐요

00:18.770 --> 00:23.690
그런 다음 100만 번 반복하죠

00:24.170 --> 00:28.640
2억 번은 들었을 거예요 전부 다 보이거든요

00:28.670 --> 00:31.130
그 시리즈에서 두 가지 요소를 하는 거죠

00:31.130 --> 00:33.710
이런 시리즈가 2억 개예요

00:33.710 --> 00:38.300
파이에 얼마나 가까운지 보고 결과를 프린트할 거예요

00:38.570 --> 00:40.700
그렇게 하죠

00:40.820 --> 00:46.970
이제 악성 코드를 하겠습니다 물론 할 수 있죠 우리가 뭘 하는지 정확히 아니까요

00:46.970 --> 00:51.140
하지만 누가 엑스라고 하면 약간 의심해야 해요

00:51.170 --> 00:56.690
ExAC은 파이썬 코드를 문자열에 명시된 대로 실행하는 명령어죠

00:56.720 --> 01:02.820
이제 이 문자열이 악에게 아무 짓도 안 하는 걸 볼 수 있죠

01:02.820 --> 01:04.350
이 시리즈를 하면서요

01:04.350 --> 01:09.060
하지만 임원이 관련된 코드를 줄 땐 항상 다시 확인해야 합니다 파일

01:09.060 --> 01:13.530
시스템에 문제가 있거나 인터넷 연결 같은 게 되지 않도록요

01:13.530 --> 01:17.820
하지만 이 경우에는 꽤 안전하니 한번 해 보죠

01:17.850 --> 01:18.600
정확한 파이예요

01:18.630 --> 01:20.040
어떻게 되나 보죠

01:21.270 --> 01:23.400
잠시 멈췄어요

01:23.430 --> 01:27.570
파이썬은 그중 2억 달러를 생각해요

01:27.570 --> 01:28.500
다 됐어요

01:28.500 --> 01:31.080
파이가 어떻게 나오는지 보죠

01:31.080 --> 01:33.090
3번요 14159265년요

01:33.090 --> 01:34.650
그 숫자가 틀렸어요

01:34.890 --> 01:39.960
Get in get 약관 2억 개로는 얼마 못 벌어요

01:39.960 --> 01:40.320
파이요

01:40.350 --> 01:45.570
아시겠지만, 빠르게 모이는 더 좋은 나열도 있어요 하지만 그것들은

01:45.570 --> 01:48.000
훨씬 더 코드가 많고 검프하죠

01:48.030 --> 01:51.840
쓰기는 쉽지만 점차 집약되는 것의 장점이죠

01:51.840 --> 01:57.870
8시간 걸렸어요 5764초 걸렸어요

01:58.120 --> 02:01.870
이걸 몇 번 실행하면 꽤 많이 변하는 걸 볼 수 있어요 컴퓨터에서 다른 일들이

02:01.870 --> 02:03.100
벌어지고 있으니까요

02:03.100 --> 02:06.760
Get it의 기계는 제 것과 다르지만 대략적인 건 아시겠죠

02:06.790 --> 02:07.390
네

02:07.420 --> 02:13.480
GPT 파이 최적화를 실행할 수 있어야 합니다 그러면 C++ 코드를

02:13.480 --> 02:18.460
내보내는데 GPT4에 문자열을 보내 같은 일을 하죠

02:18.490 --> 02:20.320
Get up, Get up, Get up! 뭐가 나올지 보죠

02:20.740 --> 02:22.690
제가 말씀드린 게 이거예요

02:22.690 --> 02:28.030
이걸 파일 상단에 놓습니다 디스크에 저장하기 전에 제거하죠

02:28.060 --> 02:29.800
이게 방법이에요

02:29.920 --> 02:38.020
여러분이 C 플러스 구루일 수도 아닐 수도 있지만 어쨌든 비슷한 지식을 바탕으로 보면 이 앱도 같은

02:38.020 --> 02:42.370
일을 한다는 사실을 잘 이해하실 수 있을 거예요.

02:42.520 --> 02:48.460
비슷한 수의 계산을 하고 비슷한 수의 용어를 하고 여기에 파일을 작성했어요

02:48.460 --> 02:50.740
최적화된 C 플러스 플러스

02:50.740 --> 02:52.390
저기 있네요

02:52.390 --> 02:54.040
다 좋아 보이죠

02:54.040 --> 03:01.370
포함되어야 하는 이 패키지도 포함되어 있습니다. 왜냐하면 이것은 정밀 함수를 사용하니까요.

03:01.370 --> 03:05.570
이걸 발견하면 사용자 프롬프트에 넣지 않으면 패키지를 포함하지 않아요 파열을

03:05.570 --> 03:06.650
유발하는 패키지죠

03:06.650 --> 03:07.910
자, 됐어요

03:08.030 --> 03:10.790
어찌 됐든 우리가 힌트를 줬고 그게 해냈어요

03:11.330 --> 03:12.710
네

03:12.710 --> 03:14.090
다음 방을 보세요

03:14.090 --> 03:15.110
다음 감방이에요

03:15.110 --> 03:23.330
기억하시겠지만 Jupyter에서 느낌표를 하면 그건 그걸 터미널 명령으로

03:23.330 --> 03:25.010
실행할 거예요

03:25.010 --> 03:27.800
여기서 하는 건 터미널 명령이에요

03:27.800 --> 03:29.570
클랭++요

03:29.570 --> 03:35.030
이 문장은 최적화되어 실행되고 있어요

03:35.030 --> 03:39.740
컴파일을 하고 C++ 코드를 실행하고 있어요

03:39.980 --> 03:44.000
나중에는 더 최적화된 방법을 사용할 거예요

03:44.000 --> 03:47.750
하지만 이건 지금 컴퓨터에는 좋아요

03:47.750 --> 03:51.350
컴파일에 뭐가 필요한지 구글에 검색해 보세요

03:51.470 --> 03:57.690
맥을 사용한다면 적어도 Xcode를 열어서 최신 Xcode 도구들이 설치되었는지

03:57.690 --> 04:02.070
확인해야 합니다 최신 버전의 컴파일러가 있도록요

04:02.190 --> 04:06.630
어쨌든 구글에 검색하면 C 플러스 파일을 어떻게 컴파일하는지 알 수 있어요

04:06.690 --> 04:12.360
이 라인을 최적화된 C++ 파일 최적화된 CPP의 컴파일로 바꾸고 나면 당연히

04:12.390 --> 04:14.370
그렇게 실행하게 되죠

04:14.370 --> 04:21.450
8점을 넘어서야 한다는 걸 기억하세요 57초요

04:21.450 --> 04:26.520
GPT 40 코드가 어떻게 작동하는지 보죠

04:26.520 --> 04:27.540
시작할게요

04:29.280 --> 04:37.410
대답은 같아요 적어도 658개 안쪽으로요

04:37.440 --> 04:37.920
네

04:37.920 --> 04:38.550
그런 것 같아요

04:38.550 --> 04:39.990
예상했던 대로예요

04:40.020 --> 04:42.300
아뇨, 반반되는 것도 없어요

04:42.300 --> 04:44.310
딱 맞는 것 같아요

04:44.310 --> 04:47.520
시간의 0분의 1밖에 안 돼요 21살요

04:47.610 --> 04:55.180
그러니까 확실히 10배에서 100배 정도 빨라요

04:55.330 --> 04:58.810
나중에 최적화하면 더 좋아질 거예요

04:58.810 --> 04:59.020
하지만요

04:59.020 --> 05:01.360
하지만 이 깃발로 그걸 얻게 되죠 get it get it

05:01.390 --> 05:02.980
정말 인상적이에요

05:03.010 --> 05:10.990
파이썬 에서 C++로 코드를 변환할 수 있는 것을 빌드했습니다 그리고 훨씬 빠르게

05:10.990 --> 05:12.550
실행할 수 있죠

05:12.580 --> 05:14.890
클로드는 어떤지 보죠

05:18.340 --> 05:21.220
코드를 빨리 비교해보죠

05:22.960 --> 05:25.840
코드가 비슷해 보여요

05:26.020 --> 05:29.260
자세히 보시면 미묘한 차이가 있어요

05:29.260 --> 05:35.470
예를 들어 여기 이런 게 있어요

05:35.470 --> 05:42.310
전 C 플러스 전문가가 아닙니다 1, 2년 전에 C 플러스 코딩은 해봤지만요

05:42.460 --> 05:45.640
하지만 안타깝게도 제 머릿속에선 다 바뀌었어요

05:45.670 --> 05:48.610
이 정도 전문 지식은 절대 못 얻었을 거예요

05:48.610 --> 05:54.590
병렬화될 수 있다는 걸 암시하는 다양한 힌트를 넣고 있는 것 같아요 하지만 이런

05:54.620 --> 06:00.320
것과 관련해 제 생각엔 컴파일러가 두 경우 모두 적용할 것 같아요 두고 보죠

06:00.350 --> 06:07.820
이게 실제로 차이를 만드는지 보죠 같은 명령을 실행하면서요

06:10.490 --> 06:11.780
죄송해요, 제가 그랬나요?

06:11.780 --> 06:12.620
다시 해 보죠

06:12.650 --> 06:13.520
시작할게요

06:14.810 --> 06:17.630
이게 그 답이에요

06:17.810 --> 06:27.770
아무래도 다시 돌아가서 작업해야 할 것 같아요

06:27.770 --> 06:28.100
안 돼요

06:28.100 --> 06:28.430
시작할게요

06:28.460 --> 06:29.030
시작할게요

06:29.030 --> 06:29.930
미안해요

06:29.930 --> 06:35.360
이건 Gpg 버전이었어요 GPT는 0이었죠 2121요

06:35.540 --> 06:38.510
여기서 앞서갔죠

06:38.510 --> 06:39.470
그래서 헷갈리는 거예요

06:39.470 --> 06:40.040
미안해요

06:40.040 --> 06:41.720
다시 올라가죠

06:42.260 --> 06:55.410
0번 적어 둘게요 2131은 GPT 버전이고 클로드 버전은 0이에요 2121요

06:55.410 --> 06:58.500
클로드는 GPT보다 약간 빨랐어요

06:58.530 --> 07:02.340
하지만 이건 에러바 안에 있어요

07:02.340 --> 07:05.640
몇 번 실행하면 그 정도까지 차이가 나요

07:05.640 --> 07:12.990
기본적으로 둘 다 코드를 만들었어요 컴퓨터에서 실행될 때 같은 속도로 실행되는 코드요

07:12.990 --> 07:19.140
실제 컴파일된 머신 코드는 두 경우 모두 동일할 것 같아요

07:19.290 --> 07:23.040
아주 간단한 문제니까 당연한 결과죠

07:23.190 --> 07:32.040
GPT4와 클로드는 파이를 생성하기 위한 파이썬 코드의 최적화된 솔루션으로

07:32.040 --> 07:33.540
잘 해냈죠

07:33.870 --> 07:39.810
하지만 GPT 4는 클로드보다 힌트가 더 필요했지만 둘 다 휴식 시간이

07:39.810 --> 07:42.120
끝나고 도착했어요

07:42.120 --> 07:48.300
더 어려운 문제로 넘어가겠습니다 훨씬 어려운 코드요 어떻게 최적화할 수 있는지 보기 위해서요

07:48.300 --> 07:50.220
그럼 다음 영상에서 만나요
