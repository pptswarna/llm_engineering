WEBVTT

00:00.860 --> 00:05.330
そしてここでもう一度､ 私たちはお気に入りの場所､ Jupyter Labにいることに気づく｡ 

00:05.330 --> 00:07.310
数週間で準備完了｡ 

00:07.340 --> 00:09.620
2週目の練習

00:09.620 --> 00:14.930
2週目のフォルダーに入り､ 2週目の初日を迎える｡ 

00:15.230 --> 00:18.230
ええと､ それで......｡ 

00:18.230 --> 00:26.990
第1週目では､ チャット・ユーザー・インターフェースを通して複数のfrontier LMSを使い､ ウェブを通して使う方法､

00:26.990 --> 00:32.990
そしてAPIを通してOpenAIのAPIに接続したことを思い出してください｡

00:33.020 --> 00:41.090
そこで今日は､ AnthropicとGoogleのAPIをミックスに加え､ OpenAIを使用する私たちのスキルに加わります｡

00:41.960 --> 00:47.630
ええと､ だから､ もうひとつ念を押しておくけど､ この話を続けていると殺されちゃうよ｡ 

00:47.630 --> 00:50.300
ここでキーをセットする｡ 

00:50.300 --> 00:58.460
OpenAIのキーを設定することができます｡ おそらく先週すでに設定したと思いますが､ anthropicとGoogleのGeminiのキーを設定することができます｡

00:58.490 --> 01:05.330
でも､ グーグル・キーの設定にはもっと冒険が必要なんだ｡

01:05.390 --> 01:09.410
一度セットアップしたら､ あとは作るだけだ｡ 

01:09.470 --> 01:11.330
というファイルはすでに作成されているはずだ｡ 

01:11.480 --> 01:15.170
鍵がその形であることを確認する｡ 

01:15.560 --> 01:21.500
その代わりに､ これらのセルにキーを入力することもできる｡ 

01:21.500 --> 01:24.020
そうすることは可能だ｡ 

01:24.020 --> 01:26.270
セキュリティ上の理由から推奨されていない｡ 

01:26.270 --> 01:30.350
いつかこれを公開し､ 他の人があなたの鍵を見ることになったときのために｡ 

01:30.380 --> 01:32.300
さて､ 前置きはここまで｡ 

01:32.330 --> 01:33.800
インポートをしよう｡ 

01:33.800 --> 01:37.400
環境変数を設定するコードのブロックを実行してみよう｡ 

01:37.400 --> 01:38.900
あなたはよくご存じでしょう｡ 

01:38.900 --> 01:49.400
そして今､ このセルで､ OpenAIに同じ呼び出しをして､ OpenAI APIへの接続を確立しているのがわかるだろう｡

01:49.400 --> 01:56.840
でも､ クロードには似たようなものがあるし､ 双子座のグーグルにはちょっと違うものがある｡

01:56.960 --> 02:04.220
つまり､ この3つのコマンドは､ ある意味類似しているんだ｡ 

02:04.730 --> 02:05.510
オーケー｡ 

02:05.510 --> 02:13.160
LLMSが得意なことをたくさん見てきたし､ つまずいたこともいくつかあったが､ ほとんどはLLMSが得意なことだった｡

02:13.190 --> 02:17.600
その中で､ あまり得意でないことのひとつがジョークを言うことだ｡ 

02:17.600 --> 02:24.080
非常にタイトな文脈を与えることで､ その中でジョークを作ろうとする｡ 

02:24.260 --> 02:30.980
これは明らかに商業的な例ではないけれど､ APIを楽しみながら体験する方法なんだ｡

02:31.040 --> 02:34.850
ええと､ API上で何人かのLLMにジョークを言ってもらう予定です｡ 

02:35.120 --> 02:36.770
ええと､ それでどんな情報を？

02:36.770 --> 02:37.550
API経由で送信する｡ 

02:37.580 --> 02:41.750
通常､ 使用したいモデルの名前を常に指定する｡ 

02:41.750 --> 02:45.380
通常､ システムメッセージとユーザーメッセージを伝える｡ 

02:45.380 --> 02:48.950
全体的な背景を伝えるシステムメッセージは､ もうお馴染みですね｡ 

02:48.950 --> 02:52.340
ユーザーメッセージは実際のプロンプトである｡ 

02:52.550 --> 02:54.410
他にもいくつか特徴がある｡ 

02:54.410 --> 02:55.700
他にもできることはある｡ 

02:55.730 --> 03:00.890
温度と呼ばれるものを0から1の間で渡すことができ､ 通常､ 1はよりランダムで創造的な出力が欲しいことを意味し､

03:00.890 --> 03:09.960
0は可能な限り低く集中した､ 決定論的な反復可能な設定となる｡

03:10.320 --> 03:14.250
だから､ これもよく提供できるパラメーターのひとつだ｡ 

03:14.280 --> 03:20.010
そこで今回は､ 「あなたはジョークを言うのが得意なアシスタントです」というシステムメッセージを設定する｡

03:20.010 --> 03:26.670
そして､ ユーザー・プロンプトは､ データ・サイエンティストの聴衆に向けて軽いジョークを言う｡ 

03:26.670 --> 03:30.000
それはあなたであり､ 私でもある｡ 

03:30.660 --> 03:35.850
オーケー､ ではこの構成は､ あなたにとって非常に馴染みのあるものであることを願っている｡ 

03:35.850 --> 03:44.910
ここでは､ プロンプトをリストに入れて､ システムとユーザーを要素とし､ これら2つの要素に役割を設定します｡

03:44.940 --> 03:49.860
このリストに入るにあたって､ 説明するまでもないだろう｡ 

03:50.040 --> 03:55.080
ええと､ 私が言ったように､ この､ この､ ええと､ ここの値､ ロールはシステムでもユーザーでもいい｡ 

03:55.080 --> 03:56.070
後で分かることだ｡ 

03:56.070 --> 03:57.570
アシスタントになることもある｡ 

03:57.570 --> 03:59.760
だから､ システム・ユーザーでもアシスタントでもいい｡ 

03:59.760 --> 04:04.150
そして今週の後半には､ そこに入れられる他のものも見つけることになる｡ 

04:04.240 --> 04:04.990
だから

04:05.020 --> 04:09.790
しかし今は､ これから使う2つのロールとして､ systemとuserを覚えておけばいい｡ 

04:09.790 --> 04:12.610
だから､ それをプロンプトのリストに入れた｡ 

04:13.480 --> 04:16.570
そして､ その前のセルを実行することも忘れてはならない｡ 

04:16.570 --> 04:18.790
その前に､ ここでセルを実行したか？

04:18.790 --> 04:20.350
はい､ 大丈夫です｡ 

04:20.350 --> 04:20.770
さあ､ 始めよう｡ 

04:20.800 --> 04:21.790
もう一度やってみよう｡ 

04:21.790 --> 04:22.840
そのセルを実行する｡ 

04:22.840 --> 04:23.860
このセルを実行する｡ 

04:23.890 --> 04:25.720
とてもいい｡ 

04:25.750 --> 04:34.390
古いGPTモデルの一つGPT 3から始めよう｡  5ターボは､ ごく最近､ 最新で最高のフロンティアモデルのようだった｡

04:34.390 --> 04:35.830
しかし､ それはすでに古いニュースだ｡ 

04:35.830 --> 04:37.330
しかし､ 我々はこれを使う｡ 

04:37.330 --> 04:44.680
OpenAIのAPIは､ OpenAI dot chat, dot completions, dot

04:44.680 --> 04:53.500
create completionsで､ このAPIの名前は､ 基本的に既存のプロンプトのセットを受け取り､

04:53.500 --> 04:59.530
会話を完成させるためにテキストを生成しようとするものです｡

04:59.800 --> 05:07.980
そしてcreateを呼び出すと､ モデルを渡し､ おなじみのフォーマットでメッセージを渡します｡

05:08.010 --> 05:09.750
では､ 見てみよう｡ 

05:09.780 --> 05:18.030
そして､ 回答が返ってきたときに私たちがすることは､ 可能な選択肢のリストである完了点の選択肢を取ることだ｡

05:18.030 --> 05:19.980
しかし､ そこに含まれる要素は1つだけだ｡ 

05:19.980 --> 05:23.790
複数の選択肢を返すように指定する方法がある｡ 

05:23.790 --> 05:28.740
でも､ それをやっていないので､ ただ1つ戻ってくるだけで､ もちろんゼロ地点にある｡ 

05:28.740 --> 05:35.550
つまり､ completion dot choices zero dot messageはメッセージを返し､ contentはそれを文字列で返す｡ 

05:35.760 --> 05:37.770
だから､ それを印刷するんだ｡ 

05:37.770 --> 05:39.360
さて､ どんなジョークか見てみよう｡ 

05:39.360 --> 05:42.690
データサイエンティスト向け GPT 3. 5ターボが思いつく｡ 

05:42.720 --> 05:43.680
さあ､ 始めよう｡ 

05:44.010 --> 05:48.000
データサイエンティストはなぜコンピューターと別れたのか？

05:48.000 --> 05:52.020
二人の複雑な関係を処理しきれなかったのだ｡ 

05:52.830 --> 05:53.970
オーケー､ オーケー｡ 

05:54.000 --> 05:56.250
分かるよ､ 分かるんだ｡ 

05:56.280 --> 05:58.770
世界一面白いジョークではないが､ ひどくはない｡ 

05:58.800 --> 06:04.200
データサイエンティストは物事の関係をモデル化するが､ その複雑な関係を扱うことができなかったんだ｡

06:04.200 --> 06:04.800
十分フェアだ｡ 

06:04.800 --> 06:13.140
GPT3からすれば､ まったく問題ない､ 受け入れられるジョークだと思う｡  5ターボ｡ 

06:13.200 --> 06:17.010
では､ GPT four miniがもっとうまくやれるかどうか見てみよう｡ 

06:17.160 --> 06:21.450
今回は､ APIの使い方を少し拡張するだけだ｡ 

06:21.600 --> 06:26.340
温度を含めているので､ ここで0から1の間の数値を渡すことができる｡ 

06:26.340 --> 06:29.220
最もクリエイティブなものに1点､ 最もクリエイティブでないものに0点｡ 

06:29.490 --> 06:34.980
ええと､ それで､ この中で私は完成度の高い選択肢を持っていて､ メッセージの内容はゼロなんだ｡ 

06:34.980 --> 06:36.720
繰り返しになるが､ あなたはこのことをよく知っているはずだ｡ 

06:36.750 --> 06:38.970
そのパフォーマンスを見てみよう｡ 

06:39.570 --> 06:42.060
データサイエンティストはなぜ統計学者と別れたのか？

06:42.060 --> 06:44.670
彼女は彼があまりに意地悪だと感じたからだ｡ 

06:44.700 --> 06:46.230
なかなかいいジョークだと思うよ｡ 

06:46.230 --> 06:47.490
それでいいと思うよ｡ 

06:47.490 --> 06:49.950
それは......ああ､ これはジョークとして受け入れられるね｡ 

06:49.980 --> 06:54.990
llmsはあまり得意ではない､ と言ったのは厳しかったかもしれない｡ それは至極まっとうなジョークだからだ｡

06:55.170 --> 07:02.610
そして､ GPT4にはちょっとした拍手を送りたい｡ 

07:03.030 --> 07:09.160
じゃあ､ GPT4ミニを試してみよう｡ 

07:09.190 --> 07:12.130
GPT4のマキシバージョンだ｡ 

07:12.160 --> 07:14.260
ああ､ 大物だ｡ 

07:14.260 --> 07:16.000
そして私たちはそれを問う｡ 

07:16.030 --> 07:19.210
温度を同じにしよう｡ 

07:19.240 --> 07:21.160
冗談で聞いてみよう｡ 

07:21.190 --> 07:23.230
2人で､ どうなるか見てみよう｡ 

07:24.250 --> 07:27.130
データサイエンティストはなぜ破産したのか？

07:27.130 --> 07:30.850
なぜなら､ 彼らのアレーにはキャッシュが見つからなかったからだ｡ 

07:32.410 --> 07:35.560
もし､ それが彼らの配列になかったら､ 私はその方がいいと思ったかもしれない｡ 

07:35.560 --> 07:38.650
キャッシュは見つからなかった｡ 

07:38.650 --> 07:39.910
大丈夫だろう｡ 

07:40.810 --> 07:42.280
何か見落としているのかもしれない｡ 

07:42.310 --> 07:45.280
よく分からないんだ｡ 

07:45.550 --> 07:47.380
ええと､ もうひとつやってみよう｡ 

07:47.560 --> 07:52.480
前にやったように､ 温度を少し下げてみよう｡ 

07:52.990 --> 07:56.560
科学者たちはなぜロジスティック回帰モデルと決別したのか？

07:56.590 --> 07:58.390
適切な相手が見つからなかったからだ｡ 

07:58.600 --> 08:00.130
あ､ あのね､ それは至極まっとうなことだよ｡ 

08:00.130 --> 08:00.970
それは受け入れられる｡ 

08:00.970 --> 08:08.860
ミニとマキシのどっちが好きかわからないけど､ これはこれで､ なかなかしっかりしたギャグだよ｡

08:08.860 --> 08:12.640
それは間違いなくパスだ｡ 

08:13.810 --> 08:14.800
分かった｡ 

08:14.830 --> 08:17.050
第3節に移ろう｡  5.

08:17.080 --> 08:17.680
ソネット

08:17.950 --> 08:21.430
APIは驚くほど似ている｡ 

08:21.430 --> 08:22.270
それは良いニュースだ｡ 

08:22.270 --> 08:25.030
基本的にはとてもよく似ている｡ 

08:25.060 --> 08:26.530
いくつかの違いがある｡ 

08:26.530 --> 08:31.510
システム・メッセージは別の属性として渡さなければならない｡ 

08:31.510 --> 08:36.430
そしてメッセージはまたこのデッキリストだ｡ 

08:36.430 --> 08:42.550
しかしもちろん､ システムメッセージの最初のエントリーは持っていない｡

08:42.910 --> 08:45.310
うーん､ それは少し違うかな｡ 

08:45.340 --> 08:52.360
また､ Max tokensは､ OpenAI APIでトークンの最大数を指定するためのオプションです｡

08:52.360 --> 08:55.180
クロードには必要なことだと思う｡ 

08:55.180 --> 08:56.860
だからここにあるんだ｡ 

08:56.860 --> 08:59.200
しかし､ それ以外はすべてよく似ているはずだ｡ 

08:59.230 --> 09:03.250
API自体は少し覚えやすい｡ 

09:03.250 --> 09:05.740
クロード・ドット・メッセージ・ドット・クリエイトだ｡ 

09:05.740 --> 09:11.470
少し短いですが､ それ以外はOpenAIのChatGPTの完了が作成するものとよく似ています｡ 

09:11.710 --> 09:13.150
あ､ そうだ｡ 

09:13.180 --> 09:17.830
そして返答が返ってきたときには､ メッセージの内容はゼロになっている｡ 

09:17.860 --> 09:22.630
繰り返しますが､ 最初の1つを要求していますが､ 1つしか返ってきません｡ なぜなら､

09:22.630 --> 09:28.750
OpenAIのドット・コンテンツに相当するドット・テキストを1つしか要求していないからです｡

09:28.780 --> 09:30.100
では､ 見てみよう｡ 

09:30.100 --> 09:35.020
これは､ クロードのAPIフレームワークのために役立つことを期待している｡ 

09:35.020 --> 09:38.080
さて､ クロードがジョークでどうするか見てみよう｡ 

09:39.910 --> 09:40.630
もちろんだ｡ 

09:40.660 --> 09:43.540
データサイエンティスト向けの軽いジョークを紹介しよう｡ 

09:43.570 --> 09:46.210
データサイエンティストはなぜ恋人と別れるのか？

09:46.240 --> 09:51.310
ただ､ その関係にあまりにばらつきがありすぎて､ それを正常化するいい方法が見つからなかった｡

09:51.970 --> 09:53.530
ああ､ そうだね｡ 

09:53.530 --> 09:59.110
よりオタク的というか......もう少し､ うーん､ データサイエンス的というか｡ 

09:59.110 --> 10:03.640
ほんの少し笑えなくなったかもしれないが､ 決して悪くはない｡ 

10:03.640 --> 10:07.570
GPT4よりGPT4が好きかどうかは､ 好みの問題だろう｡ 

10:07.900 --> 10:10.100
完璧なジョークだ｡ 

10:10.220 --> 10:14.210
爆発的に面白いというわけではないが､ 完璧にしっかりしていると言える｡ 

10:14.210 --> 10:15.440
ひどくはない｡ 

10:15.950 --> 10:16.550
うーん｡ 

10:16.610 --> 10:22.220
いずれにせよ､ これはAPIについての話であり､ ジョークの話である｡ 

10:22.250 --> 10:24.800
これからお見せしたいのは､ ストリーミングについてです｡ 

10:24.890 --> 10:29.090
ストリーミングの例の前に､ ストリーミングについて簡単に話したのを覚えているかい？

10:29.090 --> 10:36.470
マークダウンを復活させ､ そのマークダウンを処理しなければならなかったからだ｡

10:36.470 --> 10:40.280
これは､ マークダウン・レスポンスを扱っていないので､ 少し単純に見える｡ 

10:40.280 --> 10:46.730
同じモデル､ クラウド3にお願いするつもりだ｡  冗談でまた5点､ でも今回は結果をストリーミングで返します｡

10:46.730 --> 10:54.470
OpenAIにストリーミングを依頼したとき､ 別の属性stream equals trueを追加したことを覚えているだろうか｡

10:54.470 --> 10:56.570
そしてそれは､ ストリーミング・モードであることを意味していた｡ 

10:56.570 --> 10:58.490
クロードの場合は少し違う｡ 

10:58.490 --> 11:00.380
余計な属性はない｡ 

11:00.380 --> 11:06.440
その代わり､ dot createメソッドの代わりにdot streamメソッドを呼び出す｡ 

11:06.440 --> 11:09.020
そこで少し異なるアプローチを取る｡ 

11:09.020 --> 11:13.790
それは､ ストリーミングのための人間工学とOpenAIのニュアンスの違いだ｡ 

11:13.790 --> 11:16.430
そこで､ クロード・メッセージ・ストリームと呼ぶことにする｡ 

11:16.460 --> 11:17.840
それ以外は同じだ｡ 

11:17.840 --> 11:22.430
そして､ 戻ってきたものについては､ ストリームとしての結果を持つコンテキスト・マネージャーを使用する｡ 

11:22.610 --> 11:26.960
それから､ ストリーム・テキスト・ストリームのテキスト用だね｡ 

11:26.960 --> 11:31.550
オープンAIは､ それに応えるチャンクのためのものだったことを覚えているだろう｡ 

11:31.550 --> 11:35.990
だからOpenAIは､ 結果を読み返す方法がまた少し違っていた｡ 

11:35.990 --> 11:37.040
でも､ それがある｡ 

11:37.040 --> 11:41.420
それぞれの小さな塊を取り戻し､ その塊を印刷する｡ 

11:41.540 --> 11:46.460
その理由は､ 各チャンクを別々の行に印刷しないようにするためです｡ 

11:46.670 --> 11:48.170
そうでなければ､ とても読みにくい｡ 

11:48.170 --> 11:49.490
だから､ この方がよく見えるはずだ｡ 

11:49.490 --> 11:56.510
クロード3世はどうだったかな｡  5ソネットは､ JupyterLabで私たちにストリームバックされるジョークで行う｡ 

11:57.200 --> 11:57.800
これでよし｡ 

11:57.800 --> 11:58.040
分かるか？

11:58.040 --> 11:59.060
ストリーミングだよ｡ 

11:59.330 --> 12:01.580
もちろん､ データサイエンティスト向けの軽いジョークだ｡ 

12:01.610 --> 12:03.110
なぜ同じジョークを？

12:03.110 --> 12:08.690
まったく同じジョークのようだが､ ブラームスの小太鼓が加えられている｡ 

12:08.840 --> 12:12.000
最後に爆発があったのは良かった｡ 

12:12.000 --> 12:14.670
なぜ以前より多くのメダルを要求したのだろう？

12:14.700 --> 12:15.180
見てみよう｡ 

12:15.210 --> 12:15.630
そうだ｡ 

12:15.630 --> 12:16.350
同じだ｡ 

12:16.650 --> 12:17.730
ええと､ それは

12:17.760 --> 12:19.020
そして､ ちょっとした説明もある｡ 

12:19.020 --> 12:22.170
このジョークは､ データサイエンスに共通する統計的概念を利用したものだ｡ 

12:22.260 --> 12:27.060
少しマニアックだが､ データに精通した観客の笑いを誘うはずだ｡ 

12:27.060 --> 12:32.070
まあ､ 君たちはデータに精通しているから､ それを判断するのは君たちだ｡ 

12:32.100 --> 12:34.440
笑ってもらえましたか？

12:35.220 --> 12:36.540
前進だ｡ 

12:36.570 --> 12:39.120
双子座は構造が違う｡ 

12:39.120 --> 12:41.370
実際にはかなり違うんだ｡ 

12:41.400 --> 12:50.580
グーグルの名誉のために言っておくと､ トークンを設定する機能はもっと複雑だが､ APIはもう少しシンプルだ｡

12:50.670 --> 12:59.550
ここではジェネレーティブ・モデル・オブジェクトを作成し､ モデルの名前を渡す｡

12:59.550 --> 12:59.550
5フラッシュ

12:59.580 --> 13:03.510
ジェミニ1のコンテキストウィンドウの大きさを覚えているだろうか｡  5フラッシュ

13:03.540 --> 13:04.680
覚えていますか？

13:04.710 --> 13:07.050
以前はトップだった？

13:07.050 --> 13:10.380
100万トークンという驚異的な数字だった｡ 

13:10.410 --> 13:11.450
100万トークン｡ 

13:11.480 --> 13:13.310
75万語｡ 

13:13.340 --> 13:15.500
というわけで､ 双子座1号｡  5フラッシュ

13:15.950 --> 13:23.270
このオブジェクトを作成するときにシステム命令を渡し､ ジェミニ・ドットを呼び出す｡ 

13:23.270 --> 13:26.420
ユーザープロンプトでコンテンツを生成する｡ 

13:26.420 --> 13:28.520
しかも､ ただのレスポンス・ドット・テキストだ｡ 

13:28.520 --> 13:37.520
リクエストもレスポンスも､ もう少しシンプルなAPIにしてみよう｡

13:37.670 --> 13:42.200
重要なのは､ なぜデータサイエンティストは統計学者と別れたのか､ ということだ｡ 

13:42.200 --> 13:45.590
p値で意見が一致しなかったからだ｡ 

13:47.420 --> 13:48.020
ああ｡ 

13:48.800 --> 13:52.310
まあ､ データ・サイエンスの側面はわかるよ｡ 

13:52.310 --> 13:53.810
よく分からないんだ｡ 

13:53.900 --> 13:55.070
ハハハ｡ 

13:55.370 --> 13:57.380
ああ､ たぶん君はわかっているんだろうね｡ 

13:57.380 --> 13:59.540
それに､ 僕は､ うとうとしているんだ｡ 

13:59.540 --> 14:01.310
ああ､ その場合はぜひ指摘してほしい｡ 

14:01.310 --> 14:05.450
でも､ そのジョークの面白さは特に分からない｡ 

14:05.450 --> 14:13.440
だから私としては､ ジェミニはジェミニ1より遅れていると思う｡  ユーモアの価値という点では5フラッシュ｡

14:14.220 --> 14:15.060
分かった｡ 

14:15.090 --> 14:18.960
ともあれ､ ちょっと真面目にGPT4に戻ろう｡ 

14:19.170 --> 14:20.910
最初の質問と同じだ｡ 

14:20.910 --> 14:22.410
君は役に立つアシスタントだ｡ 

14:22.440 --> 14:25.950
ビジネス上の問題がLLMのソリューションに適しているかどうかは､ どのように判断すればよいのでしょうか？

14:25.950 --> 14:29.790
覚えているだろうか､ それが私たちがチャット・インターフェースを通じてした最初の質問だった｡ 

14:29.970 --> 14:32.970
そして今､ 私たちはこれを再び一つにすることができる｡ 

14:32.970 --> 14:34.260
これは､ あなたにとって馴染み深いものだろう｡ 

14:34.290 --> 14:37.320
結果をマークダウンでストリームバックする｡ 

14:37.320 --> 14:40.770
つまり､ OpenAI chat dot completions dot createだ｡ 

14:40.770 --> 14:41.880
我々はモデルにパスを出す｡ 

14:41.880 --> 14:43.350
大物を狙うんだ｡ 

14:43.530 --> 14:44.820
プロンプトを使うんだ｡ 

14:44.820 --> 14:45.840
温度を設定した｡ 

14:45.840 --> 14:47.250
私たちはストリーム＝トゥルーと言う｡ 

14:47.250 --> 14:49.680
それがOpenAIのやり方だ｡ 

14:49.830 --> 14:54.750
ええと､ それからこれは､ 結果を再びストリームバックする方法です｡ 

14:54.750 --> 14:57.720
マークダウンを扱っているので､ もう少し複雑だ｡ 

14:57.720 --> 15:04.950
そのため､ 基本的に反復ごとにマークダウンを更新するために､ ここではある種の特別なことをしなければならない｡

15:04.980 --> 15:08.850
もし､ 私たちがこのようにしなければならないと確信が持てないのであれば､ それを取り除いて違うやり方をしてみれば､

15:08.850 --> 15:11.190
何が起こるかすぐにわかるだろう｡

15:11.220 --> 15:13.200
見栄えは良くない｡ 

15:13.440 --> 15:15.720
それを実行しよう

15:15.720 --> 15:21.810
そして､ その結果がここにある｡ 

15:22.500 --> 15:28.260
マークダウンが部分的にしか通過していないときに､ フリックが起こっているのがわかるだろう｡ 

15:28.260 --> 15:33.600
そのため､ 小見出しを表すハッシュが複数ある場合などを解釈している｡ 

15:33.600 --> 15:37.050
まだ1回しかハッシュを受け取っていないし､ 大きなヘディングが来ると思っている｡ 

15:37.110 --> 15:42.660
少なくとも､ マークダウンが表示されるときにチカチカと点滅していたのは､ 一時的に見たことだと思う｡

15:42.660 --> 15:55.020
しかし､ その最後には､ もちろん､ とてもきれいに構成された回答が返ってくる｡

15:55.740 --> 15:56.460
分かった｡ 

15:56.460 --> 16:04.140
これで､ さまざまなAPIについて理解していただけたと思う｡

16:04.170 --> 16:13.200
そして､ 次のビデオでは､ 実際に2､ 3人のLLMがお互いに会話をする予定だ｡

16:13.200 --> 16:14.340
それではまた｡ 
