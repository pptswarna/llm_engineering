WEBVTT

00:00.440 --> 00:05.900
유피터랩에 잘 오셨습니다 긴 사슬 세계에서의 첫 실험에 잘 오셨어요

00:05.900 --> 00:11.840
다시 한번 말하지만 저처럼 주피터 노트들을 훑어보는 게 중요해요

00:11.840 --> 00:16.490
이상적으로는 제가 여러분과 얘기하는 동시에 주피터 랩을 띄워

00:16.490 --> 00:23.870
5주 차로 바꾸고 오늘과 오늘, 그리고 오늘 2주 차로 해서 저처럼 이걸 하나씩 할 수 있어요

00:23.900 --> 00:29.360
그게 불가능하다면 그 직후에 최대한 빨리 이걸 시도해 보세요

00:29.390 --> 00:33.860
직접 경험해보는 게 아주 중요합니다 특히 텍스트 덩크나

00:33.860 --> 00:36.830
벡터 같은 개념에 대해 얘기할 때요

00:36.860 --> 00:41.480
제 말의 유효성을 검사하고 실험해보고 직접 보시는 게 아주 중요합니다

00:41.480 --> 00:46.790
코드를 시험해보고 다양한 걸 프린트하세요 막후에서 작동하는 방식에 아주

00:46.790 --> 00:49.010
익숙해지기 위해서요

00:49.010 --> 00:54.080
5주 차 폴더에 들어온 게 2일째예요 지금 보시는 건 전날의

00:54.080 --> 00:58.280
비트 복사본이지만 앞으로 더 나올 거예요

00:58.760 --> 01:01.950
수입품도 있는데 새로운 것도 있네요

01:01.950 --> 01:07.020
랭 체인에서 코드를 불러오는 건 처음이죠 문서 로더라는 걸 불러오겠습니다

01:07.020 --> 01:11.820
파일을 불러오는 걸 도와주는 유틸리티 클래스죠

01:11.850 --> 01:17.460
디렉토리 로더라는 게 있는데 전체 폴더에 로드하는 거죠 개별 텍스트 파일을

01:17.460 --> 01:19.320
로드하는 텍스트 로더요

01:19.440 --> 01:24.720
문자 텍스트 분할기라는 것도 불러오고 있어요

01:24.720 --> 01:31.890
문서를 받아들여서 글자 덩어리로 나누는 거죠

01:31.920 --> 01:34.170
수입 검사 결과나 보죠

01:34.530 --> 01:39.060
제가 몇 가지 상수를 설정했는데 오늘은 사용하지 않겠지만 다음에 쓸 거예요

01:39.390 --> 01:42.870
Get it, get it, get it, it! 자, 그럼 본론으로 들어가죠

01:42.870 --> 01:51.360
지난번에 했던 유치한 거 기억나요? 문서를 읽어 사전에 넣는 거요 Put

01:51.360 --> 01:52.770
열쇠는 문서의 이름이었어요

01:52.770 --> 01:54.870
그 서류의 내용이 가치 있는 거죠

01:54.870 --> 01:57.360
이번에는 좀 더 현명한 비트를 만들 거예요

01:57.360 --> 01:59.370
랑 체인을 쓰면 도움이 돼요

01:59.370 --> 02:03.670
먼저, 지식 기반의 다양한 폴더들의 리스트를 get으로 하고요.

02:03.700 --> 02:08.680
이 폴더들은 회사 계약직 직원들과 제품들이라는 걸 기억하실 거예요

02:08.680 --> 02:10.990
그래서 그걸 폴더에 넣었어요 Put

02:11.500 --> 02:21.100
이제 각각의 폴더에 대해 먼저 문서 유형을 갖게 됩니다 회사 계약 직원 또는 제품이요

02:21.370 --> 02:31.300
그런 다음 이 디렉터리를 로드합니다 디렉터리 로더를 사용해서요 그에 대한 핸들, 디렉터리

02:31.300 --> 02:35.050
경로를 넘기는 곳이죠

02:35.050 --> 02:40.210
텍스트 로더 로더 클래스라는 것도 제출합니다 각각의 파일을 가져오는

02:40.210 --> 02:45.220
데 사용하라고 말해주죠 텍스트 파일이니까요 그렇게 간단해요

02:45.220 --> 02:49.420
그런 다음 loader.load를 호출합니다 그럼 모든 문서를 갖고 오죠

02:49.510 --> 02:52.600
각각의 문서를 반복하는 거죠

02:52.630 --> 02:56.920
각 문서의 메타데이터를 설정할 수 있는지 묻죠

02:57.460 --> 03:03.390
doc 타입이라는 것을 추가하고 Doctype로 설정해야 합니다 회사 계약이든 직원이나

03:03.390 --> 03:04.740
제품이든 간에요

03:04.740 --> 03:08.550
그런 다음 문서라는 목록에 추가하세요

03:09.030 --> 03:10.680
이해하셨길 바라요

03:10.920 --> 03:16.590
실행해 보겠습니다. 그 결과로 이제 문서의 31개 객체가 생겼습니다.

03:16.590 --> 03:21.240
그중 하나가 어떻게 생겼는지 보여드릴게요.

03:22.740 --> 03:23.940
여기 있네요

03:23.970 --> 03:27.150
지식 기반 디렉터리에 있어요

03:27.300 --> 03:30.210
메타데이터에는 소스라는 게 있어서 위치를 알려줘요

03:30.240 --> 03:33.360
그리고 이건 우리가 제품에 추가한 Doctype이에요

03:33.930 --> 03:34.860
그러니까 제품이죠

03:34.860 --> 03:39.990
Ermmd라고 하는데 파일의 전체 콘텐츠죠

03:40.020 --> 03:46.020
제품에 관해 생각해 보면 렐름이라는 게 있어요 md요

03:46.710 --> 03:52.260
그걸 더블 클릭하면 아마도 로드된 것과 같은 것이겠죠

03:52.290 --> 03:56.010
첫 번째 문서도 볼 수 있어요

03:56.130 --> 03:58.410
제품에도 적용되죠

03:58.410 --> 04:00.370
마크의 침착함이죠

04:00.730 --> 04:03.580
왜 그런 건지 아시겠죠?

04:03.580 --> 04:06.730
무작위로 24번을 뽑죠

04:07.360 --> 04:13.870
24번째 서류는 맥신 톰프슨의 직원 인사 기록이에요

04:13.870 --> 04:15.580
맥신도 있네요

04:15.580 --> 04:19.000
문서 같은 직원이고 내용물도 있어요

04:19.000 --> 04:22.570
복잡할 게 없죠

04:22.720 --> 04:29.890
문서를 넣고 문서 유형을 줬는데 그중 31명이 서류에 앉아 있어요

04:30.250 --> 04:37.180
다음으로 할 일은 텍스트 분할기입니다 문서를 가져다가 각

04:37.180 --> 04:41.080
문서를 문자 덩어리로 나누죠

04:41.080 --> 04:44.320
이걸 할 때 랑 체인에 두 가지를 지정하세요

04:44.350 --> 04:50.860
하나는 덩어리 크기입니다 한 덩어리당 대략 몇 글자를 넣어야 하는가 하는 거죠

04:51.220 --> 04:56.410
대강이요 랑 체인에 재량권을 줄 거니까요 합리적인

04:56.410 --> 05:03.500
경계를 분할하도록 해야죠 빈 공간과 빈 줄 같은 거요 문서의 다른

05:03.500 --> 05:06.620
부분 사이의 구역도요

05:06.620 --> 05:10.460
단어나 단어 중간에 컷하는 게 아니에요

05:10.460 --> 05:11.780
말이 안 되죠

05:11.930 --> 05:17.870
그러면 잠재적으로 달 착륙선에 제공할 접촉이 좋지 않을 수 있죠

05:18.740 --> 05:26.990
덩어리 중첩은 캐릭터들이 서로 완전히 분리되지 않게 하는

05:26.990 --> 05:28.160
거예요

05:28.160 --> 05:30.710
어느 정도 겹치게 하고 싶어요

05:30.710 --> 05:35.240
두 덩크 사이에 공통으로 있는 문서의 내용이 있어요

05:35.390 --> 05:42.290
다시 말하지만, 쿼리를 입력하면 그 쿼리와 관련된 많은 부분을 뽑아낼 가능성이

05:42.290 --> 05:44.090
더 크죠.

05:44.120 --> 05:49.550
어떤 연관성이나 비판적인 단어 때문에 위험을 감수하고 싶진 않아요

05:49.550 --> 05:55.340
한 덩어리에만 포함돼요 우리가 포함하지 않는 다른 덩어리는 그것과 아주 가깝죠

05:55.340 --> 05:56.630
그것도 중요해요

05:56.630 --> 06:02.790
청크가 겹치면 잠재적으로 같은 키워드를 포함하는 여러 개의

06:02.790 --> 06:04.380
청크가 생기죠

06:05.220 --> 06:07.980
이게 텍스트 분할기예요

06:07.980 --> 06:11.100
분할 문서라고 하고 문서를 제출하죠

06:11.100 --> 06:14.730
이걸 실행하면 실행될 거예요

06:14.730 --> 06:23.100
그리고 그 물질이 만든 덩어리 하나가 1088이라는 걸 경고해줘요 우리가 요구한 것보다

06:23.100 --> 06:24.150
더 크죠

06:24.150 --> 06:28.710
경계를 존중하는 방법을 영리하게 쓰려고 노력했기 때문이죠

06:28.740 --> 06:32.730
그래서 이렇게 하기로 결정했어요

06:32.730 --> 06:40.680
덩어리가 몇 개인지 보면 123개가 나왔어요 31개의 문서에서 덩어리가 123개

06:40.680 --> 06:42.270
나왔죠

06:42.270 --> 06:47.190
이제 할 수 있는 건 덩어리를 고르는 거예요 5번 덩어리를 골라요 그 덩어리를

06:47.220 --> 06:48.240
보죠

06:48.450 --> 06:53.070
청크 자체에 메타데이터가 있어요 문서 메타데이터처럼요

06:53.340 --> 06:55.890
어디서 왔는지 알아요

06:56.100 --> 06:59.520
우리가 설정한 문서 타입이 있어요

06:59.650 --> 06:59.830
위로요

06:59.830 --> 07:04.240
이 덩어리가 그 제품에서 분리된 거예요

07:04.480 --> 07:09.490
마컴에 관한 제품 요약본이에요

07:09.490 --> 07:15.400
새 섹션에서 시작해서 그 섹션의 끝에서 끝나는 걸 보실 수 있어요

07:15.580 --> 07:18.100
그래서 경계를 존중하는 데 신중해졌죠

07:18.100 --> 07:21.460
대략 천 개의 글자가 들어있죠

07:21.610 --> 07:25.630
바로 전 덩어리랑 겹치는 부분이 있을 거예요

07:25.960 --> 07:28.090
그러기로 했는지 보죠

07:29.470 --> 07:32.530
이 경우엔 앞에 있던 게 아주 작아요

07:32.710 --> 07:39.820
어쨌든, 여러분이 찾아보실 수 있어요 가능한

07:39.820 --> 07:46.510
옵션들을요 청크 사이에 겹치는 거요

07:46.660 --> 07:51.910
그래서 빨리 이 덩어리를 실험해 보고 싶어요

07:51.910 --> 07:57.100
두 덩크에 같은 정보가 들어 있는 예시를 Get get 해 보세요

07:58.330 --> 08:05.570
이제 이 청크를 통해 Doctype 메타데이터를 검사해 올바른 문서 형식이

08:05.570 --> 08:09.260
다 있다고 자신을 설득할 거예요

08:09.260 --> 08:13.490
그럼 모든 덩어리에 뭐가 있는지 보죠

08:13.490 --> 08:18.230
doc 타입의 직원, 계약서 회사, 제품은 네 가지죠

08:18.230 --> 08:24.830
좋은 거죠, 우리가 읽은 4개의 디렉터리와 정확히 일치하니까요

08:24.830 --> 08:26.900
다 괜찮은 것 같네요

08:27.440 --> 08:33.740
그럼 이제 제가 한번 살펴볼게요 이 덩어리들을 하나씩 살펴보면

08:33.740 --> 08:35.150
어떨까요?

08:35.150 --> 08:38.540
랭커스터라는 단어가 들어간 덩어리는요?

08:38.570 --> 08:39.590
랭커스터요

08:39.620 --> 08:46.070
아시는지 모르겠지만 그건 가상의 이름이에요 가상의 회사의 가상의 CEO죠

08:46.070 --> 08:49.250
성이 랭커스터군요

08:49.250 --> 08:52.580
어떤 덩어리에서 그녀의 성이 나오는지 보죠

08:52.580 --> 08:53.600
자, 시작하죠

08:53.840 --> 09:03.100
보험 서류에 이름이 있어요 물론 그 회사의 창립자니까요

09:03.490 --> 09:10.210
인사 기록에도 랭커스터가 있는데 우리 인사 기록 맨 아래예요

09:10.210 --> 09:16.660
성까지 언급된 인사부 기록도 있고요

09:17.110 --> 09:24.070
아마 아시겠지만 지난번에 했던 싸구려 명품 버전에서는 랭커스터라는

09:24.070 --> 09:28.930
단어만 보이는 게 큰 문제였어요

09:28.930 --> 09:35.380
최악의 랭커스터에 비치지 않는 CEO에 관한 정보가 있다면 지난 버전의

09:35.380 --> 09:39.100
장난감에 그게 빠져 있을 거예요

09:39.100 --> 09:45.340
보다시피 에이버리의 이름을 검색하면 정보가 훨씬 많이 나와요 get

09:45.340 --> 09:49.360
it's name으로만 언급돼 있거든요

09:49.630 --> 09:51.760
그래서... 네

09:51.790 --> 09:58.120
또한 CEO라고 적힌 부분도 많이 발견할 수 있을

09:58.240 --> 10:06.140
겁니다 랭커스터라는 단어만 본다면 그 부분을 놓치게 될 수도

10:06.140 --> 10:07.460
있죠

10:07.520 --> 10:13.850
문서를 통해 텍스트 기반의 검색을 하는 게 좋은 방법이 아니라는 느낌을 줍니다 우리가

10:13.850 --> 10:18.410
찾아야 할 컨텍스트의 중요한 부분을 놓칠 수도 있고요

10:18.440 --> 10:25.250
벡터 검색에서 찾는 건 좀 더 영리하게 텍스트뿐

10:25.250 --> 10:32.690
아니라 의미에 숨은 단어도 찾는 거죠

10:32.720 --> 10:35.870
그게 바로 래그의 아이디어예요

10:35.900 --> 10:43.280
이 시점에선 여러분이 문서 읽기에 능숙하길 바랍니다 텍스트 로더와 디렉터리 로더를

10:43.280 --> 10:45.710
이용해 덩어리로 나누죠

10:45.710 --> 10:50.780
이 운동을 하면 다른 덩어리들을 가지고 놀면서 합리적인 부분에서 분리되었고

10:50.780 --> 10:54.440
겹치는 부분도 있다고 스스로 확신하게 되죠

10:54.440 --> 10:59.240
그런 다음 벡터화하고 벡터 데이터베이스에 넣을 준비가 되죠 Let's go
