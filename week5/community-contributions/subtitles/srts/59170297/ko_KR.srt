WEBVTT

00:00.710 --> 00:06.830
구글 콜랩에 왔습니다 모델들과 즐길 준비가 됐죠

00:07.100 --> 00:13.640
먼저 Pip 설치와 수입 작업을 할 거예요

00:13.940 --> 00:18.710
이건 좀 더 오래 걸릴 거예요 이걸 녹음하기 전에 이미 비트를 써서

00:18.710 --> 00:21.440
실행했거든요 좀 더 빠르게요

00:21.530 --> 00:26.240
피프를 설치하는 데 30-1분이 걸릴 거예요

00:26.270 --> 00:29.450
피프 설치가 끝나면 얼굴 포옹으로 로그인해요

00:29.450 --> 00:30.800
이제 익숙해진 것 같네요

00:30.830 --> 00:35.330
왼쪽에 비밀이 담긴 토큰이 있으면 좋겠네요

00:35.570 --> 00:41.780
이제 상수를 설정하겠습니다 포옹 페이스 허브에서 함께 플레이할 모델들의 이름에

00:41.810 --> 00:42.950
대해서요

00:42.950 --> 00:48.350
늘 그렇듯 모델명 또는 모델 회수 회사명이죠

00:48.620 --> 00:52.370
3번과 피 2번과 라마와 놀 거예요

00:52.370 --> 01:00.290
연습 문제를 낼 테니 콴토와 함께 반복하세요 알리바바 클라우드의 위대한 LLM이죠

01:00.290 --> 01:03.190
미스트랄도 여기 있어요

01:03.220 --> 01:08.800
이건 너무 큰 모델이 될 수도 있어요 큰 GPU에 돈을 쏟아붓지

01:08.800 --> 01:11.020
않는다면요

01:11.110 --> 01:19.450
그럴 경우 H깅페이스 허브에 가서 80억 매개 변수가 넘는 모델을 찾아서

01:19.450 --> 01:23.110
그걸 대신 사용하세요

01:23.110 --> 01:29.410
마음에 드는 걸 고르거나 아니면 지금 인기가 있거나 잘 팔리는 걸 골라서 어떻게 해석할지

01:29.410 --> 01:30.100
보세요

01:30.100 --> 01:34.840
하지만 적어도 5개는 완성해야 해요

01:34.930 --> 01:42.220
이제 상수를 설정하고 메시지 목록을 만들게요 이 시점에서 우리가 잘 아는 형식으로요

01:42.220 --> 01:48.700
시스템 메시지와 사용자 메시지죠 목록의 2개 독점으로요

01:48.730 --> 01:51.640
더 설명할 필요 없어요

01:51.910 --> 02:02.540
지난번에 라마 3에 동의해야 했던 거 기억하죠? 한 가지 서비스 조건은 모델 페이지에서

02:02.690 --> 02:07.610
동의를 얻는 거예요

02:07.610 --> 02:15.380
아직 안 하셨다면 llama 3에 액세스할 수 있도록 하세요 모델은 하나예요

02:16.370 --> 02:18.740
이런 건 처음 봐요

02:18.740 --> 02:23.180
제가 언급했던 퀀타이즈라는 것에 대해 잠깐 얘기할게요 비트

02:23.180 --> 02:27.350
퀀타이즈는 놀라운 개념이에요

02:27.440 --> 02:35.480
이 모델의 경우 메모리에 로드하고 싶은데 그렇게 할 때

02:35.480 --> 02:42.500
모델을 구성하는 무게의 정밀도를 줄이는 거죠

02:42.500 --> 02:46.130
이 무게추들은 보통 32비트 플로트예요

02:46.250 --> 02:51.650
32 비트 부양점 숫자는 이 심층 신경망의 무게예요

02:51.650 --> 02:55.490
덜 채워서 가져오면 어떨까요?

02:55.760 --> 02:59.320
32비트는 4바이트로 계산할 수 있고요

02:59.590 --> 03:08.350
그리고 숫자를 더 적어 넣는 게 좋을 것 같아요 less 메모리에요

03:08.650 --> 03:15.490
정밀도를 줄이는 이 과정을 퀀타이즈라고 합니다 모델에 거친 숫자가 더 많이

03:15.490 --> 03:17.080
보이게 하는 거죠

03:17.080 --> 03:19.930
그게 우리가 할 일이죠

03:19.930 --> 03:24.670
이 이야기를 처음 들었을 때 정말 놀랐던 기억이 납니다 처음에는

03:24.700 --> 03:32.530
32 비트 숫자를 8 비트 숫자로 대체하면 정확도가 훨씬 떨어진다고들 했거든요

03:32.530 --> 03:39.460
그 비트는 놀랍게도 정확도는 조금 떨어지지만 생각만큼 떨어지진

03:39.460 --> 03:41.320
않아요

03:41.320 --> 03:44.680
줄어들지도 않고 4배로 악화되지도 않아요

03:44.860 --> 03:51.550
좀 더 나빠지지만 견딜 만해요 메모리가 더 많다면 비트를 걸 만하죠

03:51.670 --> 03:56.800
그 말을 듣고 놀랐지만 그보다 더 많은 걸 할 수 있다는 걸 알고 더 놀랐어요

03:56.800 --> 04:01.760
8비트가 아니라 4비트로 졸일 수 있어요

04:01.760 --> 04:03.950
0.5 바이트예요 세어본다면요

04:04.220 --> 04:09.560
32비트 숫자를 4비트로 줄일 수 있어요

04:09.800 --> 04:17.600
다시 말하지만 정확도는 손상됐지만 기대만큼 크진 않아요

04:17.630 --> 04:21.500
완전히 다를 줄은 몰랐어요

04:21.500 --> 04:23.990
견딜 만해요

04:23.990 --> 04:29.870
훨씬 더 큰 모델이 메모리에 맞아 더 빨리 로드되고 더 빨리 달리게 해주죠

04:29.870 --> 04:33.710
사람들이 많이 하는 거죠

04:33.710 --> 04:39.560
강력한 도구예요 특히 훈련을 받거나 이런 모델로 많은 작업을 해야 할 때는요 get

04:39.560 --> 04:41.060
it get it

04:41.060 --> 04:43.190
퀀타이즈는 구세주예요

04:43.220 --> 04:48.590
기억하실지 모르겠지만 몇 주 후에 큐 로라라는 기술을 배울

04:48.590 --> 04:53.150
거예요 효율적으로 미세 조정하는 방법이죠

04:53.150 --> 04:57.760
Q의 로라, Q의 로라는 퀀타이즈를 뜻하죠

04:57.760 --> 05:01.720
그래서 이따금 다시 보게 될 거예요

05:02.350 --> 05:09.340
그동안 비트 앤 바이트라는 라이브러리를 사용합니다 포옹하는 트랜스포머 라이브러리와 밀접한

05:09.340 --> 05:10.480
관련이 있죠

05:10.510 --> 05:18.670
훌륭한 라이브러리예요 새 bits와 바이트 구성 객체를 만들 수 있죠 우리가 원하는

05:18.760 --> 05:22.720
수량화가 뭔지 곧 설명드릴게요

05:22.720 --> 05:27.490
로드 인 for 비트 = true라고 하죠

05:27.520 --> 05:29.020
50센트까지 쭉 내릴 거예요

05:29.020 --> 05:31.810
로드 인 8 비트 = true도 할 수 있어요

05:31.810 --> 05:36.370
대신 8bit를 하고 싶다면 둘 다 해서 차이를 확인할

05:36.370 --> 05:37.660
수 있죠

05:38.320 --> 05:41.260
이것도 정말 놀랍죠

05:41.260 --> 05:46.510
근데 4비트 퀀트 = True도 할 수 있어요

05:46.510 --> 05:51.760
한 번도 아니고 두 번씩 모든 무게를 수량화한다는 뜻이죠

05:51.790 --> 05:54.190
메모리를 좀 더 저장하려고요 비트

05:54.190 --> 06:02.210
이걸 다시 한다고 해서 결과의 정확성에 큰 영향을 주진 않아요

06:02.210 --> 06:05.300
좋은 거래고 사람들이 그렇게 해요

06:05.870 --> 06:13.340
이 데이터 형식 A와 B 16을 이용해 계산을 한다는 뜻입니다

06:13.520 --> 06:17.270
그러면 성능이 향상되죠

06:17.270 --> 06:19.280
이것도 꽤 흔한 일이에요

06:19.400 --> 06:27.290
여기서 중요한 건 숫자를 4비트로 줄였을 때 4비트 숫자를 어떻게

06:27.320 --> 06:32.510
처리하고 압축하는지에 관한 거죠

06:32.510 --> 06:37.490
이 NF4는 4비트로 숫자를 나타내요

06:37.490 --> 06:39.860
평범화됐다는 뜻이죠

06:39.860 --> 06:45.230
이런 숫자들을 고려하는 것과 관련 있다는 걸 압니다 일반적인

06:45.230 --> 06:51.200
분포를 따르려면 4비트로 압축할 때 더 정확할 수 있죠

06:51.230 --> 06:56.090
이 둘은 less로 보여요

06:56.110 --> 06:58.690
큰 변화를 기대하진 않아요

06:58.720 --> 06:59.170
둘은 운명이에요

06:59.200 --> 06:59.680
운명인 거죠

06:59.680 --> 07:01.030
설정이 좋네요

07:01.030 --> 07:03.490
이건 좀 달라요

07:03.490 --> 07:06.280
이건 메모리 면에서 큰 차이를 만들어요

07:06.280 --> 07:11.500
결과물 면에서는 나쁘지 않아요

07:11.530 --> 07:19.420
이 모든 대화로 우린 이제 퀀트 구성, 비트 및 바이트 구성을 만들었어요

07:19.480 --> 07:21.370
이건 우리에게 익숙한 거예요

07:21.400 --> 07:24.910
라마에게 토큰을 만들어 주려고요

07:25.450 --> 07:28.090
이 대사는 처음 언급하는 거예요

07:28.090 --> 07:37.240
패드 토큰이라는 것도 있는데요 신경망에 추가할 것이 있을 때 프롬프트를

07:37.240 --> 07:43.090
채우는 데 쓰이는 토큰이죠

07:43.180 --> 07:50.440
일반적인 관행으로 패드 토큰을 문장 끝, 프롬프트 토큰의 마지막과

07:50.470 --> 07:54.220
동일하게 설정하는 것이죠

07:54.370 --> 07:57.830
Get을 안 하면 경고를 받아요

07:57.860 --> 07:59.840
Get you 경고는 중요하지 않아요

07:59.840 --> 08:01.250
효과가 없는 것 같아요

08:01.250 --> 08:04.610
경고를 받고 싶지 않다면 get을 선택하세요.

08:04.640 --> 08:09.170
많은 코드에서 사람들이 표준으로 사용하는 것을 볼 수 있어요.

08:10.310 --> 08:10.970
네

08:10.970 --> 08:13.520
이제 토큰라이저를 사용할 거예요

08:13.520 --> 08:17.390
채팅 템플릿 적용 함수라고 부를게요

08:17.390 --> 08:23.930
그건 우리 메시지를 사전 목록으로 받아들여 토큰으로 변환하는 거죠

08:24.260 --> 08:28.820
그걸 GPU 위에 적용했어요

08:28.850 --> 08:33.080
get을 실행하면 토큰izer가 작동할 거예요

08:33.080 --> 08:37.520
다음으로 할 일은 모델을 로드하는 거예요

08:37.520 --> 08:39.950
이 선은 뭐죠?

08:39.980 --> 08:44.900
우선 이 대사와 아주 유사해요

08:44.900 --> 08:50.540
여기서 토큰라이저를 만들었는데 오토 토큰라이저. FROMpretrep이라고 입력했어요

08:50.570 --> 08:57.200
미리 배운 자동 LLM을 위한 모델을 생성하죠

08:57.290 --> 09:02.420
LLM을 생성하는 일반 클래스죠

09:02.450 --> 09:06.290
인과적 LLM은 자가적 공격 LLM과 같아요

09:06.290 --> 09:13.760
LLM은 과거의 토큰을 가지고 미래의 토큰을 예측하는 것이죠

09:13.760 --> 09:18.170
기본적으로 우리가 얘기한 모든 llm은 그런 종류의 LLM이었죠

09:18.170 --> 09:24.200
과정 후반부에 다른 종류의 LLM을 살펴보겠습니다 때때로 사용되는 거죠

09:24.200 --> 09:30.710
하지만 우리가 말하는 이런 생성적인 인공지능 사용 사례에선 인과적 llms 즉

09:30.710 --> 09:34.130
자동적 위반 llms를 연구할 거예요

09:34.130 --> 09:39.650
미리 훈련된 걸 이용해서 만드는 거죠

09:39.650 --> 09:42.560
토큰이처럼 모델 이름을 전달하는 거죠

09:42.560 --> 09:46.340
GPU가 있다면 그걸 사용하고 싶다고 하죠

09:46.370 --> 09:48.950
그게 Device Map 오토의 역할이죠

09:48.980 --> 09:57.590
그런 다음 퀀트화 구성에서 넘깁니다 방금 설정한 퀀트 구성요 그게 모델을 구축하는 방법이죠

09:57.620 --> 10:07.700
모델은 실제 코드입니다 즉, 소프트웨어로서의 큰 언어 모델로서 파이썬 코드로서 우리가

10:07.700 --> 10:09.440
실행할 것이죠

10:09.440 --> 10:11.720
그 아래는 피토치예요

10:11.750 --> 10:19.220
파이토치 층으로 구성돼 있어요 신경망 층으로 구성되어 있어서 입력값에 입력하면 출력이

10:19.220 --> 10:20.390
나오죠

10:20.390 --> 10:22.580
진짜 물건이네요

10:22.670 --> 10:28.520
이걸 실행하면 시간이 더 걸릴 거예요 방금 실행했으니까요 완전히 새로운

10:28.520 --> 10:32.330
상자처럼 많은 작업을 할 필요가 없었죠

10:32.360 --> 10:38.090
이걸 실행하면 실제로 발생하는 일은 다운로드예요

10:38.090 --> 10:39.650
얼굴을 안는 것과 연결되죠

10:39.680 --> 10:46.190
Hub에서 모델 무게를 다운로드해 Google Colab 인스턴스의

10:46.190 --> 10:54.460
디스크에 로컬로 놓습니다 이 박스의 데스크에 있는 임시 파일 캐시에요 나중에 이 박스와 연결을

10:54.460 --> 11:01.540
끊으면 삭제됩니다 이 모델은 이제 일시적으로 디스크의 박스에 저장됩니다 메모리에

11:01.540 --> 11:07.660
로드되기도 해서 우리가 사용할 수 있게 되죠

11:07.660 --> 11:12.940
모델에게 물어볼 수 있어요 get 메모리풋프린트를 호출해 메모리를 얼마나 사용하는지요

11:12.940 --> 11:15.100
뭐라고 하는지 보죠

11:15.100 --> 11:19.510
이 모델의 메모리 공간은 약 5개라고 나오네요 5기가바요

11:19.840 --> 11:28.030
이 박스에 대한 리소스를 보면 약 5개를 사용하는 걸 보실 수 있어요 상자는 5GB로 하고요

11:28.030 --> 11:31.210
이미 실행하고 있었기 때문에 과거에도 흔들리고 있어요

11:31.450 --> 11:35.740
하지만 자세히 보면 이 아래부터 시작해서 5.5cm까지

11:35.740 --> 11:37.000
올라갈 거예요

11:37.000 --> 11:42.700
디스크에서 많은 공간을 사용하고 있습니다 디스크 캐시에 로드되어 있기 때문이죠

11:43.690 --> 11:44.560
네

11:44.590 --> 11:47.350
황금 시간대 준비가 거의 다 됐어요

11:47.350 --> 11:51.250
먼저 모델 자체를 살펴보죠

11:51.430 --> 11:54.210
모델을 프린트함으로써 그렇게 하죠

11:54.990 --> 12:04.080
모델을 프린트하면 이 모델 객체에 의해 표현되는 실제 심층 신경망에 대한 설명이

12:04.080 --> 12:05.370
나와요

12:05.370 --> 12:06.990
여기 보이는 게 그거예요

12:06.990 --> 12:12.720
딥 신경망 층을 나타내는 코드 층이에요

12:12.720 --> 12:19.140
이건 전부 PyTorch 클래스를 보여줍니다 모델에 의해 참조되는

12:19.140 --> 12:20.730
설정이죠

12:21.210 --> 12:26.460
다시 말씀드리지만 실습 시간이라 가끔 이론만 살짝 다룰 거예요

12:26.460 --> 12:31.320
하지만 깊은 신경망과 그 층의 내장에 대한 지식 수준에 따라 살펴볼

12:31.320 --> 12:32.700
가치가 있어요

12:32.700 --> 12:34.740
익숙한 내용도 있을 거예요

12:34.740 --> 12:40.230
토큰을 심는 레이어에서 시작한다는 게 익숙하실 겁니다 토큰을 신경망에

12:40.230 --> 12:41.820
심는 방법이죠

12:41.820 --> 12:47.280
이걸 상상해 보세요 단어의 입체성을 나타내는

12:47.280 --> 12:49.170
거예요

12:49.620 --> 12:56.680
그리고 모듈이 여러 개 있는 게 보이시죠 신경망의 각 레이어예요

12:56.710 --> 13:04.060
예상했던 대로 주의 깊게 보는 층이 있어요 특히 주의 깊게 보는 게 가장 중요하잖아요

13:04.090 --> 13:08.890
종이에 쓰여 있듯이 주의만 기울이면 돼요 이런 주의 층이 트랜스포머를

13:08.920 --> 13:11.350
트랜스포머로 만드는 핵심이죠

13:11.350 --> 13:17.230
그리고 다중 페르셉트론 층이 여기 있어요

13:17.230 --> 13:19.690
활성화 함수가 있어요

13:19.690 --> 13:24.340
이 이론에 더 익숙한 사람들은 이걸 보길 기대하겠죠

13:24.340 --> 13:32.860
이 llama 3이 사용하는 활성화 함수죠 1번 모델은 리루 활성화 함수로

13:32.860 --> 13:40.570
구형 아니 선형 유닛으로 여기 문서화에 나와 있죠

13:40.750 --> 13:43.900
스위시 함수라고도 알려져 있죠

13:44.080 --> 13:49.300
기본적으로 물적 X의 X 곱하기 X죠

13:49.300 --> 13:52.190
활성화 함수는 이렇게 생겼어요

13:52.220 --> 13:57.020
심층 신경망 이론에 관심이 있다면 이게 뭔지 정확히 알 거예요

13:57.050 --> 13:59.300
아니라면 걱정하지 마세요

13:59.300 --> 14:05.630
여기서 무슨 일이 일어나는지 전반적으로 파악하세요 이 모델이나 나중에 다른 걸 연구할

14:05.630 --> 14:09.200
때 더 자세히 살펴볼 수 있는 거죠 Get it

14:09.890 --> 14:17.690
그 끝에는 표준 층이 있고 그 끝에는 직선

14:17.690 --> 14:20.360
층이 있어요

14:21.170 --> 14:29.300
이건 특별히 살펴볼 가치가 있어요 피터치 신경망에 대한 지식이

14:29.300 --> 14:30.560
있다면요

14:30.770 --> 14:35.060
나중에 다른 모델도 똑같이 할 수 있어요

14:35.060 --> 14:36.680
모델 출력을 보세요

14:36.710 --> 14:42.320
모델을 보고 인쇄해서 어떻게 생겼는지 보고 라마3와 비교해요

14:43.160 --> 14:47.720
다음 비디오에선 쉬도록 하죠 다음 비디오에선 이걸 실행하고 다른 모델도

14:47.720 --> 14:49.040
실행할 거예요

14:49.070 --> 14:50.690
그러니 어디 가지 마세요

14:50.720 --> 14:51.770
이따 봐요
