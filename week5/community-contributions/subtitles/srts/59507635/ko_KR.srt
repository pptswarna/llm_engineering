WEBVTT

00:00.950 --> 00:02.870
기대해도 좋아요

00:02.870 --> 00:04.160
그러는 게 좋을 거예요

00:04.190 --> 00:09.110
코스의 80%를 통과했고 그 모든 게 이 순간을 위해 쌓여온 거죠

00:09.140 --> 00:15.920
오늘 여러분은 자체 개발한 LLM을 훈련할 겁니다 재미와 이윤을 위해서요

00:16.100 --> 00:17.780
여기서 모든 게 시작돼요

00:17.780 --> 00:20.360
오늘날에는 어떤 일이 일어나나요?

00:20.360 --> 00:23.600
별로 스릴이 없을지도 모르는 것부터 시작할게요

00:23.600 --> 00:25.700
hyperperameter에 대해 한 번 더 얘기할게요

00:25.700 --> 00:29.090
여러분과 함께 할 필수 하이퍼파라미터예요

00:29.090 --> 00:34.280
이게 중요한 이유는 hyperpaameter 최적화를 직접 하실 것이기

00:34.280 --> 00:35.060
때문이죠

00:35.060 --> 00:37.490
시행착오를 뜻하는 고급 단어죠

00:37.490 --> 00:41.270
우리가 갖고 노는 것의 맥락을 이해해야 해요

00:41.270 --> 00:46.430
다른 모델을 이길 수 있는 걸 만들 기회예요

00:46.460 --> 00:51.200
어떤 레버를 실험해야 하는지 이해하는 게 중요해요

00:51.230 --> 00:56.630
건축의 주요 모델에 대한 연구개발의 핵심이죠

00:56.630 --> 01:00.260
hyperperameter에 대해 얘기해 보죠

01:00.480 --> 01:05.790
감독하에 소량 조율 트레이너를 설치할 거예요

01:05.820 --> 01:11.040
트레이너는 이 훈련의 핵심 객체예요

01:11.130 --> 01:16.440
TRL 라이브러리에서 얼굴 안기 부분을 살펴보고 시작할게요

01:16.470 --> 01:20.760
우리만의 LM 훈련 과정이죠

01:20.820 --> 01:22.350
멋질 거예요

01:22.920 --> 01:28.800
먼저, 훌륭한 내용을 다루기 전에 이 프로세스를 제어하는 필수 hyperperameter에

01:28.800 --> 01:36.810
대해 얘기하겠습니다 Q 로라부터요 대부분은 이제 아주 익숙해졌죠

01:36.810 --> 01:41.970
첫 번째 hyperpaameter는 대상 모듈을 다시 한 번 언급하는 거예요

01:41.970 --> 01:44.370
이제 이게 뭔지 정확히 기억하실 거예요

01:44.700 --> 01:52.890
변압기 아키텍처가 있다면요 라마 3 같은 기본 모델요 첫째, 이 거대한 건축물을 정교하게 다듬기에는

01:52.890 --> 01:55.320
너무 커요

01:55.320 --> 02:00.850
아키텍처에서 레이어 몇 개를 골라 그걸 레이어라고 부르죠

02:00.850 --> 02:03.400
목표 모듈이 우리가 목표로 삼을 것들이죠

02:03.430 --> 02:04.660
전부 얼려요

02:04.660 --> 02:06.520
무게를 최적화하지 않을 거예요

02:06.520 --> 02:07.630
너무 많아요

02:07.630 --> 02:09.220
이 표적 모듈에서도 말이죠

02:09.220 --> 02:10.660
훈련 안 시킬 거예요

02:10.660 --> 02:16.780
그보다는 한쪽에 차원 매트릭스를 두고 이 차원 매트릭스를

02:16.780 --> 02:22.210
훈련할 겁니다 그걸 이 원래 목표 모듈에 적용하고요

02:22.210 --> 02:28.420
이걸 곱해서 적용할 거예요 여기 무게추를 삼각주로 사용해서요

02:28.510 --> 02:35.020
이 작은 녀석들을 훈련해서 대상 모듈에 적용합니다 더 큰 아키텍처에서

02:35.020 --> 02:38.230
선택한 층이 대상 모듈이죠

02:38.230 --> 02:44.920
그리고 더 큰 3D 고글을 로고로 해서 아이콘으로 삼았어요

02:45.040 --> 02:51.190
R은 이 저차원 어댑터 매트릭스에 차원이 몇 개 있느냐는 거예요

02:51.190 --> 02:56.350
언어 학습을 할 때 8단계로 시작하는 경우가 많아요

02:56.530 --> 03:02.730
이 프로젝트에서 32가 R인 걸 보실 수 있습니다 훈련 데이터가 아주 많거든요

03:02.730 --> 03:07.020
몇 가지 매개 변수를 이용해 배울 수 있을 것 같았죠

03:07.200 --> 03:10.140
하지만 메모리가 부족하다면 8개를 가질 수 있어요

03:10.170 --> 03:16.890
솔직히 8과 16과 32의 차이는 거의 없다고 봐야겠죠

03:16.890 --> 03:19.110
상황이 좋아지긴 했지만 큰 차이는 없었어요

03:19.110 --> 03:22.470
메모리에 문제가 있다면 R에서 8을 유지하세요

03:22.500 --> 03:25.320
작은 상자라도 괜찮을 거예요

03:25.440 --> 03:31.800
32는 좀 비싸지만 훈련 데이터를 생각하면 비트를 쓸 만해요

03:32.550 --> 03:36.570
알파는 배율 요인이죠

03:36.570 --> 03:42.990
대상 모듈에 적용될 때 이 어댑터의 중요성을 곱하기 위해 사용되죠

03:42.990 --> 03:46.680
기억하실지 모르겠지만 로라 행렬은 두 개가 있어요

03:46.680 --> 03:53.490
하나는 로라 A 하나는 로라 B라고 해요 무게의 변화가 알파형으로 바뀌는

03:53.550 --> 03:54.600
거죠

03:54.630 --> 03:58.520
배율 인수 곱하기 A 곱하기 B, 간단하죠

03:58.520 --> 04:02.410
이 코스에서 배울 수 있는 가장 많은 수학이죠. Get it.

04:02.920 --> 04:05.230
그 정도면 과하지 않은 것 같아요

04:05.230 --> 04:07.360
알파가 무엇인지만큼 간단하죠

04:07.360 --> 04:08.530
스케일링 요인이죠

04:08.530 --> 04:12.130
경험상 알파는 더블 R로 해야 해요

04:12.220 --> 04:13.630
다들 그렇게 해요

04:13.630 --> 04:16.480
알파의 다른 가치를 실험할 수 있어요

04:16.480 --> 04:20.650
하지만 알파는 R이 두 개인 게 일반적이죠

04:20.650 --> 04:25.120
R은 32로 알파는 64로 시작하죠

04:26.230 --> 04:33.760
퀀티세이션은 베이스 모델의 무게 중심을 줄이는 것을 일컫는 말이죠

04:33.760 --> 04:35.830
기본 모델은 32 비트 번호예요

04:35.830 --> 04:36.490
네

04:36.550 --> 04:41.980
8분의 1에서 4분의 1까지 줄여요 미친 소리 같겠지만요

04:42.070 --> 04:47.560
베이스 모델로 그렇게 했는데도 여전히 결과가 나오는 걸 봤죠

04:47.650 --> 04:51.730
좋은 결과는 아니었지만 전반적인 베이스 모델은 그렇다고 생각해요

04:51.730 --> 04:56.380
8비트 모델이 4비트 모델보다 잘 달리는 걸 확인했지만

04:56.380 --> 04:58.420
둘 다 아주 처참했어요

04:58.730 --> 05:02.900
8비트 모델로 연습해 볼 수도 있어요

05:02.900 --> 05:07.640
하지만 4비트 모델로 훈련할 거예요 우리 메모리에 맞으니까요

05:07.640 --> 05:12.650
Get 8 비트를 시도해보고 결과가 확연히 달라지는지

05:12.650 --> 05:13.910
보고 싶어요

05:14.630 --> 05:19.880
마지막 hyperpaameter는 새로운 건데 코드 드롭아웃에서 보여드린

05:19.880 --> 05:21.920
것 외엔 얘기한 적 없죠

05:21.920 --> 05:24.440
중퇴도 유형이군요

05:24.440 --> 05:29.960
정규화 기술이라고 알려진 기술인데 몇 가지가 있어요

05:29.960 --> 05:35.840
과잉 착용이라는 행동을 막기 위해 고안된 기술이죠

05:36.020 --> 05:43.340
과잉 충족이란 모델이 훈련 데이터를 많이 받고 훈련을 많이 거쳐서 훈련

05:43.340 --> 05:51.080
데이터 집합에 있는 데이터의 구조를 정확히 기대하게 되고 정확히 그 답을

05:51.110 --> 05:52.580
주는 거예요

05:52.580 --> 05:59.330
제안되는 것의 일반적인 추세를 더는 이해하지 못해요 대신

05:59.330 --> 06:04.100
그 단어와 나중에 나올 예측에 집중하죠

06:04.100 --> 06:10.520
그 결과 훈련 데이터 세트에서 보지 못한 새로운 점을 주면 성능이 아주 떨어집니다

06:10.550 --> 06:16.280
일반적인 주제를 배우는 게 아니라 그걸 배우는 거니까요

06:16.310 --> 06:21.980
이 훈련 데이터 집합의 세부 사항을 너무 많이 배웠어요

06:22.010 --> 06:24.530
또 손으로 비트를 휘젓고 있는데 이해하시길 바라요 get it get it

06:24.560 --> 06:31.040
훈련 데이터와 결과에 너무 충실하면 과잉 대응이라고 하죠

06:31.040 --> 06:36.380
예측하려는 것의 일반적인 맛을 배우는 게 아니에요

06:36.560 --> 06:38.000
바로 그 맛이에요

06:38.000 --> 06:39.770
뉘앙스가 중요한 거죠

06:39.770 --> 06:42.020
모델에게 그걸 가르쳐야 해요

06:42.260 --> 06:46.280
방금 그건 서문인데 뭘 설명하는 거죠?

06:46.310 --> 06:47.300
과잉이 뭔지에 대해서요

06:47.300 --> 06:53.690
드롭아웃의 기능을 간단히 설명하자면 드롭아웃의

06:53.780 --> 07:03.870
역할은 심층 신경망에서 무작위로 뉴런을 제거하는 거예요

07:03.870 --> 07:06.840
변압기에서 무작위로 퍼센트를 얻어요

07:06.960 --> 07:12.690
10%부터 시작할 거예요 10%의 뉴런을 제거하고 활성화 비율을 0으로 설정해서

07:12.690 --> 07:16.800
앞이나 뒤의 패스에는 관여하지 않게 하는 거죠

07:16.800 --> 07:21.300
다음 토큰을 예측하는 것과 관련 없고 최적화하는 것과도 관련 없죠

07:21.300 --> 07:23.010
마치 존재하지 않는 것 같아요

07:23.010 --> 07:29.730
그 결과 훈련을 받을 때마다 모델은 90%의 다른 신경망을

07:29.760 --> 07:35.490
무작위로 제거하는 다른 하위 집합을 보게 되죠

07:35.490 --> 07:44.310
그래서 추를 조작할 때 너무 정확하거나 너무 정확한 입력 토큰을 사용하지 않게

07:44.310 --> 07:50.700
됐죠 하지만 훈련 과정에서 다양한 뉴런이 참여하면서 더

07:50.700 --> 07:54.210
많은 걸 배우기 시작했어요

07:54.240 --> 08:00.670
일반적인 주제는 구체적으로 다른 패를 기대하는 법을 배우는 거죠

08:00.670 --> 08:05.380
하나의 뉴런이 너무 각화되지 않도록요

08:05.380 --> 08:11.560
신경망에 대한 일반적 이해를 뒷받침하는 개념이죠 매번 다른

08:11.560 --> 08:17.680
10%의 뉴런을 제거하는 아주 단순한 방법이에요

08:17.680 --> 08:18.910
드롭아웃이에요

08:18.910 --> 08:20.230
아주 간단해요

08:20.260 --> 08:28.180
그걸 깨달았을 땐 말 그대로 뉴런과 정상 기관이 떨어져 나가고 있었죠

08:28.570 --> 08:32.740
보통 5%에서 20% 정도 돼요

08:32.860 --> 08:36.340
10%는 포기한 사람으로 정했어요

08:36.340 --> 08:43.150
5%, 20%로 실험을 해봐야 해요. 더 나은 결과가 나올지 봐야죠. Get it.

08:43.180 --> 08:47.320
하이퍼파라미터로 실험해 볼 만하죠

08:47.830 --> 08:51.040
Q의 하이퍼파라미터 5개고요

08:51.070 --> 08:57.130
로라, 다음에는 전반적인 훈련 프로세스를 위한 hyperperameter 5개를 다룰 거예요
