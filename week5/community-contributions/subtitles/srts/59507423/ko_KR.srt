WEBVTT

00:00.920 --> 00:05.060
아주 오래 전에 데이터 세트를 만들던 때를 기억하실 거예요

00:05.060 --> 00:08.960
데이터를 허깅페이스에 업로드 했어요

00:08.990 --> 00:13.760
그 시점부터, 우린 피클 파일도 제작한 이후로 그 시점부터 피클 파일의 데이터를

00:13.760 --> 00:15.200
로드하고 있어요

00:15.200 --> 00:20.090
하지만 구글 Colab에 있으니 H깅페이스 허브에서 데이터를

00:20.090 --> 00:27.050
수집하는 게 가장 쉽죠 자신만의 모델을 만드는 이런 과정의 아주 전형적인 작업이에요

00:27.080 --> 00:28.400
그럼 시작할게요

00:28.430 --> 00:34.550
데이터셋을 로드합니다 얼굴 로드 데이터셋 메서드를 끌어안고 데이터셋 이름을 전달합니다.

00:34.550 --> 00:40.190
그리고 그것을 기차와 테스트, 데이터셋 이름을 상수에 나눠 놓죠.

00:40.220 --> 00:44.930
그 후에 첫 번째 훈련 데이터 포인트를 볼 수 있어요

00:45.080 --> 00:48.710
텍스트와 가격이 있는 것 같아요

00:48.740 --> 00:51.830
우리가 명시적으로 설정한 걸 기억하실 거예요

00:51.830 --> 00:54.800
글이 우리의 프롬프트예요

00:54.830 --> 01:00.590
가장 가까운 달러의 가격은 얼마일까요? 제품 설명과 가격은

01:00.590 --> 01:07.070
달러 그다음은 가격을 가장 가까운 숫자로 반올림해 볼게요

01:07.070 --> 01:08.330
그리고 위에도요

01:08.330 --> 01:09.920
이건 얼마냐고 물어볼게요

01:09.950 --> 01:11.330
최대한 많이요

01:11.720 --> 01:18.560
이렇게 하는 이유는 비트를 좀 더 쉽게 만들기 위해서예요 80억 개의 변수가 있는

01:18.560 --> 01:20.870
단일 모델이죠

01:21.230 --> 01:26.870
개척 모델로 보낼 때 그걸 지정할 필요가 없었어요 센트에 대한 결정을 스스로

01:26.870 --> 01:29.030
내릴 만큼 강력하니까요

01:29.030 --> 01:33.710
하지만 이 경우에는 최대한 단순하게 만들고 싶어요

01:33.920 --> 01:40.400
그리고 이건 항상 라마 3에서 토큰 하나로만 매핑되니까요 아주 쉽게 만들었어요 그냥

01:40.400 --> 01:46.490
저기 있는 토큰 하나만 예측하면 되죠

01:46.490 --> 01:50.180
그걸 잘 하는 방법을 배우려고 할 거예요

01:50.540 --> 01:54.320
이 데이터 세트에는 실제 가격도 있어요

01:54.680 --> 02:00.560
테스트 데이터를 보고 첫 번째 점을 보면 구조는 아주 비슷한데 한 가지

02:00.560 --> 02:02.600
작은 차이가 있어요

02:02.600 --> 02:03.950
그 차이가 뭔지 아세요?

02:04.130 --> 02:05.030
물론 그러시겠죠

02:05.070 --> 02:11.220
물론 이 시점에서 테스트 데이터에 제공된 가격은 없어요

02:11.250 --> 02:13.260
텍스트는 텍스트가 될 거예요

02:13.290 --> 02:14.970
이게 얼마 정도 해요?

02:14.970 --> 02:17.340
이 텍스트를 전달해요

02:17.340 --> 02:21.870
다음 토큰을 예측하는 게 우리 모델의 임무죠

02:21.900 --> 02:25.260
다음 토큰이 나올 확률은 얼마나 될까요?

02:25.260 --> 02:33.090
3이라는 숫자와 일치하는 토큰이 나올 확률이 높기를 바라야죠 74,000달러예요 실제

02:33.180 --> 02:35.490
가격과 같네요

02:35.550 --> 02:37.350
그게 이번 과제예요

02:37.350 --> 02:42.810
이것은 하나의 토큰에 대응하기 때문에 다음 토큰을 예측하는 것이 매우 어렵습니다.

02:42.810 --> 02:47.760
하나의 토큰이 비용을 나타내니까요. Get in get get it.

02:48.030 --> 02:52.620
또 하나 언급할 점은 기억하실지 모르겠지만 이 텍스트가 정확히

02:52.620 --> 02:58.140
179t less 토큰에 맞는지 확인하기 위해 우리가 좀 고생을 했었죠

02:58.260 --> 03:05.670
그 덕분에 이제 알 수 있는 게 여기 연속적으로 최대 시퀀스 길이가 182이라고

03:05.670 --> 03:08.460
나오네요

03:08.880 --> 03:10.320
몇 가지 패를 더했어요

03:10.320 --> 03:13.140
여기 있네요, 179개

03:13.140 --> 03:20.790
하지만 저는 여분의 토큰을 몇 개 추가할 겁니다 토큰라이저는 문장 토큰의 시작 부분을

03:20.790 --> 03:26.880
순서 시작 부분에 추가하고 문장 끝이나 패드 토큰을 추가할 수도

03:26.910 --> 03:28.890
있기 때문이죠

03:28.890 --> 03:34.500
실수로 가장 중요한 토큰의 가격을 오차로 처리하는 일은 없었으면 합니다

03:34.500 --> 03:37.020
마지막에 나올 토큰이죠

03:37.020 --> 03:42.450
약간의 여유만 있다면요 사실 훈련이 시작되기 전까진 중요하지 않아요 Get in get

03:42.450 --> 03:45.540
데이터를 보고 있으니 지금 지적하고 싶었어요

03:46.470 --> 03:48.510
자, 됐어요

03:48.720 --> 03:50.790
미안해요, 너무 심했어요

03:50.790 --> 03:53.010
방금 이 데이터를 봤어요

03:53.040 --> 03:57.630
다음으로 할 일은 올바른 퀀타이즈 구성을 고르는 거죠

03:57.630 --> 04:01.530
퀀트 포 비트 이상으로 상시 유지하기로 했어요

04:01.560 --> 04:03.420
이 경우엔 true로 설정했죠

04:03.450 --> 04:06.030
가서 확인해 보죠

04:06.060 --> 04:06.810
됐어요

04:06.810 --> 04:08.970
퀀트 포 비트가 트루로 설정됐어요

04:08.980 --> 04:14.320
이제 다시 내려오면 for 비트 퀀타이즈를 선택할게요

04:14.320 --> 04:17.110
8비트를 선택하면 어떻게 되는지 보여드릴게요

04:17.110 --> 04:20.680
하지만 아주 작은 4비트 버전을 고를 거예요

04:21.100 --> 04:24.370
그리고 토큰라이저와 모델을 로드하죠

04:24.370 --> 04:26.680
이 방은 안 쓸 거예요 이미 썼으니까요

04:26.680 --> 04:28.870
여기 메모리에 남아 있어요

04:28.870 --> 04:30.730
두 번 실행하면 메모리가 부족할 거예요

04:31.810 --> 04:36.100
여기서 토큰라이저를 로드할 거예요

04:36.130 --> 04:39.640
비트 박스는 상용적인 내용으로 자주 보게 될 거예요

04:39.760 --> 04:45.670
토큰라이저에 이렇게 알려 주는 거예요 시퀀스 끝에 패드를 넣어야 할 때는

04:45.670 --> 04:48.970
그냥 문장 끝부분을 쓰면 된다고요

04:48.970 --> 04:51.400
오른쪽에 이렇게 해야 해요

04:51.400 --> 04:54.430
훈련할 때 흔히 하는 거예요

04:54.430 --> 04:56.200
당장은 안 쓸 거예요

04:56.320 --> 04:57.910
걱정 안 하셔도 돼요

04:57.910 --> 04:59.740
하지만 어디서나 볼 수 있죠

04:59.740 --> 05:04.300
아주 표준적인 셋업이죠 여기 이 라인처럼요 이것도 지금 당장 걱정하실 필요는 없어요

05:04.300 --> 05:10.540
토큰이저를 만들어 llama 3을 로드하고 있어요 기본 모델 1개요

05:10.540 --> 05:15.370
5를 다 쓰고 있어요 메모리가 6GB예요

05:15.370 --> 05:22.090
저기 있네요, 55번 9개인 것 같아요 제가 아래에 추론을 했거든요

05:22.240 --> 05:29.710
아주 날씬한 4인치 비트 모델이에요

05:30.250 --> 05:34.810
이 함수는 여러분께 익숙할 겁니다 최근 프론티어 모델에서

05:34.840 --> 05:43.780
가격 추출에 사용했거든요 텍스트를 추출하죠 어떤 텍스트든요 예측된 가격을 추출해요

05:43.780 --> 05:55.570
가격을 추출하는 이런 걸 하면 가격은 $999 문자열로 이걸 넣어야겠죠

05:55.570 --> 05:57.040
잘 안 될 것 같아요

05:57.040 --> 06:01.120
가격은 달러 9999 어쩌고저쩌고죠

06:01.540 --> 06:04.600
가격은 999예요

06:04.840 --> 06:05.770
정말 싸요

06:07.060 --> 06:07.960
됐어요

06:08.260 --> 06:10.210
결과가 기대되네요

06:10.240 --> 06:10.540
네

06:10.570 --> 06:12.610
99999마리를 잡아낼 거예요

06:12.610 --> 06:16.760
모델은 프롬프트에서 제공될 거라는 걸 알죠

06:16.760 --> 06:21.680
9단계가 모두 포함돼야 해요

06:21.860 --> 06:25.820
이 모델이 예측해요

06:25.820 --> 06:30.080
이게 시험용 하네스에 사용할 함수예요

06:30.080 --> 06:33.020
우리가 그걸 알려주는 함수죠

06:33.050 --> 06:34.790
프롬프트를 하나 드리죠

06:34.790 --> 06:37.550
비용은 얼마나 드는지 알고 싶어요

06:37.550 --> 06:44.540
이건 추론 모드의 모델을 부르는 방법입니다 몇 주 전에 했던 것과 유사하죠

06:44.810 --> 06:52.490
프롬프트를 가져다가 Tokenizer.ex코드를 이용해 암호화해요

06:52.490 --> 06:55.820
이건 GPU 쪽으로 밀어내죠

06:56.510 --> 07:01.400
이건 그냥... 별로 중요하지 않은 거예요

07:01.400 --> 07:03.020
경고문을 인쇄하는 걸 막아주죠

07:03.020 --> 07:06.680
그럼 아무 영향도 없군요

07:07.190 --> 07:16.040
어, 그리고, 음 정확히 말하자면, 입력 토큰 영역에서 일어나는 일을 예측하지 못하게 합니다.

07:16.040 --> 07:22.880
예측하지 않고, 이후에 일어날 일을 예측하고 싶어하죠.

07:22.880 --> 07:24.170
어차피 그렇게 될 거예요

07:24.170 --> 07:27.230
하지만 우리가 말하지 않았다면 경고가 나왔을 거예요

07:27.410 --> 07:33.380
결과물을 위해 기본 모델 lemma 3을 호출하죠 1번요

07:33.380 --> 07:36.950
그 위에 생성 메서드를 호출할 거예요

07:36.980 --> 07:38.720
입력값을 통과시키죠

07:38.720 --> 07:41.930
최대 새 토큰을 위한 거라고 하죠

07:41.930 --> 07:43.340
훨씬 적은 숫자로 만들 수 있어요

07:43.340 --> 07:44.900
토큰 하나만 있으면 돼요

07:44.900 --> 07:51.680
4개까지 토큰을 생성하도록 할 것입니다 달러 기호를 또 출력할 수 있으니까요

07:52.100 --> 07:58.130
방금 설치한 주의력 마스크를 통과시키면 경고가 안 뜨죠

07:58.130 --> 08:00.590
이건 하나의 답만 원한다는 거죠

08:00.590 --> 08:03.290
여러 가지 답이 나오면 안 돼요

08:03.680 --> 08:08.000
그 답에 대한 답변은 그 답 하나를 취하면 다시 보내지죠

08:08.000 --> 08:13.130
Tokenizer.Dcoode를 호출해 다시 문자열로 바꾸죠

08:13.130 --> 08:15.830
그 문자열을 추출해요

08:16.340 --> 08:17.000
좋아요

08:17.000 --> 08:18.240
신나네요

08:18.240 --> 08:20.280
우리 스스로 되새겨 보죠

08:20.280 --> 08:27.270
0을 보면 첫 번째 테스트 항목이 여기 있네요

08:27.270 --> 08:30.000
OEM 에어컨 압축기예요

08:30.030 --> 08:33.780
실제 가격은 374달러예요

08:33.810 --> 08:34.920
누가 알았겠어요

08:34.920 --> 08:37.440
첫 번째 시도예요

08:37.440 --> 08:40.080
Model이라고 입력하죠 예측요

08:42.870 --> 08:44.010
0번째 테스트예요

08:44.010 --> 08:48.390
프롬프트를 얻기 위해 get 텍스트를 호출할게요

08:49.050 --> 08:50.190
그럼 준비되셨나요?

08:50.220 --> 08:50.970
시작할게요

08:51.000 --> 08:59.910
라마 3요 1번 기본 모델은 OEM AC 압축기와 수리 키트의

08:59.940 --> 09:02.850
가격을 예측해 보려고 해요

09:02.850 --> 09:07.470
예상 가격은 1,800달러인데 차이가 너무 커요

09:07.470 --> 09:12.960
라마 3에 대한 나쁜 징조일 수도 있어요 기본 모델 1개면 돼요

09:12.960 --> 09:20.460
첫 번째 예시는 운이 나빴을 뿐이지만 그건 다음 영상에서 밝혀질 거예요
