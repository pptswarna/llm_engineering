WEBVTT

00:00.800 --> 00:09.230
そして､ ハギング・フェイス・トランスフォーマー・ライブラリーのモデル・クラスを巡る旅の続きへようこそ｡ 

00:09.260 --> 00:17.690
私たちはただ､ 単純に書いたときに得られるラマ・モデルのアーキテクチャを見て､ 他のモデルにも目を向けるべきだと言っただけなのだ｡

00:17.690 --> 00:22.010
もうひとつ指摘しておきたいのは､ 常に次元を見ることだ｡ 

00:22.010 --> 00:32.120
簡単に触れたように､ ボキャブラリーを表す入力次元の数を見て､ それがこの下の出力と一致していることを確認してほしい｡

00:32.300 --> 00:39.080
そして､ 建築物を通して寸法を追うことができ､ 何が起こっているのかを感じ取ることができる｡ 

00:40.010 --> 00:41.060
分かった｡ 

00:41.060 --> 00:48.170
しかし､ こうしてすべてを終え､ 何が起こっているのかを話し合い､ インプットを作り上げた今､

00:48.200 --> 00:51.320
ビジネスの時が来た｡

00:51.320 --> 00:53.990
これがドットジェネレーションのメソッドモデルだ｡ 

00:53.990 --> 00:58.220
GPU上にある私たちの入力を取り込み､ その準備をする｡ 

00:58.460 --> 01:02.100
新しいトークンは80枚までとする｡ 

01:02.340 --> 01:06.150
ええと､ 念のために言っておくけど､ 私たちがお願いしたのはジョークだよ｡ 

01:06.180 --> 01:08.970
データサイエンティストの部屋でのジョーク｡ 

01:09.000 --> 01:11.460
私たちのお気に入りの小さな実験｡ 

01:11.700 --> 01:16.110
それから出力を取るんだ｡ 

01:16.110 --> 01:20.490
アウトプットのリストの最初のものを取る｡ 

01:20.760 --> 01:28.770
そして､ トークナイザー・ドット・デコードを呼び出して､ トークンから文字に戻し､ 再びテキストにする｡ 

01:28.770 --> 01:30.690
そしてその結果を印刷する｡ 

01:30.720 --> 01:32.340
そうしよう｡ 

01:32.520 --> 01:34.560
だから走り出す｡ 

01:34.710 --> 01:41.070
この下を見て､ フォワードパスをするのを見るのが好きなんだ｡ 

01:41.070 --> 01:45.810
そして､ 軽妙なジョークに対する私たちの答えがそこにある｡ 

01:45.810 --> 01:49.590
なぜ回帰モデルはニューラルネットワークと別れたのか？

01:49.620 --> 01:54.900
ニューラルネットワークが感情をオーバーフィットさせていたからだ｡ 

01:55.230 --> 01:56.610
ああ､ 大丈夫だよ｡ 

01:56.610 --> 01:57.830
ひどくはない｡ 

01:57.830 --> 01:58.880
それは､ ええと｡ 

01:58.910 --> 02:02.990
ああ､ まったくもっともなジョークだよ｡ 

02:02.990 --> 02:05.870
今まで聞いた中で一番面白いとは思わないけど､ まあね｡ 

02:05.900 --> 02:07.370
悪くないよ｡ 

02:09.290 --> 02:12.350
ロジスティック回帰モデルはなぜセラピーを受けたのか？

02:12.350 --> 02:15.410
感情を分類するのに苦労していたからだ｡ 

02:15.410 --> 02:17.120
それは本当にいいことだと思うよ｡ 

02:17.120 --> 02:18.560
それは素晴らしいことだと思う｡ 

02:19.520 --> 02:23.810
よりシンプルで､ データ・サイエンスの読者には的確だ｡ 

02:23.810 --> 02:30.410
フロンティアのモデルたちが思いつくギャグより､ その方がいいと思うよ｡ 

02:30.830 --> 02:33.320
ああ､ よくやった｡ 

02:33.320 --> 02:34.520
ラマ 3. 1.

02:34.730 --> 02:45.320
ええと､ 念頭に置いておかなければならないのは､ もちろん､ ここで扱っているのは80億パラメータのバージョンのラマ3だということだ｡

02:45.320 --> 02:45.320
1､

02:45.320 --> 02:46.730
つまり最小のバージョンで､ それを4ビットに量子化し､ さらに2倍に量子化した｡

02:46.910 --> 02:54.740
ええと､ つまり､ この超スリム版のモデルで､ 完全に立派なジョークを言っただけなんだ｡ 

02:55.710 --> 02:57.840
楽しんでもらえたかな？

02:57.990 --> 03:01.500
次にすることは､ メモリを解放するためのクリーンアップだ｡ 

03:01.500 --> 03:06.570
そうでなければ､ このまま走り続ければ､ さまざまなモデルがあっという間にGPUを使い果たしてしまう｡ 

03:06.660 --> 03:13.320
このようなことが起こるかもしれないが､ その場合はいつでもランタイムのセッションを再起動して､

03:13.320 --> 03:19.110
インポートを行った後､ 中断したところから続けることができる｡

03:19.620 --> 03:27.450
だから次にすることは､ 今やったことをすべて､ そのすべてを行う小さな関数にパッケージ化することだ｡

03:27.450 --> 03:34.770
この関数は､ モデル名を受け取り､ 通常の辞書のリストをメッセージします｡ 

03:34.770 --> 03:38.970
そして､ 今やったことを修正する方法として､ これを一行ずつ見ていこう｡ 

03:39.000 --> 03:48.060
まず､ オート・トークナイザー・クラスを使用して､ 作業中のモデルに基づいて新しいトークナイザーを作成します｡

03:48.990 --> 03:54.860
この行は､ パディング・トークンを文末トークンと同じにするためのものである｡ 

03:54.890 --> 03:57.710
このようなことは､ お決まりの定型文のようなものだ｡ 

03:57.950 --> 03:58.970
そしてこれだ｡ 

03:58.970 --> 04:00.890
私たちはそれを知っているし､ よく知っている｡ 

04:01.130 --> 04:08.900
ここで､ このトークナイザーに適したチャットテンプレートをリストのメッセージに適用します｡ 

04:08.900 --> 04:13.220
そして､ 一連のトークンを返してくる｡ 

04:13.220 --> 04:20.240
それをGPUに載せ､ 入力に割り当てる｡ 

04:20.510 --> 04:21.590
これは新しい｡ 

04:21.590 --> 04:29.120
だから､ もうひとつ､ ちょっとした技を加えて､ 結果をストリーミングで返そうと思うんだ｡ 

04:29.240 --> 04:33.320
そして､ Huggingfaceライブラリーはそれもサポートしている｡ 

04:33.320 --> 04:36.290
テキストストリーマーというものを作るんだ｡ 

04:36.320 --> 04:43.190
トークンをストリームバックする際に､ トークンをテキストに変換する必要があるからだ｡

04:43.220 --> 04:46.130
どのトークナイザーを使っているかを知る必要がある｡ 

04:46.130 --> 04:50.240
だから､ それを提供し､ そして行動する｡ 

04:50.450 --> 04:52.400
ええと､ まずモデルを手に入れます｡ 

04:52.400 --> 04:55.200
これは因果LMの自動モデルである｡ 

04:55.200 --> 04:58.770
これはオート・トークナイザーに相当する｡ 

04:58.770 --> 05:04.350
しかし､ 事前に訓練されたモデルをロードするには､ モデル名を指定する｡ 

05:04.470 --> 05:07.590
デバイス・マップはオート､ つまりユーザーGPUを意味する｡ 

05:07.590 --> 05:22.650
もし4ビットの数値があれば､ その数値のコンフィギュレーションを4ビット・ダブル量子化NFに設定する｡

05:22.650 --> 05:28.710
そして､ bfloat16は計算､ つまりデータ型である｡ 

05:29.010 --> 05:34.170
そして､ 今こそビジネスモデルのドットジェネレーションの時だ｡ 

05:34.170 --> 05:35.460
それが大きな方法だ｡ 

05:35.460 --> 05:42.540
そしてインプットを渡すと､ 最大80の新しいトークンを生成し､ ストリーマに渡す｡ 

05:42.570 --> 05:49.020
これが､ 出力をストリーミングし､ クリーンアップする部分だ｡ 

05:49.530 --> 05:55.550
つまり､ この関数は､ 前にやったことをすべてラップし､ さらにストリーミングを追加したものだ｡ 

05:55.550 --> 06:03.350
それで､ 今書いた関数を使って､ 単純にファイ3をメッセージで呼び出してみよう｡

06:03.350 --> 06:06.380
これでファイ3が再びロードされることになる｡ 

06:06.410 --> 06:12.920
初めてロードするので､ 少し時間がかかります｡ 

06:12.980 --> 06:16.370
ええと､ すでにロードしてあるので､ ディスクにキャッシュされています｡ 

06:16.460 --> 06:20.660
ええと､ だから､ ハグした顔から全部を再ダウンロードする必要はないんだ｡ 

06:20.690 --> 06:21.380
ハブだ｡ 

06:21.710 --> 06:25.730
そうしている間に､ ロードするためにまだ少しやることがあるんだ｡ 

06:25.730 --> 06:27.140
そうだな｡ 

06:27.170 --> 06:32.180
ああ､ 資源を見ることができると言おうと思ったんだけど､ あっという間に終わってしまいそうだから､

06:32.180 --> 06:34.580
ストリーミングで戻ってきてほしいんだ｡

06:34.610 --> 06:39.050
そして､ がっかりされるかもしれないという事実を覚悟しておくべきだと思うんだ｡ 

06:39.560 --> 06:50.400
少なくともプロンプトを使った限りでは､ ファイ3にジョークを言わせることはできなかった｡

06:50.400 --> 06:59.010
むしろ､ データ・サイエンティストが話していそうな一般的な事柄をいくつか挙げて､ とりとめもなく説明している｡

06:59.040 --> 07:04.320
このプロンプトを､ 53歳にとってもう少し自己主張の強いものに改善できるか､

07:04.320 --> 07:08.700
それとも単に53歳がやりたがらないだけなのかはわからない｡

07:08.970 --> 07:14.040
53は実に多くのことを立派にこなすが､ この特別な仕事はできない｡ 

07:14.040 --> 07:19.680
だから､ 他のモデルも試してみてほしい｡ 

07:19.680 --> 07:28.860
また､ 53にジョークを言わせるために促し方を改善できるかどうか､ あるいはジョーク好きでないなら､ 得意なことをいくつか見つけられるかどうかも見てみよう｡

07:28.860 --> 07:35.130
Llmsの使用方法など､ 我々がllmsに尋ねた他の質問にも､ 実にうまく答えてくれるだろう｡

07:35.700 --> 07:41.070
それが53の結果だ｡ 

07:41.070 --> 07:43.410
さて､ ジェマはどうするか｡ 

07:43.410 --> 07:51.290
Gemmaはシステム・プロンプトをサポートしていないので､

07:51.320 --> 08:02.270
このようにユーザー・プロンプトを渡さなければならない｡

08:02.540 --> 08:06.500
そして､ ジェンマを試してみよう｡ 

08:06.500 --> 08:08.780
もちろん､ 20億のモデルだ｡ 

08:08.780 --> 08:10.130
とても小さなモデルだ｡ 

08:10.130 --> 08:16.850
非常に小さなモデルであることに加えて､ 私たちはそれを4ビットに量子化し､ また量子化している｡

08:16.850 --> 08:29.270
というわけで､ この時点では非常にスリムなモデルを扱っていて､ メモリもそれほど消費しないし､ 読み込みも早くてジョークもすぐに言えるはずだ｡

08:32.330 --> 08:34.130
そこにジョークがある｡ 

08:34.130 --> 08:37.400
データサイエンティストはなぜ統計学者と別れたのか？

08:37.400 --> 08:41.240
p値に関する意見の相違が多すぎたからだ｡ 

08:41.270 --> 08:44.540
p値に関する､ またオタクっぽいジョークだよ｡ 

08:44.570 --> 08:46.130
私には理解できない｡ 

08:46.140 --> 08:49.470
でも､ もしかしたら私が見落としている明白な何かがあるかもしれない｡ 

08:49.620 --> 08:50.790
ああ､ ようこそ｡ 

08:50.790 --> 08:53.040
どなたか教えてください｡ 

08:53.370 --> 08:53.760
ええと｡ 

08:53.760 --> 08:56.820
それでも､ 親切でフレンドリーなところがいい｡ 

08:56.820 --> 08:57.540
もうひとつある｡ 

08:57.540 --> 08:59.490
またジョークを聞きたいなら言ってくれ｡ 

08:59.640 --> 09:02.970
これを走らせたら､ もっといいジョークが飛び出すかもしれないよ｡ 

09:03.120 --> 09:07.890
あー､ でも､ あー､ 確かに､ あー､ 楽しい､ あー､ トーンだ｡ 

09:07.890 --> 09:15.180
そして､ ジェマ2世はデータ・サイエンスに関連した､ 称賛に値する仕事をしたと思う｡

09:15.480 --> 09:21.780
そして､ 特に､ この小さなモデルをさらに量子化していることを思い出してほしい｡ 

09:21.780 --> 09:28.440
ジェマ2世は素晴らしい結果を残したと思うが､ 私が使っている量子を使えば､

09:28.440 --> 09:36.150
もっと優れた結果が出るだろうし､ パイ3世でももっと良い結果が出るかもしれない｡

09:36.150 --> 09:41.310
それから､ ミックスドトライアルモデルを選ぼうが､ もう少しスリムで自分も使えるものを選ぼうが､

09:41.340 --> 09:44.370
いずれにせよ､ いい結果が得られると想像している｡

09:44.510 --> 09:49.580
また､ 彼らが苦手とする数学の質問をしてみるのもいいだろう｡ 

09:49.610 --> 09:52.640
難しい数学を扱っているのなら｡ 

09:52.790 --> 10:02.840
しかし､ 私はラマ3世にかなり難しい質問をしてみた｡  1以前は全く問題なかった｡

10:03.200 --> 10:09.050
いずれにせよ､ 今はこれらのモデルを使って､ いろいろなことを試してみる時だ｡ 

10:09.080 --> 10:11.450
あなたはオープンソースのモデルを使っている｡ 

10:11.540 --> 10:13.490
APIにコストはかかっていない｡ 

10:13.520 --> 10:16.610
あなたが支払うコストは､ 使い切った場合だけです｡ 

10:16.610 --> 10:25.850
フリー・コラボを利用していない方で､ グーグル・コラボのユニットを使い切ろうとしている方｡

10:26.030 --> 10:32.240
ええと､ 私が使っているのは1. 毎時76台｡ 

10:32.240 --> 10:40.250
というわけで､ これを使って作業したり､ 抱きつき顔トランスフォーマー・ライブラリーを使ってオープンソースのモデルで推論を楽しんだりする時間は､

10:40.250 --> 10:43.790
本当にたくさんある｡
