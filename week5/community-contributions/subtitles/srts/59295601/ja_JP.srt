WEBVTT

00:00.380 --> 00:13.460
そこで､ オープンソースの世界への旅を続け､ オープンソース・コードを生成する能力を調査するためにどのモデルを選ぶべきかを理解する時が来た｡

00:13.460 --> 00:14.420
何から始めようか？

00:14.420 --> 00:17.780
もちろん､ まずは大きなコードモデルのリーダーボードから｡ 

00:17.780 --> 00:28.820
これは､ 以前見た､ 抱き合った顔の空間として動いているリーダーボードで､ コード生成タスクにおけるオープンソースモデルのパフォーマンスを比較するものだ｡

00:29.270 --> 00:39.530
コード・ラマ､ コード・クワン､ ディープ・シーク・コーダーなど､ 本当にうまくいっているベースモデルのいくつかを見ることができる｡

00:39.770 --> 00:44.540
というのも､ C＋＋コードのようなタスクのために特別に訓練されたモデルは､

00:44.690 --> 00:55.370
基本モデルよりもはるかに優れたパフォーマンスを発揮するからです｡

00:55.520 --> 01:03.080
PythonとCに加えて､ テスト能力も見ていきます｡

01:03.440 --> 01:12.350
そして､ これらを見るとき､ ひとつ注目すべきことは､ ここで終了と書かれているものは､ 彼らのベンチマークであり､ スコアリングの一部は外部で行われたものだということだ｡

01:12.350 --> 01:17.720
だから個人的には､ そのシンボルがないもの､ ハグフェイスの一部としてベンチマークされたもの､

01:17.720 --> 01:33.050
スペース・プラットフォーム､ そしてこのリストのトップにあるコード・クワン1に傾倒する傾向がある｡

01:33.050 --> 01:33.050
570億ドル､ まさにトップだ｡ 

01:33.050 --> 01:35.090
クワンのコードバリエーション｡ 

01:35.090 --> 01:40.850
チャット用に訓練されているので､ 例えばPythonのコードを与えて完了するのを期待するのではなく､

01:40.850 --> 01:43.670
対話することができる｡

01:43.670 --> 01:50.870
このPythonのコードを最適化されたC言語に変換してくれない？

01:50.870 --> 01:51.500
プラス？

01:51.500 --> 01:53.150
中に入って見てみよう｡ 

01:53.630 --> 02:00.710
我々は今､ コード・クワン1を見ている｡  570億円のチャットがトップモデル｡ 

02:00.740 --> 02:04.250
そして､ ここにその機能の一部が記されている｡ 

02:04.400 --> 02:07.310
そして､ どのようにそれに接することができるのか｡ 

02:07.340 --> 02:11.270
例えば､ Pythonでクイックソートのアルゴリズムを書けばいい｡ 

02:11.450 --> 02:18.080
そして､ トークナイザーがチャットテンプレートを適用してトークンに変換し､

02:18.110 --> 02:25.070
それをモデルを通して実行します｡

02:25.070 --> 02:34.040
だからこれは､ 過去に他の単純な活動､ つまりテキストを生成する活動に対して多くのモデルを実行した方法と非常に一致している｡

02:34.310 --> 02:43.760
Codeclanを見ると､ PythonのコーディングとCプラスアルファのコーディングで実に高いスコアを出していることがわかる｡

02:43.760 --> 02:51.380
ここで負けているのは､ ほんのわずかしか成績が良くない外部運営のこちらだけだ｡ 

02:51.380 --> 02:56.780
そして見てみると､ このモデル自体が実はクインの微調整そのものなのだ｡ 

02:56.780 --> 03:01.040
だから率直に言って､ コードにこだわることでうまくいっていると思う｡ 

03:01.040 --> 03:01.610
クインだ｡ 

03:01.640 --> 03:04.250
その後は大きく落ち込む｡ 

03:04.250 --> 03:13.550
もうひとつは､ コード・ジェンマをお見せしたかったんです｡

03:13.610 --> 03:15.590
しかし､ コードを使おうとすると､ そうなってしまう｡ 

03:15.620 --> 03:23.000
ジェマ......とても簡単なタスクには答えられたけど､ もっと難しいタスクを与えられるとクラッシュしたんだ｡

03:23.000 --> 03:25.730
コードを取得できるかどうか､ 練習として試してみるのもいいかもしれない｡ 

03:25.730 --> 03:35.000
Gemmaは動くが､ この特別な問題では動かなかった｡ 少なくとも､ CプラスプラスでPythonの複雑な翻訳や再実装はできなかった｡

03:35.000 --> 03:42.470
しかし､ 他のモデルを試してみるのもいい練習になるだろう｡

03:42.470 --> 03:46.820
だから､ コード・クアンを選んだんだ｡ 

03:46.850 --> 03:48.560
もう1度突っ込んでみよう｡ 

03:48.680 --> 03:52.970
ええと､ 次にやるべきことは､ どうやってこれをいろいろな方法で走らせるかを考えることだ｡ 

03:52.970 --> 03:53.450
私たちならできる｡ 

03:53.450 --> 03:54.770
そのうちの一人はすでにご存じだろう｡ 

03:54.770 --> 04:01.460
Google Colabにアクセスして､ Hugging Face Transformersライブラリを使ってCodexコードに直接アクセスし､

04:01.460 --> 04:07.280
それを読み込んで推論時に実行するコードを書けばいいのだ｡

04:07.610 --> 04:08.810
それは素晴らしいことだ｡ 

04:08.810 --> 04:14.810
問題は､ コンパイルしたコードを自分のマシンで実行したいので､ ちょっと不便だということだ｡ 

04:14.840 --> 04:21.500
そのコードをJupyterで実行し､ Google Colabで実行し､ 私のボックスにコピー＆ペーストしなければならない｡

04:21.650 --> 04:25.250
そして､ そのすべてを1つの素敵なユーザーインターフェイスで行えることを望んでいた｡ 

04:25.250 --> 04:30.230
だから基本的には､ このモデルをそのまま､ でも自分のボックスから実行できるようにしたいんだ｡ 

04:30.260 --> 04:34.370
その方法はいくつかあるので､ そのすべてを紹介するつもりはないが､

04:34.370 --> 04:41.990
超便利な方法がある｡

04:41.990 --> 04:50.000
そしてそれは､ あなたのためにこのモデルを実行し､ あなたのコードからリモートでモデルを呼び出すために使用できるエンドポイントを与えてくれるよう､

04:50.000 --> 04:53.540
hugging faceに依頼することである｡

04:53.540 --> 04:59.690
つまり､ このモデルのようなモデルや､ あなたが望むオープンソースのモデルを実行するためのホスティング・ソリューションのようなもので､

04:59.690 --> 05:02.810
自分で実行するためのエンドポイントを提供する｡

05:02.840 --> 05:04.790
そして､ それは超高度に聞こえる｡ 

05:04.880 --> 05:07.340
こんなことをするのは大変だと思うかもしれない｡ 

05:07.430 --> 05:09.680
全然難しくないことがわかった｡ 

05:09.680 --> 05:12.740
ここにあるデプロイボタンをクリックするだけだ｡ 

05:12.740 --> 05:19.130
そして最初の選択肢は､ 本番用の推論専用の推論エンドポイントだ｡ 

05:19.130 --> 05:24.380
そして､ このモデルを独自に展開することができる方法だと言っているのだ｡ 

05:24.380 --> 05:30.350
そして､ どこからでも自分で電話をかけ､ このモデルを自分で使うことができるようになる｡ 

05:30.350 --> 05:32.900
もちろん､ そのための費用は支払わなければならない｡ 

05:33.230 --> 05:37.310
タダではないが､ 決して高くはない｡ 

05:37.310 --> 05:39.260
でも､ これはちょっと高いんだ｡ 

05:39.290 --> 05:41.480
確かに注意すべきことだ｡ 

05:41.630 --> 05:48.890
これらの推論エンドポイントを使用する場合､ AWS､ Azure､ GCP､ Google

05:48.890 --> 05:53.450
Cloudのどれで実行するかを選択します｡

05:53.660 --> 05:57.440
また､ CPUボックスかGPUボックスかを選ぶこともできる｡ 

05:57.440 --> 06:07.100
このモデルの場合､ GPUボックスが必要で､ 少なくともNvidia L4が必要だ｡

06:07.130 --> 06:13.820
少なくとも､ GPUに24GBのラムを搭載している私たちには､ それが推奨されている｡ 

06:14.210 --> 06:23.870
これを選択し､ いくつかの項目を入力し､ エンドポイントの作成をクリックします｡

06:23.870 --> 06:25.190
それはとても簡単なことだ｡ 

06:25.190 --> 06:34.070
私たちは､ あなたの個人的な使用のために私たち自身の専用エンドポイントを持っている抱擁顔0ドルを支払って実行している｡

06:34.070 --> 06:34.070
時給80円｡ 

06:34.070 --> 06:36.860
米国にお住まいの方は､ 価格が異なるかもしれません｡ 

06:36.860 --> 06:41.360
だから､ 超安くはないけれど､ いつでも好きなときにオフにしたりオンにしたりできるんだ｡ 

06:41.390 --> 06:46.070
もし予算が許すのであれば､ 実験することをお勧めするが､

06:46.070 --> 06:55.340
もしそうでなければ､ 心配はいらない｡

06:55.370 --> 06:57.560
どんなものか､ 一緒に見てみるといい｡ 

06:57.680 --> 07:01.700
このメニューを使って､ 専用のエンドポイントに移動します｡ 

07:01.700 --> 07:05.780
そして､ 2つの専用エンドポイントを設定したことがわかるだろう｡ 

07:05.780 --> 07:09.110
そのひとつがコードクランである｡ 

07:09.110 --> 07:15.560
私は基本的にその画面に従い､ 推奨されたL4ボックスで動作している｡ 

07:15.590 --> 07:21.410
というわけで､ 現在の支出は0ドルだ｡  このエンドポイントを走らせる喜びのために1時間80ドル｡ 

07:21.440 --> 07:23.390
私があなたのために何もしないとは言わせない｡ 

07:23.930 --> 07:27.740
そして､ ジェンマのコードも試した｡ 

07:28.070 --> 07:29.690
アルファボックスで試してみた｡ 

07:29.690 --> 07:31.310
私はこれを実行させることができなかった｡ 

07:31.310 --> 07:35.960
簡単なことはできるけど､ 複雑すぎるとクラッシュするんだ｡ 

07:36.200 --> 07:39.950
でも､ 私はこれを練習の場として使ってほしい｡ 

07:39.950 --> 07:46.040
コード・ジェンマを使えるようにしてみて､ それがコードとどう一致するのか興味がある｡ 

07:46.490 --> 07:52.100
しかし､ リーダーボードを見ればわかるように､ コーデクランがこの種のタスクにおいて非常に優れており､

07:52.100 --> 07:59.450
非常に有能であることに疑いの余地はないだろう｡

07:59.540 --> 08:05.210
だから､ この時点で､ あなたは願わくば､ この通りにしてほしい｡ 

08:05.240 --> 08:10.550
codeclanエンドポイントが立ち上がって実行されるまで､ コーヒーを買いに行って5分待つ必要がある｡

08:10.550 --> 08:19.190
その後､ このエンドポイントを呼び出してコード生成を試すために､ 私たちのボックスで実行されているJupyterLabに戻る準備ができる｡

08:19.190 --> 08:20.360
すぐに会おう｡ 
