WEBVTT

00:00.470 --> 00:10.220
第8週2日目パート4の最終段階として､ これらすべてを統合したアンサンブル・モデルを構築する｡

00:10.220 --> 00:16.040
まず､ 私のマイク､ Quadcast HyperXコンデンサーマイクのような製品を例にとると､

00:16.040 --> 00:26.330
Specialist FrontierとRandom Forestの3つのオブジェクトがあり､ それぞれにこの製品の価格を尋ねることができます｡

00:26.330 --> 00:28.670
そして､ この3つの数字をご覧いただきたい｡ 

00:28.670 --> 00:33.080
この場合､ フロンティアモデルが最も真実に近いと思う｡ 

00:33.080 --> 00:38.780
前回､ スペシャリストモデルに電話したとき､ 私たちとたぶん私の文章が少し違っていたように記憶している｡

00:38.780 --> 00:40.100
さらに良くなったと思う｡ 

00:40.100 --> 00:43.940
129だったと思う｡ 

00:44.120 --> 00:45.740
あー､ でもそうだね｡ 

00:45.740 --> 00:51.830
とにかく､ ランダムフォレストの結果はあまり良くなかったが､ 他の2つは､ まあ､ 妥当だったということがわかるだろう｡

00:52.070 --> 00:55.280
だから､ 私たちが今やっていることはとてもシンプルだ｡ 

00:55.280 --> 01:02.450
まず､ 250のテストデータを取る｡ 

01:02.510 --> 01:10.170
実際にテストに使っているものとは別にするために､ 1000から150までのものを選んだんだ｡

01:10.410 --> 01:18.630
基本的には､ それぞれの項目を取り出して､ その説明を見つけ､ スペシャリストモデル､ フロンティアモデル､

01:18.630 --> 01:24.930
ランダムフォレストモデルから得られる価格を加える｡

01:24.930 --> 01:29.700
そして､ その商品の本当の値段を書く価格リストも持っている｡ 

01:29.700 --> 01:37.890
つまり､ GPT4から得られた独自のLLMフロンティアラグに基づく結果の専門家によるリストと､ 私たちの特別なコンテキストとランダムフォレストの結果､

01:37.920 --> 01:47.310
そしてグランドトゥルース（実際の数値）を加えた4つのリストが完成することになる｡

01:47.310 --> 01:49.410
そして､ そのすべてを構築する｡ 

01:50.160 --> 01:52.770
これから､ よくあるトリックをやってみよう｡ 

01:52.770 --> 01:54.630
本当に遊べるものなんだ｡ 

01:54.630 --> 01:57.480
あと2つ､ この中に加えようと思う｡ 

01:57.510 --> 02:06.750
そのうちの1つはMinsと呼ばれ､ 3つのうちの最小値であり､ もう1つはMax'sと呼ばれ､ 3つのうちの最大値である｡

02:06.960 --> 02:13.250
ただ､ それはもう一つのウム､ 事実であり､ そこに何らかのシグナルがあるかもしれない｡ 

02:13.250 --> 02:22.520
また､ 3つのモデルで最も低い見積もりと､ 1つの製品で最も高い見積もりを見てみるのも有効かもしれない｡

02:22.520 --> 02:30.140
つまりこの時点で､ 250の各製品について､ スペシャリスト､ フロンティア､ ランダムフォレスト､ この3つのうちの最小値､

02:30.140 --> 02:35.630
そしてこの3つのうちの最大値の5つの結果が得られたことになる｡

02:35.660 --> 02:47.240
これらのデータは5つのコレクションに格納されており､ フロンティア､ ランダムフォレスト､ 最小値､ 最大値の5つのスペシャリストからパンダのデータフレームを作成する｡

02:47.330 --> 02:52.340
そして､ その価格､ グランドトゥルースをシリーズに変換する｡ 

02:52.340 --> 03:01.010
これをxと呼び､ これをyと呼ぶ｡ 従来の機械学習のバックグラウンドを持つ人なら誰でも知っていることだろう｡

03:01.010 --> 03:07.670
つまり､ 線形回帰モデルをトレーニングして､ これらの異なる系列のどの加重平均が､

03:07.670 --> 03:20.190
このデータに最もフィットし､ 最も良い結果をもたらすか､ という単純な線形回帰を行うことができる｡

03:20.520 --> 03:22.800
だからそうするんだ｡ 

03:22.950 --> 03:25.140
そして､ こうなった｡ 

03:25.140 --> 03:26.820
これが係数である｡ 

03:27.570 --> 03:31.980
だから､ 最低点と最高点の両方がかなり高いウェイトを占めている｡ 

03:32.070 --> 03:42.690
つまり､ 一般的に言えば､ 最小値と最大値の組み合わせを最もよく見ている｡

03:42.750 --> 03:49.980
そうすると､ LM専業メーカーのシェアは健闘しているが､ フロンティア・モデルのシェアはずっと小さい｡

03:49.980 --> 03:53.280
そして少々奇妙なことに､ それは実際にフロンティアと言われている｡ 

03:53.310 --> 04:06.180
ランダムフォレストにはシグナルがありますが､ それを差し引きます｡ かなり大きな切片を与えて､ ランダムフォレストの数値の一部を差し引いているのがわかるでしょう｡

04:06.300 --> 04:11.220
これは不思議な結果で､ ランダムフォレストの数値がそれほど良くなかったことを示している｡

04:11.250 --> 04:15.210
しかし､ 全体的なパズルの中にそれを取り入れることは有効だと思う｡ 

04:15.240 --> 04:17.790
今､ あなたはおそらく心の中でこう思っていることだろう｡ 

04:17.790 --> 04:21.960
この2つにはランダムフォレストがすでに組み込まれていると指摘されたので､ それはできない｡ 

04:21.990 --> 04:28.860
マイナスの数字があることは､ すでに最小値と最大値に織り込まれているからだ｡

04:28.860 --> 04:35.280
そのため､ この3つのモデルをどのように評価するかについて､ おそらくより良い評価を得るために､ 最小値と最大値を取り除いてもう一度実行することができる｡

04:35.880 --> 04:44.880
つまり､ アンサンブルモデルを構築するのに必要なのは､ このモデルを使ってさまざまな要素を取り込み､

04:44.880 --> 04:52.830
投入したモデルの最良の線形結合をとって価格を予測することだ｡

04:53.160 --> 04:58.890
だから､ まずアンサンブル・モデルにそれを保存して､ 将来のためにキャプチャしておくんだ｡ 

04:58.890 --> 05:00.720
毎回走る必要はない｡ 

05:00.720 --> 05:05.130
そして､ アンサンブル・エージェントという新しいエージェントを作った｡ 

05:05.160 --> 05:08.130
今すぐアンサンブル・エージェントを見に行こう｡ 

05:08.820 --> 05:09.630
これだ｡ 

05:09.630 --> 05:11.610
これはアンサンブル・エージェントのコードである｡ 

05:11.610 --> 05:13.230
そして､ それはとてもシンプルだ｡ 

05:13.500 --> 05:16.590
ええと､ ここにコメントを加える必要があるようなので､ そうしよう｡ 

05:16.590 --> 05:20.550
だから､ これを自分で見る前に､ コメントが必要なんだ｡ 

05:20.550 --> 05:21.450
悪い肉だ｡ 

05:21.720 --> 05:23.700
それは申し訳ない｡ 

05:24.060 --> 05:33.480
イニシエーションでは､ 価格設定に使用する3つのエージェントを作成し､ セットアップした｡

05:33.840 --> 05:40.380
また､ アンサンブル・エージェントを動かして価格を算出する際には､

05:40.380 --> 05:46.560
そのモデルの重みをロードして加重結合を行います｡

05:46.560 --> 05:48.270
フロンティアの価格をこう呼ぶ｡ 

05:48.270 --> 05:50.700
ランダムフォレストの価格を呼ぶ｡ 

05:50.730 --> 05:55.830
最小値と最大値を含むXのデータフレームを作成する｡ 

05:55.860 --> 06:03.600
そして最後にモデルを呼ぶ｡  データ・サイエンスの言葉を使うなら､ なぜYになるのかを予測し､

06:03.600 --> 06:07.560
その予測を返す｡

06:08.310 --> 06:11.040
ええと､ だから､ あなたにとって明確なものであってほしい｡ 

06:11.040 --> 06:19.860
これは単純に､ 以前に構築したさまざまなモデルの線形結合を与える線形回帰モデルへの呼び出しをパッケージ化する方法である｡

06:20.010 --> 06:30.710
それで､ もちろん､ 次に試したのは､ 想像できると思うけど､ 同じように価格を設定することだった｡

06:30.710 --> 06:34.880
その結果､ 私たちが期待していた通りの中間的な数字が出た｡ 

06:34.880 --> 06:45.020
そしてもちろん､ そのアンサンブルを使ってテスターのドットテストを呼び出す｡

06:45.020 --> 06:49.490
モーダルは時間がかかる｡ 

06:49.490 --> 06:50.810
だから､ 事前に実行したんだ｡ 

06:50.810 --> 06:55.310
これをご覧になっている方は､ モーダルがウォームアップする間､

06:55.310 --> 06:59.270
最初に数分かかることを覚えておいてください｡

06:59.450 --> 07:05.750
見ての通り､ 赤が数匹いる｡ 

07:05.750 --> 07:06.650
私が教えてあげよう｡ 

07:06.680 --> 07:14.030
やや残念なことに､ 私はこれで針が動き､ 私たちが持っている素晴らしい独自モデルを打ち負かすことを本当に期待していたのですが､

07:14.030 --> 07:20.450
やや残念なことに､ この､ 複数のモデルをアンサンブルするというアプローチを使うと､

07:20.450 --> 07:30.590
このテストデータセットでは､ 以前よりも少し悪くなってしまったようです｡

07:30.590 --> 07:35.320
しかし､ それはむしろ､ かなりノイジーであるという事実によるものだと想像しなければならない｡ 

07:35.590 --> 07:36.970
とても近いよ｡ 

07:36.970 --> 07:42.280
このように異なるモデルのアンサンブルを実施していることは､ 改善されなければならない｡ 

07:42.490 --> 07:46.240
うーん､ でも､ ここでもっとやるべきことがあるのは明らかだ｡ 

07:46.270 --> 07:53.350
ええと､ チャートの見た目はとてもいいのですが､ インターセプトの数値が高すぎるという問題があるかもしれません｡

07:53.380 --> 07:55.240
ええと､ 何をしたかについてだけど｡ 

07:55.450 --> 08:01.930
それに､ この件で多くの時間を費やすくらいなら､ 今こそ「もう終わったことだ」と言うべきだと思う｡

08:01.930 --> 08:08.020
さて､ これにはかなりの時間を費やしたが､ アンサンブルのテクニックや他のいくつかのテクニックにはそれほど時間をかけていない｡

08:08.020 --> 08:15.700
そして､ アンサンブルを構築する際に､ より多くの項や系列を追加し､ それを線形回帰に渡すのはとても簡単なので､

08:15.700 --> 08:19.960
これを実験するのは素晴らしいことだ｡

08:19.990 --> 08:22.120
そしてこれはデータサイエンティストの夢でもある｡ 

08:22.120 --> 08:22.960
あなたはデータを持っている｡ 

08:22.990 --> 08:28.390
あなたは明確で､ 測定可能で､ 成功を決定する明確な方法を持っている｡ 

08:28.540 --> 08:34.330
ハイパーパラメーターも豊富で､ すぐに満足できる｡ 

08:34.330 --> 08:37.520
変更を加えれば､ すぐに反応を見ることができる｡ 

08:37.670 --> 08:39.920
だから君は僕よりうまくやれる｡ 

08:39.950 --> 08:41.540
これは非常にチャレンジングなことだ｡ 

08:41.540 --> 08:43.550
あなたは今､ たくさんの良いツールで武装している｡ 

08:43.550 --> 08:47.000
あなたはすでに私を打ち負かす独自のモデルを構築しているかもしれない｡ 

08:47.120 --> 08:53.720
また､ そうでなくても､ このアンサンブルのテクニックを使って前に進むことはできるはずだ｡ 

08:53.780 --> 09:00.200
それでは､ スライドに戻る前に､ このパートのラボワークを終わります｡ 

09:00.230 --> 09:08.660
ただ覚えておいてほしいのは､ 今回の主な目的は､ 必ずしも商品の値付け方法について超深入りすることではなく､

09:08.660 --> 09:15.890
ベクトル埋め込みやさまざまなモデルの実行について理解を深め､ この種の材料にかなり自信がある段階から､

09:15.890 --> 09:26.720
上級者になって超自信が持てるようになることだったということだ｡

09:26.720 --> 09:28.160
そして今､ そこにたどり着いたことを願うよ｡ 

09:28.160 --> 09:33.590
そして､ もしそうでないのなら､ このノートを見返して､ 一つひとつの細胞を調べ､ 結果を検証し､

09:33.590 --> 09:38.180
とてもとても自信が持てるまで自分自身を納得させるのだ｡

09:38.180 --> 09:41.600
では､ また次のビデオでお会いしましょう｡ 
