WEBVTT

00:00.890 --> 00:04.100
そして､ また我々の挑戦に戻ってきてくれたことを歓迎する｡ 

00:04.130 --> 00:08.000
そして今回は､ 私たちの美しいプロトタイプを使っている｡ 

00:08.060 --> 00:16.400
ええと､ 今回のデフォルトは､ 単純なπコードではなく､ Python Hardチャレンジに設定されています｡ 

00:16.400 --> 00:17.750
私たちはこれを持ち出した｡ 

00:17.750 --> 00:18.800
これだ｡ 

00:18.800 --> 00:25.910
Pythonの実行を開始し､ 約2720 8秒かかることを覚えているかもしれない｡ 

00:25.910 --> 00:27.620
だから､ しばらくここに座っていることになる｡ 

00:27.620 --> 00:34.430
その間に､ GPTを使ってコードをCプラスプラスに変換し､ それを実行するつもりだ｡ 

00:34.430 --> 00:42.200
そして､ クロードにも同じことをやって､ クロードがどう出るか､ 前回との違いがあるかどうかを見る｡

00:42.590 --> 00:44.060
もう少しだ｡ 

00:44.060 --> 00:48.080
Gradioが小さなタイマーを提供してくれるのを見ることができる｡ 

00:48.080 --> 00:49.790
だから､ 私たちはそのことを知ることになる｡ 

00:49.820 --> 00:52.070
私たちは正しい答えを得る｡ 

00:52.070 --> 00:54.530
そして約28秒かかった｡ 

00:54.560 --> 00:55.250
分かった｡ 

00:55.250 --> 00:58.370
私たちはGPTにこれをC＋＋のコードに変換するよう依頼した｡ 

00:58.370 --> 01:00.440
これがCプラスプラスのコードだ｡ 

01:00.560 --> 01:02.420
これが結果だ｡ 

01:02.420 --> 01:06.110
そして､ そのCプラスプラスのコードを実行する｡ 

01:07.820 --> 01:10.460
そして､ 以前と同じ問題を抱えている｡ 

01:10.490 --> 01:17.930
数字がオーバーフローして､ 答えがゼロになっているのだと思う｡

01:17.930 --> 01:23.870
というのも､ その答えにゼロを与える際に､ いくつかの入れ子ループも起こっていたからだ｡ 

01:23.870 --> 01:26.090
クロードがどう出るか見てみよう｡ 

01:26.090 --> 01:29.210
クロードに切り替え､ コードを変換する｡ 

01:34.850 --> 01:35.900
さあ､ 始めよう｡ 

01:39.650 --> 01:41.690
クロードが何をしたか見てみよう｡ 

01:42.560 --> 01:43.370
嗚呼！

01:44.270 --> 01:50.870
興味深いことに､ 今回のクロードはシングルループができることを確認していない｡ 

01:50.870 --> 01:54.230
そこで､ 今回はクロードから別の答えをもらった｡ 

01:54.440 --> 01:54.980
これでよし｡ 

01:55.010 --> 01:58.550
クロードのコードが実行されれば､ どうなるか見てみよう｡ 

01:58.550 --> 02:00.560
せめてCプラスを走らせよう｡ 

02:00.560 --> 02:06.470
それに､ 正しい答えを導き出したし､ 時間も0だった｡  6秒｡ 

02:06.470 --> 02:09.770
だからクロードは少なくとも正しい答えを得た｡ 

02:09.770 --> 02:12.260
だが､ 今回は違う｡ 

02:12.260 --> 02:13.730
今回はクロードと一緒に走った｡ 

02:13.730 --> 02:24.570
前回のように潰せなかったのは､ キヤノンのアルゴリズムでループを崩すチャンスを見つけられなかったからだ｡

02:24.930 --> 02:26.460
そして今､ それがこう呼ばれていることを思い出してほしい｡ 

02:26.820 --> 02:33.240
だから､ もう1回コードを変換してみて､ 2回目にうまくいくかどうか試してみよう｡ 

02:33.480 --> 02:34.350
見てみよう｡ 

02:34.350 --> 02:35.760
見てみよう､ 見てみよう｡ 

02:37.590 --> 02:39.510
1つのループのように見えるね｡ 

02:39.510 --> 02:39.870
分かった｡ 

02:39.870 --> 02:43.470
それがうまくいくかどうか､ 確かめよう｡ 

02:44.160 --> 02:45.330
うまくいったよ｡ 

02:45.330 --> 02:46.560
2度目の幸運だ｡ 

02:46.590 --> 02:47.910
2度目の幸運だ｡ 

02:47.940 --> 02:49.320
私たちは正しい答えを得る｡ 

02:49.320 --> 02:52.110
またしても息をのむような展開になった｡ 

02:52.140 --> 02:52.980
なんてことだ｡ 

02:53.010 --> 02:55.200
前回よりも全然いい｡ 

02:55.350 --> 02:59.970
明らかに､ 僕のプロセッサーで他に何が動いているかに依存している｡ 

02:59.970 --> 03:07.650
おそらく騒音レベルまで下がっているだろうが､ それは0だ｡  4ミリ秒の､ ああ､ ミリ秒の､ ああ､

03:07.650 --> 03:11.640
もう一回計算してみよう｡

03:11.640 --> 03:18.750
こういう桁違いのことが頭の中でできないのは恥ずかしいことだが､ あまりに大きくずれてしまうのが怖くてできない｡

03:18.780 --> 03:25.200
28. 3÷0. 000446.

03:25.560 --> 03:29.760
ええと､ 60,000倍以上速いんだ｡ 

03:29.760 --> 03:33.900
もちろん､ ネストされたループではなく､ 単一のループを含むアルゴリズムを発見したことを考えれば､

03:33.900 --> 03:37.560
それほど驚くべきことではないが､ それを見るのは素晴らしいことだ｡

03:37.560 --> 03:44.040
まとめると､ クロードはGPT4が失敗したところをなんとか成功させたということだ｡ 

03:44.040 --> 03:49.800
そして､ クロードは常にではないが､ 息をのむほど速い｡ 

03:49.800 --> 03:54.390
息を呑むようなことだが､ クロードも四捨五入を間違えて､

03:54.390 --> 03:59.850
クロードとGPTの4人がゼロになったことが何度かあった｡

03:59.850 --> 04:02.670
しかし､ GPTフォーゼロは一貫してその間違いを犯しているようだ｡ 

04:02.670 --> 04:12.090
そして多くの場合､ クロードはそれを正しく理解するだけでなく､ アルゴリズムを書き換えて驚異的に速くなるチャンスを見つける｡

04:12.090 --> 04:18.030
だから､ もう一度言うが､ これはクロードの勝利だ｡ 

04:18.180 --> 04:22.890
それから来週はオープンソースに切り替える予定だ｡ 

04:22.890 --> 04:25.080
オープンソースのモデルを評価するつもりだ｡ 

04:25.080 --> 04:32.040
オープンソースのモデルがどのようにコードを生成し､ オープンソースのLlmsを使ったソリューションを使うかを見ていく｡ 

04:32.040 --> 04:36.630
問題は､ オープンソースがクロードに対抗できるかどうかだ｡ 

04:36.660 --> 04:38.310
3. 5ソネット

04:38.370 --> 04:42.840
ええと､ この驚くべき速さで､ ええと､ 結果が出た｡ 

04:43.290 --> 04:44.010
ではまた
