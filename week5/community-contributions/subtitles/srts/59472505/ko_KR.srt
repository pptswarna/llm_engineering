WEBVTT

00:00.260 --> 00:05.780
좋은 소식은 이게 데이터 세트 큐레이션에 관한 마지막 영상이라는 거예요

00:05.810 --> 00:08.120
데이터 세트 큐레이션이 지겨웠을 거예요

00:08.120 --> 00:10.970
이제 하나만 더 하면 끝이에요

00:11.000 --> 00:16.370
그래서 우린 아주 훌륭한 데이터 세트를 만들었어요 아주 자랑스럽게 여겨야 하죠

00:16.370 --> 00:19.610
마지막으로 살짝 보죠

00:19.760 --> 00:23.030
궁금한 게 하나 있어요

00:23.060 --> 00:24.710
그래도 물어볼 거예요

00:24.710 --> 00:30.740
물건의 가격과 관련이 있을까요?

00:30.740 --> 00:35.570
물건의 길이에 따라 관련이 있어요

00:35.570 --> 00:41.960
가격이 높은 물건일수록 정보가 더 많은 상황을 상상할 수 있죠

00:41.960 --> 00:44.420
그걸 이해해야 해요

00:44.600 --> 00:48.170
모델에게 그런 걸 빨리 배울 수 있거든요

00:48.170 --> 00:52.730
어떻게 접근할지 전통적인 접근법을 보면 좋은 감이 오죠

00:52.730 --> 01:01.220
이건 멋진 산란도예요 엑스 축의 개별 크기를 보여줄 거예요

01:01.250 --> 01:07.970
설명의 길이를 보여줄 거예요 y축에서는 가격을 보여주고요

01:08.060 --> 01:12.350
전체 샘플 데이터 세트를 살펴보죠

01:12.740 --> 01:13.700
자, 시작하죠

01:13.700 --> 01:15.950
여기 잘 나온 사진이 있어요

01:15.950 --> 01:20.210
이 그림에는 400,000점이 있어요

01:20.360 --> 01:23.330
볼거리도 많고요

01:23.330 --> 01:26.420
보시다시피 소화할 게 많아요

01:26.450 --> 01:34.490
흥미로운 패턴이 일어나고 있어요 가격이 이런 경계선에서 더 자주 나타나죠

01:34.490 --> 01:43.370
799달러짜리 상품도 있고요 보다시피 더 저렴한 제품도 많아요

01:43.370 --> 01:52.610
분명히 상관관계가 있는 게 보이실 거예요 설명이 긴 물건들은 때때로

01:52.610 --> 01:59.480
더 비싼 물건이라는 추세를 보이는 거죠

01:59.480 --> 02:03.750
하지만 그 일과 관련해서 중요한 상관관계가 있는지는 확실하지 않아요

02:03.750 --> 02:06.750
뭔가 있긴 한데 심각한 건 아니에요

02:06.750 --> 02:12.780
전통적인 머신 러닝을 적용하면 큰 상관관계를

02:12.780 --> 02:15.270
찾지 못할 거예요

02:15.270 --> 02:21.660
일종의 다이어그램을 예로 들게요 데이터의 다양한 양상에 대한 통찰력을 얻기

02:21.660 --> 02:23.610
위한 거죠 Get it

02:24.330 --> 02:27.510
잠시 더 얘기하고 싶은 건 토큰이에요

02:27.750 --> 02:34.830
오픈 소스 모델에 대해 실제로 훈련하게 되면 Get 토큰으로 더 많이 작업할 겁니다

02:34.830 --> 02:38.640
지금 토큰을 살펴볼 가치가 있어요

02:38.640 --> 02:44.790
함수 리포트를 작성했는데 아이템을 하나 가져와서 프롬프트를 프린트합니다

02:44.790 --> 02:48.630
훈련 때 사용될 전체 훈련 프롬프트죠

02:48.630 --> 02:54.930
마지막 10개의 토큰을 프롬프트에 입력하면 디코딩이 되는 것이죠

02:54.930 --> 02:59.010
마지막 10개의 토큰까지의 행적을 볼 수 있어요

02:59.010 --> 03:02.250
왜 마지막 10개가 있는지 궁금하시다면 잠시 후에 보여드리죠

03:02.250 --> 03:08.550
무작위로 40,000번을 선택해 실행해보죠

03:08.580 --> 03:09.060
네

03:09.090 --> 03:12.840
여기 이건∙∙∙ 여기 있는 텍스트 전부 죄송해요

03:12.840 --> 03:18.390
LLM으로 보내져 배울 수 있는 프롬프트죠

03:18.630 --> 03:22.170
최대한 비용이 많이 들 거라고 할 거예요

03:22.170 --> 03:23.790
그런 다음 설명을 get 하죠

03:23.790 --> 03:30.090
가격은 이겁니다 가격은 1달러로 반올림한 거고요

03:30.180 --> 03:36.750
아이템 코드를 보시면 훈련 프롬프트를 만들 때 가장 가까운 달러로 회전하는 것을

03:36.780 --> 03:37.860
알 수 있죠

03:37.950 --> 03:44.520
마지막 10개의 토큰을 보면 어떻게 된 건지 알 수 있죠 아래에 프린트했어요

03:44.550 --> 03:46.110
그 10패는 뭐죠?

03:46.110 --> 03:53.010
이제 마지막 몇 개의 토큰을 보여드릴게요 가격은 하나의 토큰에 매핑되고

03:53.040 --> 04:02.130
워드 스페이스의 시작을 가진 토큰을 받습니다 워드의 시작과 함께 달러의 시작을 가진 토큰이죠

04:02.130 --> 04:07.410
그리고 숫자 34는 하나의 특정 토큰에 매핑되고요

04:07.680 --> 04:12.450
이건 라마 토큰라이저의 기능 중 하나예요

04:12.450 --> 04:18.000
GPT처럼 세 자리 숫자마다 토큰을 갖고 있어요

04:18.000 --> 04:21.120
다른 모델의 토큰이 그렇지 않은 경우도 있어요

04:21.210 --> 04:27.120
우리 프로젝트에 필수적인 건 아니지만 나중에 비트를 보면 좀 더 간단해질 거예요

04:27.180 --> 04:32.250
마침표는 토큰 하나와 더불어∙∙∙ 더불어∙∙∙ 0은 토큰을 받아요

04:32.280 --> 04:35.130
샘플을 하나 더 해 보죠

04:36.930 --> 04:42.000
완전히 다른 장소에서 뭔가 해 보자고요

04:42.720 --> 04:44.100
10,000번요

04:44.280 --> 04:47.550
이건 가격이 저렴해요

04:47.580 --> 04:51.930
9천 달러인데 가격이 9천 달러예요

04:51.960 --> 04:58.110
데이터셋 398,000의 끝에 있는 것으로 가보죠

04:58.620 --> 05:05.740
이건 코일오버 댐퍼 키트예요

05:05.740 --> 05:10.240
가격은 765달러예요

05:10.240 --> 05:15.430
또 한 번 765가 토큰 하나에 매핑되는 걸 보실 수 있어요

05:15.430 --> 05:22.090
이제 만족하셔야 해요 이 샘플은 가장 싼 것부터 분류했어요 각

05:22.120 --> 05:25.840
항목의 샘플을 다 살펴봤거든요

05:25.840 --> 05:28.990
가장 가까운 달러로 동그랗게 돌려요

05:28.990 --> 05:35.170
가장 싼 제품은 낮은 제품군으로 분류하고 가장 비싼 제품은 높은 제품군으로

05:35.170 --> 05:36.100
분류해요

05:36.100 --> 05:43.390
이렇게 효과를 얻는다고 만족하실 수 있습니다 1부터 999까지의 숫자는 모두 토큰 하나에

05:43.390 --> 05:46.780
매핑됩니다 여기 나와 있는 것처럼요

05:46.780 --> 05:54.190
다시 한번 말씀드리지만 수량이나 감마 혹은 피 쓰리 토큰라이저를 보면 그렇지 않다는

05:54.190 --> 05:55.870
걸 알 수 있어요

05:55.960 --> 06:02.350
나중에 비트가 좀 유용할 것 같긴 한데 꼭 필요한 건 아니고 나중엔 꼭 필요해요

06:02.350 --> 06:07.060
양자 제미니 3호 같은 다른 모델을 실험하고 싶다면 스위치만

06:07.090 --> 06:08.620
켜면 돼요

06:08.650 --> 06:15.430
여기 보면 여러 개의 토큰에 매핑되어 있습니다. 하나의 3자리 토큰이 아니라요.

06:16.690 --> 06:20.260
안도의 한숨을 내쉬네요

06:20.260 --> 06:22.630
데이터 큐레이션을 통과했어요

06:22.630 --> 06:27.460
마지막 단계는 마무리하고 허브에 업로드 하는 거죠

06:27.460 --> 06:33.520
가장 먼저 할 일은 데이터 세트를 섞는 겁니다 가장 싼 순서대로 분류하면

06:33.520 --> 06:35.710
전혀 좋지 않으니까요

06:35.710 --> 06:38.650
먼저 잘 뒤섞인 데이터 집합이 필요해요

06:38.800 --> 06:44.350
먼저 무작위 씨앗을 설정했어요 항상 정확히 같은 데이터로 작업하도록 확실히 하려고요

06:44.350 --> 06:50.230
그래야 제가 하려는 것과 정확히 같은 걸 복제해서 같은 결과를 얻을 수 있으니까요 get

06:50.260 --> 06:51.340
it

06:51.520 --> 06:59.290
랜덤을 사용해요 섞어서 섞은 다음 첫 400,000개를 훈련 데이터로 가져가요

06:59.290 --> 07:01.900
그 다음 2000년은 테스트 세트죠

07:01.930 --> 07:03.220
이제 알겠어요

07:03.250 --> 07:05.230
데이터 과학자들은 울죠

07:05.260 --> 07:11.380
보통 테스트 데이터는 최소 5%에서 10%가 필요해요

07:11.470 --> 07:16.270
얼마든지 그렇게 하셔도 돼요 여기 데이터 포인트가 8,000개

07:16.300 --> 07:17.350
있거든요

07:17.350 --> 07:21.490
더 많은 샘플을 채취해 더 큰 데이터를 얻을 수도 있죠

07:21.520 --> 07:27.310
우리한테는 필요 없을 거예요 왜냐하면 테스트에 몇백 개만 사용할 거니까요

07:27.310 --> 07:30.160
그럼 아주 정확한 결과가 나오죠

07:30.160 --> 07:34.090
계속 더 많이 시험하면 결과도 감소하죠 Get it

07:34.090 --> 07:39.340
이 프로젝트의 목적에는 충분하지만 최선의 관행이죠

07:39.370 --> 07:40.630
최선의 관행인지는 모르겠어요

07:40.660 --> 07:47.620
일반적인 관행은 적어도 5%를 테스트 데이터 집합에 비축하는 것이고 때로는 5%를

07:47.620 --> 07:52.810
테스트에 비축하고 5%를 유효성 검증에 비축하는 것이죠

07:52.870 --> 07:58.930
이 목적에는 필요 없지만 원한다면 얼마든지 할 수 있어요 관리할 추가 데이터

07:58.930 --> 08:00.880
집합으로 가질 수 있죠

08:01.030 --> 08:02.300
어쨌든 그렇게 할 거예요

08:02.300 --> 08:03.320
전부 뒤섞을 거예요

08:03.320 --> 08:08.630
훈련 데이터 400,000개와 테스트 세트 2000개로 나뉘었죠

08:08.660 --> 08:14.480
그럼 첫 번째 테스트 요소를 보죠

08:14.480 --> 08:19.640
여러분이 기억하는 테스트 프롬프트는 답을 공개하지 않은 프롬프트죠

08:19.640 --> 08:24.680
이게 전송될 프롬프트∙∙∙ 죄송합니다 훈련 프롬프트를 먼저 보고 테스트 프롬프트를

08:24.680 --> 08:25.310
보죠

08:25.340 --> 08:27.470
훈련 시기가 해답을 갖고 있어요

08:27.470 --> 08:31.310
훈련용 문자가 가장 가까운 비용으로 얼마가 드는지를 보여주죠

08:31.310 --> 08:35.120
델포이 연료 펌프 모듈이에요

08:35.390 --> 08:37.430
그리고 네

08:37.460 --> 08:37.910
어때요?

08:37.910 --> 08:39.470
227달러예요

08:39.470 --> 08:41.300
전 전혀 몰랐을 거예요

08:41.300 --> 08:47.450
이건 훈련의 일부로 LM으로 보내질 것의 예입니다 설명과

08:47.450 --> 08:50.240
가격이 포함돼 있거든요

08:50.480 --> 08:54.380
테스트 프롬프트를 보죠

08:54.410 --> 09:01.280
테스트 프롬프트는 사용될 뭔가를 보여줄 겁니다 설명은 있지만

09:01.280 --> 09:02.990
가격은 없죠

09:02.990 --> 09:07.400
이게 테스트 세트의 첫 번째 항목이에요

09:07.400 --> 09:09.350
자, 됐어요

09:09.470 --> 09:17.960
첫 250가지 테스트 포인트들의 가격 분배를 빠르게 살펴봅시다. 왜냐하면 이 포인트들은 모델

09:17.960 --> 09:22.430
테스트에 가장 많이 사용되는 포인트들이거든요.

09:22.430 --> 09:26.750
다양한 가격대가 잘 분포돼 있어요

09:26.780 --> 09:33.410
높은 영역에서는 이 모델이 비싼 물건을 다룰 수 있는지 테스트할 것들이 많아요

09:33.410 --> 09:41.360
그리고 다수가 저렴한 제품으로 테스트 데이터에 다양한 가격대가 포함되어

09:41.360 --> 09:42.530
있죠

09:43.340 --> 09:51.650
자, 마지막으로 이제 이걸 일련의 훈련과 테스트 프롬프트로 바꿀게요

09:51.650 --> 09:58.910
방금 본 테스트 프롬프트와 가격표를 뽑아내는 거죠

09:59.390 --> 10:03.590
이 코드는 포옹하는 얼굴에 업로드 돼요

10:03.620 --> 10:10.820
안는 얼굴 허브에 적합한 데이터셋 객체로 바꿀 겁니다 데이터셋에 대한 Fromex를 호출하고

10:10.820 --> 10:14.330
dataset 독감에 넣는 거죠

10:15.050 --> 10:22.940
마지막으로 이 라인은 데이터 세트를 안아주는 페이스 허브에 업로드 합니다 계속 사용하거나

10:22.940 --> 10:26.000
앞으로 다운로드 할 수 있도록요

10:26.000 --> 10:33.110
get me fine 튜닝이 끝나면요 하지만 이미 작동했으니 실행하진 않을 거예요

10:33.110 --> 10:35.300
그리고 이건 당신의 사용자이름을 입력하세요.

10:35.300 --> 10:46.100
업로드해 놨어요, 제 어, 죄송합니다 제 사용자 이름에 업로드해 놨어요

10:46.100 --> 10:51.800
그렇게 데이터를 검색할 수도 있어요

10:51.830 --> 10:55.820
이 모든 데이터 큐레이션을 합선시키고 싶다면요 그런 일은 없길 바라지만요

10:56.210 --> 11:07.230
마지막으로 이 기차를 돌려서 피클 파일로 만들어 볼게요

11:07.230 --> 11:12.270
절여서 파일에 넣을 거예요 앞으로 로드할 수 있게요 목록 작성하는

11:12.300 --> 11:16.050
이 복잡한 과정을 다시 거칠 필요가 없도록요

11:16.050 --> 11:23.520
파이썬 을 잘 아신다면 파이썬 을 파일에 덤프하는 아주 쉬운 방법이에요

11:23.520 --> 11:28.710
이제 실행하면 새 파일이 두 개 생기죠 test.pickle과 Tack.pickle이요

11:28.710 --> 11:32.340
트레이닝과 테스트 데이터 세트를 포함하죠

11:33.090 --> 11:36.900
이로써 데이터 큐레이션을 마쳤어요

11:36.900 --> 11:44.820
데이터 집합을 더 살펴보고 확인하기 위해 이 작업을 진행할 텐데요. 서로

11:44.970 --> 11:53.220
다른 데이터 포인트를 토큰화하는 작업입니다. 그러면 항상 세 자릿수가 하나의

11:53.220 --> 11:59.490
토큰으로 토큰화되고 토큰의 감각을 얻을 수 있죠.

11:59.820 --> 12:03.720
그럼 마무리로 슬라이드로 다시 만나죠
