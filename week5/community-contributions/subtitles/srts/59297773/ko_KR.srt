WEBVTT

00:00.620 --> 00:06.080
JupyterLab의 이번 세션을 기대하시기 바랍니다 드디어 벡터를

00:06.110 --> 00:07.640
직접 보게 되니까요

00:07.670 --> 00:13.220
여러분은 5주 차 폴더에 있고 3일째에 있습니다 어느 때보다

00:13.250 --> 00:15.710
저를 따라오게 될 거예요

00:15.710 --> 00:19.910
이 예제에선 시각적으로 중요하고, 실제로 어떻게 진행되는지 감을 잡을 수 있기 때문에 중요하죠.

00:19.910 --> 00:20.960
Get it.

00:20.960 --> 00:25.940
이건 전날의 복사본에 더 추가된 거예요

00:25.940 --> 00:33.380
자, 가져오기부터 시작해보죠 가져오기에 추가된 것은 우리가 다룰 특별한 기능들이고요

00:33.380 --> 00:33.920
오늘요

00:33.920 --> 00:41.960
OpenAI 엠디딩을 가져올 겁니다 랑랑 체인 OpenAI 패키지의 일부죠

00:42.230 --> 00:45.860
랑 체인 크로마를 가져올 거예요

00:46.130 --> 00:50.690
그리고 불러올 것이 몇 가지 있어요 재미있게 실제로 이 벡터들을

00:50.690 --> 00:56.180
시각화할 수 있도록요 t-SNE라는 거죠 나중에 얘기할 거예요 그리고

00:56.180 --> 00:59.720
플롯리에서는 멋진 다이어그램을 줄 거예요

00:59.720 --> 01:01.750
불러오기를 해보죠

01:02.380 --> 01:07.120
좋아요, 상수를 실행해보죠

01:07.120 --> 01:09.040
환경 변수를 불러오는 거죠

01:09.040 --> 01:11.440
이제 아주 익숙해지셨겠죠

01:11.470 --> 01:14.440
로더를 이용해 지식 기반을 실을 거예요

01:14.440 --> 01:20.920
텍스트 분할기를 이용해 덩어리를 만들 건데, 123개예요

01:20.920 --> 01:27.730
4개의 폴더 각각에 구획이 있어요 계약, 제품, 직원, 회사

01:28.300 --> 01:35.110
한 번 더 삽입과 자동 역행 LMS에 대해 상기시켜 드리고 싶네요 지금까지 코스

01:35.110 --> 01:40.030
대부분에서 자동 역행 LMS에 대해 얘기했었죠

01:40.060 --> 01:46.120
자동 인코딩 LMS를 처음으로 살펴보겠습니다 전체 입력을 가져다가 하나의 출력을

01:46.120 --> 01:49.660
생성하기 위해 사용하죠 우리 경우엔 벡터죠

01:50.140 --> 01:53.890
자동 인코딩 경보의 예가 버트죠

01:53.920 --> 01:56.380
이걸 사용할 거예요

01:56.410 --> 01:58.000
오픈아이 삽입구죠

01:58.210 --> 01:59.280
실행해 보죠

01:59.520 --> 02:00.420
네

02:00.420 --> 02:05.010
크로마 데이터 저장소를 만들 거예요

02:05.310 --> 02:10.770
여기 이 부분을 집어넣었어요 이미 있는 데이터베이스를 지우거나 비우기 위해서요

02:10.800 --> 02:15.480
그렇지 않으면 코드를 실행할 때마다 벡터가 추가됩니다. 벡터 모음이 중복되어서

02:15.480 --> 02:17.520
혼란스러워져요.

02:17.520 --> 02:20.760
데이터베이스를 새로 고침하는 데 도움이 되죠

02:20.760 --> 02:25.800
여러분이 이미 한 번 실행했다면∙∙∙ 저도 이미 한두 번 실행했다고 상상하실 수 있죠 그러니

02:25.800 --> 02:27.090
이건 제게 유용해요

02:27.360 --> 02:28.890
저희가 지울게요

02:29.400 --> 02:37.350
벡터 db 음 이 폴더에 있어요 그냥 db 이름이죠 상수예요 DB 이름이

02:37.350 --> 02:41.340
벡터 DB라고 표시해뒀어요

02:41.370 --> 02:45.480
SQLite 기반의 뭐든 될 수 있어요

02:45.510 --> 02:49.440
여길 보면 SQLite 관련 작업이 진행 중이죠

02:49.440 --> 02:55.950
여러 개의 다른 파일들이 있는 거죠 여러분이 부여하고자 선택한 데이터베이스 이름

02:55.950 --> 02:56.730
내에요

02:56.730 --> 02:58.730
이 경우엔 벡터 db죠

02:59.660 --> 03:06.170
이제 벡터 데이터베이스를 생성하고 벡터로 채울 차례군요

03:06.170 --> 03:08.930
또 다른 그러디오 순간을 보여드리죠

03:08.930 --> 03:14.870
여러분은 문서들을 벡터화하고 벡터 데이터베이스에 저장하는 프로세스가

03:14.870 --> 03:19.670
꽤나 복잡할 거라고 생각하실 수도 있습니다 적어도 여러 개의

03:19.700 --> 03:21.740
셀이 있을 거라고 말이죠

03:21.980 --> 03:27.200
물론 한 셀에서 할 수도 있고 한 줄의 코드에서도 할 수 있어요

03:27.200 --> 03:34.010
랭 체인이 접착 코드를 많이 발라서 가능했어요

03:34.040 --> 03:39.560
수동으로 하는 건 그리 어렵지 않아요 반복하기 위해서요 이런 각각의

03:39.560 --> 03:44.900
삽입을 각각의 덩크마다 벡터로 전환해 크로마에 저장하는 거죠 4,

03:44.900 --> 03:46.970
5줄이면 될 거예요

03:47.060 --> 03:50.870
이렇게 한 번에 하면 훨씬 간단해요

03:50.870 --> 03:55.490
이것과 관련해 또 다른 장점은 다른 벡터 데이터 저장소를 시도하면

03:55.490 --> 04:00.280
랭 체인에서 불러온 다른 벡터 저장소와 같은 겁니다 여러분도 시도해

04:00.280 --> 04:01.630
보세요

04:01.630 --> 04:06.700
이 라인을 실행해 볼게요 실행됐네요

04:06.700 --> 04:11.200
벡터 스토어는 123개의 문서가 만들어졌죠

04:11.200 --> 04:14.800
그 말을 들으니 안심이 되네요 덩어리 수가 123개였거든요

04:14.800 --> 04:21.040
벡터 데이터 저장소에 같은 수의 문서가 있다는 건 좋은 일이죠

04:21.520 --> 04:26.950
크롬을 생성하고 돌아온 벡터 스토어 객체를 발견할 수 있었습니다

04:26.950 --> 04:33.880
덩크와 OpenAI 엠베딩을 전달했습니다 간단하게 데이터베이스의

04:33.880 --> 04:35.860
이름을요

04:35.860 --> 04:40.060
그게 우리가 제공한 3가지예요 완전히 말이 되죠

04:40.090 --> 04:42.820
벡터 스토어를 생성하는데 필요한 건 그게 다죠

04:42.820 --> 04:50.170
벡터 스토어는 get_Cetting.Count라고 호출할 수 있습니다 벡터 스토어 내 문서의 수를

04:50.170 --> 04:51.220
얻기 위해서요

04:51.850 --> 05:04.380
벡터들의 크기가 얼마나 되는지 알아봅시다. 이것으로 컬렉션으로부터 벡터를 얻을 수 있어요.

05:04.410 --> 05:10.650
그래서 컬렉션은 이 밑줄 get을 호출하면 얻게 되는 거죠 벡터 스토어의

05:10.650 --> 05:11.640
특성

05:11.640 --> 05:14.040
그런 다음 .get을 호출하죠

05:14.070 --> 05:15.300
한계를 넘을 수 있어요

05:15.300 --> 05:16.380
우린 한 명만 원해요

05:16.380 --> 05:20.550
벡터인 내장들을 불러오길 원하죠

05:20.760 --> 05:26.490
그리고 그걸 살펴보고 얼마나 큰지 볼 거예요

05:26.490 --> 05:30.180
1536차원이에요

05:30.180 --> 05:34.920
1536개의 숫자가 이 덩어리를 이루죠

05:34.920 --> 05:38.850
우리가 직접 보죠 그냥 프린트할 수 있게요

05:38.850 --> 05:43.260
삽입 샘플을 인쇄해서 어떤지 보죠

05:43.890 --> 05:44.430
놀랍네요

05:44.430 --> 05:45.810
숫자가 많네요

05:46.080 --> 05:48.000
숫자가 많네요

05:48.030 --> 05:51.360
당신과 나에겐 무의미해요

05:51.540 --> 05:54.770
하지만 이 숫자들은 어떤 식으로든 그래요

05:55.460 --> 06:02.450
이 숫자들은 어떤 식으로든 숫자와 관련된 덩어리의 의미를 반영해요

06:02.450 --> 06:03.230
두고 봐야죠

06:03.650 --> 06:06.560
잠시 후 덩어리랑 연결시켜 보죠

06:07.370 --> 06:09.140
숫자가 엄청나요

06:09.140 --> 06:17.480
1536개의 숫자로 1536차원 공간의 좌표를 해석할 수 있어요

06:17.720 --> 06:24.830
그 좌표가 선택되면 비슷한 좌표를 가진 다른 벡터들이 벡터 공간에서

06:24.830 --> 06:28.790
비슷한 의미를 갖는 거죠

06:28.790 --> 06:30.740
그게 이 요리의 핵심이죠

06:30.980 --> 06:34.940
잠시 시각화해 보죠

06:34.940 --> 06:37.640
댓글을 없애면 좋을 것 같아요 Get it

06:37.640 --> 06:44.960
좋은 방법이 될 거예요 무대 뒤에서 무슨 일이 일어나는지 제대로 조사할 수 있는

06:44.960 --> 06:46.070
방법이죠

06:46.070 --> 06:53.320
컬렉션겟티에 전화해 메타데이터와 문서 내장 정보를 요청할 수 있어요

06:53.320 --> 06:56.320
일단 그렇게 하고 나면 벡터들을 put 할 수 있어요

06:56.320 --> 07:03.010
박아둔 것들을 벡터들의 배열에 넣을 수 있습니다. doc 타입을 doc 타입이라는 것에

07:03.010 --> 07:04.720
넣을 수 있어요.

07:04.720 --> 07:07.960
이제 색을 좀 만들어 볼게요

07:07.990 --> 07:10.300
Get it get get it 사전 작업이에요

07:10.600 --> 07:18.400
한 가지 문제가 있습니다 인간은 결점이 있는데 모든 걸 3차원 이상으로

07:18.430 --> 07:22.360
시각화하는 데 문제가 있다는 거죠

07:22.360 --> 07:27.610
1536차원으로 시각화하는 건 정말 어려운 일이에요

07:27.670 --> 07:34.360
다행히 다양한 기술을 활용할 수 있어요 하향 투사라는 걸 하는데 차원을

07:34.360 --> 07:41.290
2차원으로만 축소하는 거죠 그렇게 하면 사물을 분리하는 데 가장 효과적인

07:41.290 --> 07:47.680
방법으로 다차원적 표현에 충실할 수 있어요

07:47.680 --> 07:52.860
그래서 모든 면에서 좀 더 멀리 떨어져 있는 걸 만들려 하면 2차원으로

07:52.860 --> 07:57.780
투사했을 때도 여전히 꽤 멀리 떨어져 있을 거예요

07:58.290 --> 07:59.340
그게 목적이죠

07:59.370 --> 08:03.240
그에 대한 다양한 기술이 있지만 자세히 다루진 않겠습니다만 저희가 사용할

08:03.270 --> 08:04.710
기술은 아주 일반적인 거죠

08:04.710 --> 08:09.660
t-SNE라고 하는데 T 분산 가설 이웃 침투의 약자죠 구글에 검색하거나

08:09.660 --> 08:14.670
설명을 듣고 싶을 때 챗GPT에 물어보면 나오는 거예요

08:15.150 --> 08:19.710
통과할 때 몇 가지 차원을 원하죠?

08:19.740 --> 08:24.630
천 가지에서 2차원으로 영사하는 거죠

08:24.630 --> 08:29.790
이 무작위 상태는 무작위 씨앗을 설정하는 방식이에요 이걸 호출할 때마다 같은

08:29.790 --> 08:33.210
결과가 나와서 이걸 재생산할 수 있죠 get it

08:33.450 --> 08:41.400
그러면 감소된 벡터를 얻을 수 있습니다. t-SNE 객체에 대한 get transform 메서드를 호출하면요.

08:41.820 --> 08:49.770
이제 멋진 라이브러리 플리틀리를 이용해서 멋진 분산 도표를 만들 거예요

08:49.890 --> 08:55.570
이건 전부 일종의 코드예요 원하는 대로 복사, 붙여넣기, 재사용할 수

08:55.570 --> 08:56.170
있죠

08:56.170 --> 09:01.720
하지만 멋진 걸 했어요 마커에 다른 색을 입혔죠 다양한

09:01.720 --> 09:08.260
문서 유형에 맞춰 설정한 색에 근거해서요 팝업 텍스트도 있어요

09:08.290 --> 09:14.560
청크 자체에서 첫 100개의 글자가 조각으로 나오죠

09:14.560 --> 09:20.050
여기서 보고 싶은 건 문서가 벡터 데이터베이스에서 어떻게 보이는지 보는 거예요

09:20.050 --> 09:25.810
그런 다음 각각의 다른 벡터에 대해 어떤 종류의 문서인지에 따라 색을 입힐 거예요

09:25.810 --> 09:27.850
텍스트 위로 마우스가 떠요

09:27.850 --> 09:33.100
이 비트 조각이 나타내는 텍스트 조각을 읽을 수 있어요

09:33.100 --> 09:34.600
잘 되는지 보죠

09:34.600 --> 09:35.800
그럼 멋지겠네요

09:36.370 --> 09:37.420
당연히 알죠

09:37.420 --> 09:38.470
이미 해 봤어요

09:38.530 --> 09:39.580
여기 있네요

09:39.610 --> 09:40.420
네

09:40.420 --> 09:42.040
이게 뭐죠?

09:42.670 --> 09:50.670
다차원 벡터의 시각화를 보고 있는데 2D로 보여줍니다 엑스 축과 Y축의

09:50.670 --> 09:53.370
특별한 의미가 없어요

09:53.370 --> 09:59.100
여러 지점을 분산시킬 수 있는 최선의 방법이죠

09:59.190 --> 10:01.560
몇 가지 알아두셔야 할 게 있어요

10:01.560 --> 10:07.500
여기 보이는 녹색 점들은 직원들을 나타내요

10:07.530 --> 10:10.350
빨간 점은 뭘 의미할까요?

10:10.530 --> 10:17.730
여기서 직원이라는 건 직원 문서에서 텍스트를 잔뜩 뽑아낸다는 뜻이에요

10:17.760 --> 10:22.020
빨간 건 계약서에서 나온 텍스트 덩어리예요

10:22.050 --> 10:28.830
파란색은 제품 문서화 노란색은 어바웃 문서화예요

10:29.760 --> 10:36.900
이 시점에서 아셔야 할 마법 같은 게 있어요 OpenAI가 비트를

10:36.930 --> 10:44.850
삽입할 때 텍스트 덩어리를 벡터화할 때 문서 유형을 몰랐어요

10:44.850 --> 10:46.830
메타데이터는 말 안 했어요

10:46.830 --> 10:52.190
여름철 직원, 여름철 제품 여름철 계약에 대해 말하지 않았어요

10:52.190 --> 10:55.580
텍스트 덩어리를 주고 벡터로 바꾸라고 했죠

10:55.580 --> 10:57.500
그게 다였어요

10:57.770 --> 11:04.880
그 덩어리들을 바탕으로 보면 이 덩어리들이 벡터 공간으로 분리되어

11:04.880 --> 11:10.730
공간 내의 다른 영역을 차지하고 있어요

11:10.910 --> 11:16.070
서로 어느 정도 비슷하거든요 내용이나 의미 면에서요

11:16.070 --> 11:20.630
직원들은 모두 같은 영역에 있어요

11:20.630 --> 11:26.570
계약서는 여기 있고 제품은 여기 있어요

11:26.690 --> 11:34.820
일부 계약 정보가 제품과 같은 부근에 있는 걸 눈치채셨을

11:34.820 --> 11:37.100
거예요

11:37.100 --> 11:39.290
잠시 놀라실지도 모르겠네요

11:39.290 --> 11:41.210
뭔가 잘못된 것처럼 보일 수도 있어요

11:41.210 --> 11:48.010
이 덩어리들을 마우스로 가리키면 계약의 특정 텍스트 덩어리란 걸 알 수 있어요

11:48.010 --> 11:53.170
클라이언트가 등록한 핵심 기능을 설명하는 거죠

11:53.380 --> 11:56.260
텍스트를 입력하라고 하는 게 보이시죠

11:56.290 --> 12:02.920
죄송합니다 잠시 마우스로 가리켜보면 텍스트라는 두 번째 줄이 있는데 벡터 공간에 있는

12:02.920 --> 12:08.440
위치에 있는 덩어리를 추출한 것입니다. 하나의 인공지능으로 된 매칭을

12:08.440 --> 12:10.420
볼 수 있는데요.

12:10.660 --> 12:12.250
다른 걸 찾아보죠

12:12.610 --> 12:17.620
인공지능 위험 평가 기능이죠

12:17.800 --> 12:19.420
그게 그거죠

12:19.870 --> 12:28.420
여기서 보이는 건 계약 안에 기능성 정보 같은 게 있어요

12:28.420 --> 12:35.980
기능성 물질은 벡터 공간에 존재합니다 다른 제품과 비슷한 공간에 존재하죠

12:35.980 --> 12:38.800
이해가 되셨으면 좋겠네요

12:38.830 --> 12:46.890
다시 말씀드리지만 공간의 올바른 위치를 문서의 의미와 연결하는 건 거의 소름

12:46.920 --> 12:49.290
끼칠 정도로 잘하죠

12:49.590 --> 12:56.610
마지막으로 말씀드릴 요점은 너무 멀리 간 것일 수도 있지만 제가

12:56.610 --> 12:59.520
보기엔 이런 상황 같아요

12:59.550 --> 13:04.260
보시면 회사 관련 서류가 세 장 있어요

13:04.440 --> 13:07.380
여기 이 세 개가 중앙에 있어요

13:07.410 --> 13:10.290
여러 문서들 가운데에 있어요

13:10.290 --> 13:17.580
그건 일부 정보를 포함하고 있기 때문이라고 봅니다

13:17.580 --> 13:23.370
직원과 계약 제품과 관련된 정보요

13:23.580 --> 13:28.080
모든 것과 관련된 중심 정보 같은 거죠

13:28.080 --> 13:34.950
그래서 이 모든 게 어떤 식으로든 모든 정보의 한가운데에 있는 거죠 REST

13:35.400 --> 13:37.350
그게 참 흥미로워요

13:37.350 --> 13:41.280
내가 오버하는 걸 수도 있지만 그런 것 같아요

13:41.400 --> 13:46.730
여러분이 할 수 있는 것 중 하나는 벡터 데이터베이스에 넣고 싶은 텍스트 덩어리를

13:46.730 --> 13:48.770
실험해보는 거예요

13:48.860 --> 13:56.270
돌아가서 다른 문서를 추가할 수 있다고 상상해 보세요 여기 로드한 문서에

13:56.270 --> 13:57.080
말이죠

13:57.080 --> 14:02.360
파일을 직접 지정하거나 텍스트를 추가하거나 기존

14:02.360 --> 14:08.690
문서에 텍스트를 추가해서 벡터 공간으로 보내거나 둘 중 하나입니다.

14:08.690 --> 14:16.070
그리고 이것을 통해 오픈AI가 다른 텍스트의 의미를 이해하고 비슷한

14:16.070 --> 14:25.940
의미의 다른 것들에 가깝게 배치할 수 있다는 것을 알게 되었는데요.

14:26.060 --> 14:28.220
그게 핵심이에요

14:28.730 --> 14:33.140
이 2D 모형은 정말 멋졌어요

14:33.140 --> 14:35.420
2D 표현보다 더 좋은 게 있을까요?

14:35.450 --> 14:36.320
당연히 있죠

14:36.350 --> 14:40.040
3D 표현이 있어요 그게 다음에 할 일이죠

14:40.220 --> 14:46.160
3D로 해보죠 간단하거든요 2를 3으로 바꾸는 것만큼요

14:46.160 --> 14:51.140
그럼 3D의 이 벡터를 시각화할 수 있어요

14:51.170 --> 14:52.280
그렇게 간단하지 않았어요

14:52.310 --> 14:57.620
여기에 3D도 넣어야 했어요. 다른 벡터들도 만져야 했죠. 하지만

14:57.620 --> 14:59.480
꽤 비슷해요.

14:59.480 --> 15:02.510
타이틀도 2D에서 3D로 바꿔야 했어요

15:02.690 --> 15:04.910
어쨌든, 어떤지 보죠

15:04.910 --> 15:06.170
여기 있네요

15:06.440 --> 15:13.010
이게 벡터예요 2D에서 3D로 영사된 거죠

15:13.160 --> 15:17.990
첫 번째로 눈치챌 수 있는 건 사실 아주 드문 경우라는 거예요

15:17.990 --> 15:23.090
영화처럼 3D가 2D보다 나을 때도 있어요 비트 비트

15:23.300 --> 15:27.200
비트가 좀 뒤죽박죽인 것 같네요

15:27.200 --> 15:28.790
비트는 잘 안 보여요

15:28.820 --> 15:31.100
노란색이 가운데 있는 것처럼 보이긴 해요

15:31.220 --> 15:34.910
초록, 빨강, 파랑은 확실히 구분돼 있고요

15:34.910 --> 15:40.610
하지만 예상하셨듯이 일부 요소가 합쳐졌어요

15:40.640 --> 15:46.360
이 제품의 장점은 상호 작용적으로 놀 수 있다는 거예요

15:46.390 --> 15:48.310
이렇게 돌릴 수 있어요

15:49.060 --> 15:50.260
대단하지 않아요?

15:50.260 --> 15:55.150
이걸 이용해서 어떻게 배치됐는지 더 잘 알 수 있어요 get get get get it

15:55.150 --> 15:59.830
둘 사이에 차이가 있다는 걸 알 수 있죠

16:00.130 --> 16:07.540
하지만 2D 묘사만큼 명확하진 않은 것 같아요

16:07.630 --> 16:10.780
그래도 보기 좋아요

16:10.780 --> 16:13.900
Get up 하면 포인트 뒤에 있는 의미가 보이시죠?

16:13.900 --> 16:19.870
물론 아까처럼 노란색은 어바웃입니다 모든 것의 중간에 있는 것처럼

16:19.960 --> 16:26.410
보이죠 아까 말씀드린 것과 일치합니다 여기 이 파란색은 좀 특이하죠

16:26.800 --> 16:34.270
3D로 표현한 비트도 충분히 즐길 수 있어요 2D가 어떤 면에서는

16:34.270 --> 16:36.970
더 명확하긴 하지만요

16:37.360 --> 16:43.310
벡터 실험은 이걸로 끝났는데 중요한 게 있어요 이제 여러분에게 달렸다는 거죠 이

16:43.310 --> 16:49.010
도표를 보고 텍스트의 다양한 덩어리를 검사하는 게 아니라 자신의 텍스트 덩어리를

16:49.010 --> 16:50.930
추가하는 거예요

16:50.960 --> 16:55.970
간단한 방법은 문서를 지식 저장소에 넣는 겁니다 지식 기반 디렉터리에 말이에요 Put

16:55.970 --> 16:58.040
그렇게만 하면 바로 효과가 나타나죠

16:58.130 --> 17:04.670
텍스트 로더 클래스도 활용할 수 있어요 문서를 그냥 드롭하는 대신 랑가인 코드를 이용해 청크를

17:04.670 --> 17:06.260
추가하는 거죠

17:06.260 --> 17:12.230
하지만 덩어리들을 넣고 나면 벡터 공간에서 어디에 도달하는지 보고 어떻게 작동하는지 감을 잡으세요 Get in get in

17:12.230 --> 17:12.800
get

17:12.830 --> 17:17.480
또는 전체 지식 기반 디렉터리를 대체할 수도 있습니다 다른 것으로 이름을

17:17.480 --> 17:23.840
바꾸고 새 디렉터리를 생성해 아주 간단한 것으로 채우는 거죠 문서가 벡터 스페이스 내 다른 위치에

17:23.840 --> 17:28.430
어떻게 놓이는지 실험할 수 있도록요 Get up Get up

17:28.790 --> 17:36.500
아주 중요한 숙제예요 다음 단계에 대한 기반을 제공하거든요 실제로

17:36.500 --> 17:39.170
Get을 하는 단계요

17:39.200 --> 17:41.000
먼저 슬라이드로 돌아가죠
