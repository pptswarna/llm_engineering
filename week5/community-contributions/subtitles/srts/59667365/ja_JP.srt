WEBVTT

00:01.160 --> 00:12.980
Colabに戻り､ Colabノートの7週目､ 5日目を見ている｡

00:12.980 --> 00:18.260
今日はトレーニングではなく､ 推論をするのだから､ 必要なのはそれだけだ｡ 

00:18.590 --> 00:22.070
ええと､ トレーニングはまだこの別のタブで行われています｡ 

00:22.070 --> 00:30.890
今話しているように､ まずインストールから始めて､ それから通常のインポートをいくつかする｡

00:30.890 --> 00:34.190
そして､ ここにある定数についてお話ししましょう｡ 

00:34.340 --> 00:39.380
ええと､ ベースモデルはもちろんラマ3｡  1 プロジェクト名は､ 抱きつき顔の使い手､ プライザー｡ 

00:39.380 --> 00:41.450
だから､ ここで選んで､ 入れることができる｡ 

00:41.480 --> 00:47.480
さて､ あなたの名前を入れて､ あなたが微調整してハグハブにアップロードしたモデルに対して､ この推論､

00:47.480 --> 00:50.960
このテストを実行してくれることを願っている｡

00:51.140 --> 01:03.680
しかし､ あなたが､ あー､ 我慢の限界に達したか､ あるいは私のものがどうだったかを見たいだけという可能性もある｡

01:03.680 --> 01:06.980
だから､ このモデルとも対戦できるだろう｡ 

01:07.430 --> 01:10.460
ええと､ ここでランの名前を選択しました｡ 

01:10.460 --> 01:11.210
これはランの名前である｡ 

01:11.210 --> 01:19.220
そこにある39番は､ 私が過去に何度もエポックに走ったものの､ 抱き合わせのランネームだとお分かりになるかもしれない｡

01:19.430 --> 01:25.940
ええと､ このリビジョンは､ どのチェックポイントを選択するかを指定するところです｡ 

01:25.940 --> 01:29.720
ひどくオーバーフィットし始める前のものを選んでいる｡ 

01:29.780 --> 01:34.640
うーん､ これはまだいい､ いい結果を出している方だった｡ 

01:35.150 --> 01:39.200
そして､ これが私の微調整モデルの名前になる｡ 

01:39.200 --> 01:40.880
もちろん､ ハグ顔の名前である｡ 

01:40.880 --> 01:41.270
ごめんなさい.

01:41.270 --> 01:42.590
これを作らないといけない｡ 

01:43.190 --> 01:45.080
そうでなければ､ ここに自分の名前をハードコーディングする｡ 

01:45.080 --> 01:49.220
でも､ 私がやることは､ これの2つのバージョンを作ることだ｡ 

01:49.220 --> 01:55.340
ひとつは､ あなたがエントリーした抱きつきフェイスのユーザー用｡ 

01:59.120 --> 02:14.500
もうひとつはコメントアウトして､ 私のモデルを使う場合はこの行をコメントアウトしないようにします｡ 

02:16.810 --> 02:24.100
それから､ もしあなたが自分のモデルを使うのであれば､ ラン名とリビジョンをあなたが使っているものに合わせて変更する必要がある｡

02:24.100 --> 02:27.340
そして､ リビジョン・イコール・ノーンを入れないことから始めればいい｡ 

02:27.730 --> 02:36.610
リビジョンをまったく使わないのであれば､ リビジョン・イコール・ノーだ｡ 

02:36.610 --> 02:45.550
そして､ データセットについては......いずれにせよ､ あなたが注意深く､ 愛情を込めてキュレーションし､ Huggingfaceのハブにアップロードしたデータセットを読み込みます｡

02:45.700 --> 02:49.420
私のものを使ってもいいよ｡ 

02:49.690 --> 02:55.630
さて､ ところで､ もしあなたがこれの廉価版を使って､ 家電製品だけのモデルをトレーニングしたのであれば､

02:55.630 --> 03:01.170
もちろん､ あなたが構築した軽いデータセットと家電製品用のモデルを埋めれば､

03:01.200 --> 03:08.700
同じような結果が得られるはずです｡

03:09.630 --> 03:11.520
クオンツ・フォー・ビットは真実だ｡ 

03:11.550 --> 03:19.410
量子化し､ カラフルな線を出力する方法を覚えているだろう｡

03:19.740 --> 03:20.280
オーケー｡ 

03:20.310 --> 03:22.290
そして､ ハグをするためにログインする｡ 

03:22.680 --> 03:24.090
もう慣れただろう｡ 

03:24.240 --> 03:27.000
トレーニングをしているわけではないので､ ウェイトやバイアスに記録する必要はない｡ 

03:27.000 --> 03:29.400
そしてデータセットをロードする｡ 

03:29.400 --> 03:36.030
それに､ この時点で最初のトレーニング・データセットを見れば､ もうそれを使うことはないだろう｡

03:36.030 --> 03:38.790
しかし､ その値段は織り込み済みだ｡ 

03:38.820 --> 03:39.750
こんな感じだ｡ 

03:39.780 --> 03:44.640
もちろん､ テストデータセットを使用する｡ 

03:44.640 --> 03:46.800
本文には価格が書かれていない｡ 

03:46.800 --> 03:50.940
値段は､ モデルに与えられない答えの中にしかない｡ 

03:50.940 --> 03:54.060
この文章も与えられただけだ｡ 

03:54.090 --> 04:04.420
この予測を実際に行う部分に入ったら､ すぐにトリプルチェックをすることができますよ」｡

04:04.690 --> 04:06.010
でも､ 私たちは違う｡ 

04:06.070 --> 04:13.300
それではまず､ トークン・サイザーと微調整したモデルをロードしましょう｡ 

04:13.300 --> 04:17.110
そこでまず､ 適切な量子化を選ぶ｡ 

04:17.140 --> 04:19.180
以前と同じでおなじみだろう｡ 

04:19.210 --> 04:21.370
これも以前と同じだ｡ 

04:21.490 --> 04:22.960
まあ､ ここだけ少し違う｡ 

04:22.960 --> 04:24.460
しかし､ 我々はトークナイザーを読み込む｡ 

04:24.460 --> 04:28.540
パラメータを設定するために､ 定型文を入れたんだ｡ 

04:28.540 --> 04:33.850
先ほどと同じように､ 右クオンツのコンフィグを使ってベースモデルをロードする｡ 

04:33.880 --> 04:36.070
そして､ またあの一発ギャグが飛び出した｡ 

04:36.070 --> 04:39.280
そしてこれが新しい｡ 

04:39.280 --> 04:42.850
だから今､ 左モデルというものをロードしている｡ 

04:43.090 --> 04:46.510
覚えていれば､ パラメーターの効率的な微調整を意味する｡ 

04:46.510 --> 04:51.850
ローラをコード化したパッケージの名前だ｡ 

04:52.120 --> 04:57.850
つまり､ 左のモデルは､ ベースがあるモデルを表す抱き合わせの顔のモデルなんだ｡ 

04:57.850 --> 05:01.190
そして､ ベースの上にアダプターを装着する｡ 

05:01.760 --> 05:02.990
だから､ それを積み込むんだ｡ 

05:03.020 --> 05:05.090
今はフロンプレーンと呼んでいる｡ 

05:05.090 --> 05:11.930
そして､ 上で設定したベースモデル､ 微調整したモデル名を渡すことができる｡ 

05:11.930 --> 05:13.820
そして､ 希望があれば修正もする｡ 

05:13.820 --> 05:17.780
もしリビジョンがNULLでなければ､ それを渡す｡ 

05:17.780 --> 05:20.570
そうでなければ､ わざわざパスする必要はない｡ 

05:21.140 --> 05:26.570
そうすれば､ 微調整したモデルがロードされる｡ 

05:26.570 --> 05:28.670
そして最後に､ メモリのフットプリントを表示する｡ 

05:28.700 --> 05:35.900
メモリフットプリントが5だったことを覚えているだろうか｡  以前は6GBだったが､ 今は5GBだ｡  7.

05:35.930 --> 05:44.930
ラウラ・アダプターの100MBか109MBが追加されているから5700MBだ｡ 

05:45.020 --> 05:48.950
ローラAとローラBがそこにいる｡ 

05:49.070 --> 05:53.540
ええと､ もう一回､ この微調整されたモデルをプリントすればいいんだ｡ 

05:53.540 --> 05:56.750
この記事を書いたのは1週間前のことだ｡ 

05:56.750 --> 06:01.480
2日目､ 僕が未来を見ていると言ったのは､ 僕がこれを使っていたからなんだ｡

06:01.480 --> 06:04.120
このモデル自体は私たちが見たものだ｡ 

06:04.120 --> 06:05.620
そして､ このように見える｡ 

06:05.620 --> 06:10.630
これを覚えておくと､ ニューラルネットワークのさまざまなレイヤーをすべて見ることができ､

06:10.630 --> 06:17.830
これらのレイヤー､ つまり張力レイヤーに到達すると､ そこにドロップアウトレイヤーがあることがわかる｡

06:17.830 --> 06:20.860
今､ あなたは10％の確率でドロップアウトすることをすべて知っている｡ 

06:20.860 --> 06:25.240
それにローラAとローラBもいる｡ 

06:25.480 --> 06:34.690
ローラAとローラBは､ 適応されたすべてのレイヤー､ つまりターゲット・モジュールのものだ｡

06:34.690 --> 06:50.740
この層は､ ロジット､ つまり､ ボキャブ・トークン・ボキャブ・エントリーの可能性のある各数値を出力し､

06:50.740 --> 07:01.540
次のトークンの確率を予測するためにソフトマックスに入る｡

07:02.560 --> 07:03.670
分かった｡ 

07:04.360 --> 07:05.320
準備はできているか？

07:05.590 --> 07:09.520
だから､ 推論を実行するんだ｡ 

07:09.610 --> 07:21.100
ええと､ ええと､ もう1回､ 簡単に､ ええと､ GPT4ゼロが76ラマ3ドルになったことを覚えておいてください｡

07:21.100 --> 07:21.100
ベースモデル1台｡ 

07:21.100 --> 07:24.670
この未経験モデルは396ドルだった｡ 

07:24.670 --> 07:25.900
非常に残念だ｡ 

07:26.140 --> 07:36.370
ええと､ この人間は127を､ ええと､ 僕のエラーとして､ ええと､ ラマが人間に勝てるかどうかとても期待しているんだ｡

07:36.670 --> 07:43.090
オープンソースのモデルとして重要なのは､ 何かおかしなことを期待しているかもしれないが､

07:43.090 --> 07:51.430
物価は変動が激しいということを念頭に置いておくことだ｡

07:51.430 --> 07:57.250
ある商品が値下げされたかどうかはわからない｡

07:57.250 --> 08:04.860
そのため､ これらの製品の価格には当然大きなばらつきがある｡

08:04.860 --> 08:07.290
これは非常に難しい挑戦だ｡ 

08:07.290 --> 08:10.350
そんなに難しくないと思うかもしれない｡ 

08:10.350 --> 08:11.190
とても難しいことだ｡ 

08:11.220 --> 08:12.840
自分で試してみればわかる｡ 

08:13.320 --> 08:14.820
うーん､ わかった｡ 

08:14.970 --> 08:17.040
そのことを念頭に置いて､ 話を続けよう｡ 

08:17.040 --> 08:23.820
つまり､ 価格を抽出する関数は､ 文字列を受け取り､ 価格がドルであるかどうかを調べます｡

08:23.820 --> 08:34.410
そして､ もう一回､ それ以降のどの時点に来る数字も見つける｡

08:34.410 --> 08:47.160
値段は1ドルで､ 8ドル､ 9ドル､ 99ドルとか､ 何でもいい｡

08:47.490 --> 08:48.870
ああ､ わかってもらえたと思うよ｡ 

08:48.990 --> 08:51.060
ええと､ それが抜き取り価格なんだ｡ 

08:51.240 --> 09:01.670
それから､ これはモデル予測関数で､ 前に使った関数です｡

09:01.940 --> 09:04.460
うーん､ それはマスクに気を取られるね｡ 

09:04.460 --> 09:06.980
さっき言ったのは､ それを避けるために使うものかい？

09:06.980 --> 09:12.440
警告を投げ､ 入力プロンプトの大部分を予測する必要がないことを明確にする｡

09:12.890 --> 09:20.570
そして､ 微調整されたモデルで､ 入力を渡して､ 出力を生成する｡ 

09:20.600 --> 09:29.270
このアテンション・マスクを渡すと､ 新しいトークンは3つまでしか必要ない｡

09:29.270 --> 09:33.530
でも､ 万が一､ ひどいミスをしたときに､

09:33.560 --> 09:40.700
そのミスを捕捉できるように､ もう少し入れておく｡

09:41.150 --> 09:46.580
さて､ たまたまだが､ 私たちはこの予測関数よりもう少し良いものを作ることができる｡ 

09:46.580 --> 09:48.770
これはまったく大きな違いではない｡ 

09:48.770 --> 09:58.010
しかし､ しかし､ このモデルをこれだけコントロールできるようになったのだから､ 次のトークンの扱い方をもう少しスマートにすることができる｡

09:58.010 --> 09:59.720
それで､ この関数を書いたんだ｡ 

09:59.720 --> 10:02.150
これは改良されたモデル予測機能だ｡ 

10:02.150 --> 10:06.320
改善されたモデルは......うーん､ そうだね｡ 

10:06.350 --> 10:09.110
ただ､ もう少し複雑なんだ｡ 

10:09.290 --> 10:18.230
だから､ ええと､ ええと､ 簡単に説明するけど､ 超重要なことではないんだ｡ 

10:18.230 --> 10:27.260
次のトークンの中から最も可能性の高いものを選ぶのではなく､ 次のトークンの中から最も可能性の高い3つのトークンを選ぶのだ｡

10:27.500 --> 10:30.830
そして､ この3つの確率は？

10:30.830 --> 10:32.390
そしてそれらは実数を表している｡ 

10:32.390 --> 10:42.050
例えば､ 100ドルの価値がある可能性が非常に高く､ 99ドルの可能性は少し低いが､ 101ドルの可能性はかなり高いと言ったかもしれない｡

10:42.230 --> 10:43.760
しかし､ 100が最高だった｡ 

10:43.850 --> 10:47.060
そして､ これら3つの数値の加重平均を取る｡ 

10:47.060 --> 10:52.310
そしてそれは､ 何を予測しようとしているのかをもう少し正確に知るための方法なんだ｡ 

10:52.490 --> 10:57.770
そして､ 必ずしも整数ではない何かを予測することができる｡ 

10:58.000 --> 11:01.480
僕が使ってきたテクニックなんだ｡ 

11:01.480 --> 11:07.300
回帰問題を分類問題として扱っているという事実を解決するようなものだ｡

11:07.360 --> 11:13.420
これを知っていることは超重要ではないが､ しかし､ 上記の関数を使っても大差はない｡

11:13.450 --> 11:14.800
ちょっとした違いだ｡ 

11:15.010 --> 11:20.260
しかし､ ニューラルネットワークの最後の層に興味があるのであれば､

11:20.290 --> 11:27.670
これに目を通す価値があるかもしれません｡ なぜなら､ 私がしていることは､ 入力に渡す微調整モデルの出力を取ることであり､

11:27.670 --> 11:38.860
これらはトークナイザーの可能な語彙エントリすべてにわたって､ このベクトルで述べたロジットとみなされるからです｡

11:38.860 --> 11:43.180
そして､ それを確率に変換するためにソフトマックスを呼び出す｡ 

11:43.180 --> 11:46.270
そして､ トップ3を通過する｡ 

11:46.270 --> 11:51.490
そして､ これは上位3人の加重平均を取っただけのものだ｡ 

11:51.610 --> 11:54.400
これは加重価格であり､ 加重価格を合計したものである｡ 

11:54.400 --> 11:56.050
そして､ それが返ってくる｡ 

11:56.050 --> 11:58.660
だから､ モデル予測にとても似ている｡ 

11:58.660 --> 12:05.260
ただ､ 一番上の予想だけでなく､ 上位3つの予想に基づいた､ 少し正確な答えを出すだけだ｡

12:05.890 --> 12:09.100
ええと､ それでクラスのテスターがいるんだ｡ 

12:09.100 --> 12:12.700
これは以前使ったのとまったく同じテスター・クラスだ｡ 

12:12.940 --> 12:21.250
ええと､ その前に申し上げたこと､ これは明らかに全体の核心であることを指摘しておく価値がある｡

12:21.250 --> 12:28.780
渡された関数を呼び出すと､ 渡されたのはデータ・ポイントに関連するテキストだけである｡

12:28.810 --> 12:30.730
当然､ 値段は言わない｡ 

12:30.730 --> 12:35.800
知っているのはテキストだけで､ 価格については何も知らない｡ 

12:35.800 --> 12:37.330
もちろんだ｡ 

12:37.720 --> 12:45.610
そして､ 改良された関数を使用するテストを呼び､ テストに合格すると､

12:45.610 --> 12:57.070
ある種のソープオペラのように､ 次のビデオでこの結果をお伝えします｡

12:57.100 --> 12:58.540
そこで会おう｡ 
