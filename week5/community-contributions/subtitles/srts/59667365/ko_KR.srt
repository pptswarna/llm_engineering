WEBVTT

00:01.160 --> 00:10.100
콜랍에 돌아왔어요 콜랍 공책 대회 7주 차 5일째예요 T4 박스에 탔는데

00:10.100 --> 00:12.980
저렴한 싸구려 박스죠

00:12.980 --> 00:18.260
훈련이 아니라 추론하는 거니까 그것만 하면 돼요

00:18.590 --> 00:22.070
아니면 훈련이 다른 탭에서 진행되거나요

00:22.070 --> 00:30.890
말씀드리는 순간 설치 몇 개로 시작해서 늘 하던 대로 가져오기로 했어요

00:30.890 --> 00:34.190
여기 있는 상수에 대해 말씀드릴게요

00:34.340 --> 00:39.380
기본 모델은 라마 3이고요 프로젝트 이름은 포옹하는 얼굴 사용자 프리저예요

00:39.380 --> 00:41.450
여기서 선택해 put in을 해요

00:41.480 --> 00:47.480
여러분의 이름을 입력하고 모델에 대한 추론과 테스트를 실행해 주세요 여러분이

00:47.480 --> 00:50.960
잘 조율해서 Hub에 업로드한 모델이죠

00:51.140 --> 00:58.730
하지만 인내심을 잃으셨거나 제 테스트 결과가 궁금하신 거라면 제 이름은

00:58.730 --> 01:03.680
그대로 두셔도 돼요 이 모델은 공개될 테니까요

01:03.680 --> 01:06.980
이 모델에 맞서 달릴 수 있어요

01:07.430 --> 01:10.460
그리고 실행 이름을 선택했어요

01:10.460 --> 01:11.210
이게 실행명이에요

01:11.210 --> 01:17.750
39가 뭔지 아실 겁니다 제가 과거에 여러 개국 시대에 사용한 포옹의

01:17.780 --> 01:19.220
연계명이죠

01:19.430 --> 01:25.940
이 수정본은 제가 어떤 체크포인트를 선택할지 지정하는 곳이죠

01:25.940 --> 01:29.720
너무 과해지기 전에 골라야 해요

01:29.780 --> 01:34.640
이 영화는 여전히 좋은 결과가 나오고 있었어요

01:35.150 --> 01:39.200
그리고 이게 제 미세 튜닝 모델의 이름이 되죠

01:39.200 --> 01:40.880
당연히 포옹하는 얼굴 이름이죠

01:40.880 --> 01:41.270
미안해요

01:41.270 --> 01:42.590
이걸 만들어야겠어요

01:43.190 --> 01:45.080
안 그러면 제 이름을 하드 코딩해야 해요

01:45.080 --> 01:49.220
하지만 전 두 가지 버전을 만들 거예요

01:49.220 --> 01:55.340
하나는 여러분이 입력한 포옹 얼굴 유저예요

01:59.120 --> 02:14.500
다른 건 주석 처리로 이 라인을 주석 처리 해제하라고 하죠 제 모델을 사용한다면요

02:16.810 --> 02:22.000
물론 모델을 사용한다면 실행명과 개정도 바꿔야 합니다 여러분이 사용하는

02:22.000 --> 02:24.100
것에 맞추기 위해서요

02:24.100 --> 02:27.340
for reision = 0을 입력하지 않는 것부터 시작하세요

02:27.730 --> 02:36.610
수정 = 0일 수도 있고요 수정 을 사용하지 않는다면 말이죠

02:36.610 --> 02:43.120
그리고 데이터 세트에서는 여러분이 정성껏 정리해서 업로드한 데이터 세트를 다시 로드합니다

02:43.120 --> 02:45.550
허깅페이스 허브에 말이죠

02:45.700 --> 02:49.420
아니면 제 걸 쓰셔도 돼요

02:49.690 --> 02:55.630
음, 그런데 만약 이것의 저비용 버전을 선택하고 가전제품 전용

02:55.630 --> 03:01.170
가전제품 모델을 훈련시켰다면 당연히 여러분이 구축한 라이트

03:01.200 --> 03:08.700
데이터 세트와 가전제품 모델을 채워야 합니다 그럼 비슷한 결과가 나오죠

03:09.630 --> 03:11.520
비트라는 퀀트는 진실이에요

03:11.550 --> 03:18.000
수량화하는 거죠 기억하실지 모르겠지만 색색의 선을 출력하는 좋은

03:18.000 --> 03:19.410
방법들이에요

03:19.740 --> 03:20.280
네

03:20.310 --> 03:22.290
얼굴 포옹에 로그인해요

03:22.680 --> 03:24.090
이제 익숙해졌잖아요

03:24.240 --> 03:27.000
훈련이 아니니까 무게나 편향에 로그인할 필요 없어요

03:27.000 --> 03:29.400
그런 다음 데이터 세트를 로드하죠

03:29.400 --> 03:35.280
그리고 지금 이 시점에서 첫 번째 훈련 데이터 세트를 보면 더는 사용하지 않을

03:35.280 --> 03:36.030
거예요

03:36.030 --> 03:38.790
하지만 가격이 들어 있어요

03:38.820 --> 03:39.750
이렇게 생겼어요

03:39.780 --> 03:44.640
물론 테스트 데이터 세트를 사용할 겁니다 이렇게 생겼죠

03:44.640 --> 03:46.800
텍스트에는 가격이 없어요

03:46.800 --> 03:50.940
가격은 모델에 없는 답안에만 달려 있어요

03:50.940 --> 03:54.060
이 문장만 있어요

03:54.090 --> 03:59.850
비트 박스를 만들 때 다시 한번 확인해 주세요 비트 박스를 만들 때

04:00.490 --> 04:04.420
가격표를 실수로 넘기면 실수가 되겠죠?

04:04.690 --> 04:06.010
하지만 우린 아니죠

04:06.070 --> 04:13.300
좋아요, 그럼 먼저 토큰라이저와 미세 튜닝 모델을 로드할게요

04:13.300 --> 04:17.110
먼저 올바른 양자화를 선택해요

04:17.140 --> 04:19.180
예전과 같은 방식이죠

04:19.210 --> 04:21.370
이것도 예전과 똑같아요

04:21.490 --> 04:22.960
여기만 살짝 달라요

04:22.960 --> 04:24.460
토큰이저도 설치했어요

04:24.460 --> 04:28.540
매개 변수를 설정하기 위해 상용 문서를 넣었어요.

04:28.540 --> 04:33.850
올바른 퀀트 구성을 사용하기 전처럼 베이스 모델을 로드하죠

04:33.880 --> 04:36.070
또 한 줄짜리 대사가 나왔네요

04:36.070 --> 04:39.280
이건 새로운 거예요

04:39.280 --> 04:42.850
이제 왼쪽 모델이라는 걸 로드하고 있어요

04:43.090 --> 04:46.510
매개 변수 효율 미세 조정의 약자란 걸 기억하세요

04:46.510 --> 04:51.850
로라를 암호화한 상자 이름이에요

04:52.120 --> 04:57.850
왼쪽 모델은 안아주는 얼굴 모델이고 베이스 모델을 나타내요

04:57.850 --> 05:01.190
밑부분에는 어댑터가 달려 있어요

05:01.760 --> 05:02.990
이걸 로딩할 거예요

05:03.020 --> 05:05.090
Frompretled이라고 부르는군요

05:05.090 --> 05:11.930
그리고 위에서 설정한 미세 튜닝 모델 이름을 베이스 모델로 넘길 수 있어요

05:11.930 --> 05:13.820
원하시면 복습도 가능해요

05:13.820 --> 05:17.780
수정값이 0이 아니면 넘기는 거죠

05:17.780 --> 05:20.570
안 그러면 전달할 필요가 없죠

05:21.140 --> 05:26.570
미세 튜닝 모델에 로드될 거예요

05:26.570 --> 05:28.670
마지막에 메모리 발자국을 프린트할 거예요

05:28.700 --> 05:35.900
메모리 발자국이 5개였던 거 기억하시죠? 전에는 6GB였는데 지금은 5GB예요 7시요

05:35.930 --> 05:44.930
5700MB인 이유는 로라 어댑터가 100이나 109MB 더 있기 때문이죠

05:45.020 --> 05:48.950
로라 A와 로라 B가 있어요

05:49.070 --> 05:53.540
미세 튜닝 모델로 한 번 더 프린트할게요

05:53.540 --> 05:56.750
기억하실지 모르겠지만 주중에 이걸 했어요

05:56.750 --> 06:01.480
둘째 날, 제가 미래를 보고 있다고 했죠 이걸 사용하고 있었거든요

06:01.480 --> 06:04.120
이 모형은 우리가 봤던 거예요

06:04.120 --> 06:05.620
이렇게 보이죠

06:05.620 --> 06:10.630
이걸 기억하시면 신경망의 다양한 층이 보입니다

06:10.630 --> 06:17.830
여기 장력 층을 보면 드롭아웃 층이 있어요 Get up

06:17.830 --> 06:20.860
자퇴 확률 10%에 대해 잘 아시죠?

06:20.860 --> 06:25.240
로라 A와 로라 B도 있어요

06:25.480 --> 06:33.190
로라 A와 로라 B는 각 층을 나타내는 거예요 우리의 목표

06:33.220 --> 06:34.690
모듈이죠

06:34.690 --> 06:41.230
그리고 여기 끝에 LM헤드도 주목해 주세요. 방금 이야기

06:41.260 --> 06:50.740
했듯이 완전히 연결된 마지막 레이어에서 로지트와 가능한 보캡 토큰 보캡 항목의

06:50.740 --> 06:58.630
숫자를 출력합니다. 그리고 소프트맥스로 가서 다음 토큰의 가능성을

06:58.630 --> 07:01.540
예측하죠.

07:02.560 --> 07:03.670
좋아요

07:04.360 --> 07:05.320
준비됐어요?

07:05.590 --> 07:09.520
그래서 추론을 실행할 거예요

07:09.610 --> 07:18.280
한 번 더 빠르게 설명하고 싶은데요 GPT 40이 76 라마 3으로 바뀌었다는

07:18.310 --> 07:21.100
메모리를요 기본 모델 1개요

07:21.100 --> 07:24.670
이 미숙련 모델은 396달러였어요

07:24.670 --> 07:25.900
정말 실망스럽네요

07:26.140 --> 07:34.450
여기 이 사람은 제 오류로 127점을 받았어요 라마가 사람을 이길 수 있는지

07:34.480 --> 07:36.370
보고 싶어요

07:36.670 --> 07:43.090
오픈 소스 모델로서 명심해야 할 점은 여러분이 여기서 터무니없는 걸 기대하실까

07:43.090 --> 07:51.430
봐 말씀드리는데 가격이 많이 변동될 수 있는데 모델은 그에 대해 아무것도 몰라요

07:51.430 --> 07:57.250
제품 가격이 급락했는지도 알 수 없습니다. 엄청난 가격으로 판매되고 있으니까요.

07:57.250 --> 08:02.370
제품 가격에는 자연적으로 큰 차이가 있어요 제가 직접 만들어

08:02.370 --> 08:04.860
보려 했을 때 알게 된 사실이죠

08:04.860 --> 08:07.290
이건 아주 어려운 과제예요

08:07.290 --> 08:10.350
별로 어렵지 않다고 생각할 수도 있어요

08:10.350 --> 08:11.190
정말 힘들어요

08:11.220 --> 08:12.840
직접 해 보면 알 거예요

08:13.320 --> 08:14.820
네

08:14.970 --> 08:17.040
그 점을 명심하고 계속하죠

08:17.040 --> 08:23.820
가격 추출 함수는 아시다시피 문자열이 있죠 가격 이즈 달러를 찾아요

08:23.820 --> 08:30.600
그 다음에 나오는 숫자를 한 번 더 찾아보죠 스스로 만족하도록 가격을

08:30.630 --> 08:34.410
추출해 문자열을 만들어보죠.

08:34.410 --> 08:47.160
가격은 달러입니다 아주 멋진 달러죠 8, 9, 99, 그쯤 돼요 제가 말하고 싶은 대로 가격을 말하죠

08:47.490 --> 08:48.870
I'm get you're know

08:48.990 --> 08:51.060
이게 추출가예요

08:51.240 --> 08:59.540
그리고 이건 모델 예측 함수입니다 전에 사용했던 함수로

08:59.540 --> 09:01.670
입력을 받죠

09:01.940 --> 09:04.460
그건 관심 마스크를 쓴 거죠

09:04.460 --> 09:06.980
혹시 제가 말씀드린 그거 피하시는 거예요?

09:06.980 --> 09:11.690
입력 프롬프트를 예측하기 위해 필요한 것은 아니라는 것을 확실히 하기 위해 경고를

09:11.690 --> 09:12.440
던지죠

09:12.890 --> 09:20.570
미세 조정 모델에서 발생하는 출력은 입력값을 전달하죠

09:20.600 --> 09:26.600
주의 마스크를 통과시킵니다. 새로운 토큰 세 개만 있으면 됩니다. 왜냐하면 다음 토큰은 우리가 정말

09:26.600 --> 09:29.270
중요하게 생각하는 것이기 때문이죠.

09:29.270 --> 09:33.530
하지만 만약 끔찍한 실수를 저지르면 그걸 포착하기 위해 몇

09:33.560 --> 09:39.050
가지 더 입력할 거예요 그리고 답변을 하나만 받아내죠 그 답변 하나만 받아내서

09:39.050 --> 09:40.700
가격을 추출해요

09:41.150 --> 09:46.580
비트만 있으면 이 예측 함수보다 좀 더 잘할 수 있어요

09:46.580 --> 09:48.770
큰 차이는 없어요

09:48.770 --> 09:54.080
하지만 이 모델에 대한 컨트롤이 아주 많기 때문에 다음 토큰을 다루는

09:54.110 --> 09:58.010
방법에 대해 좀 더 현명한 비트를 할 수 있어요

09:58.010 --> 09:59.720
그래서 이 함수를 작성했어요

09:59.720 --> 10:02.150
향상된 모델 예측 함수죠

10:02.150 --> 10:06.320
향상된 모델 예측 결과 네

10:06.350 --> 10:09.110
비트가 좀 더 복잡해요

10:09.290 --> 10:18.230
그러니까 간단히 설명할게요 하지만 그렇게 중요한 건 아니에요

10:18.230 --> 10:24.290
가장 가능성이 높은 다음 토큰이 아니라 가장 가능성이 높은

10:24.290 --> 10:27.260
세 개의 토큰을 취하는 거죠

10:27.500 --> 10:30.830
이 세 가지의 확률은 어떻게 나왔나요?

10:30.830 --> 10:32.390
실제 숫자를 나타내죠

10:32.390 --> 10:39.530
가령, 비트 상자가 100달러쯤 되고 99$보다는 조금 적고 101$쯤

10:39.530 --> 10:42.050
될 거라고 했죠

10:42.230 --> 10:43.760
근데 100이 제일 높았어요

10:43.850 --> 10:47.060
그런 다음 그 세 숫자 사이에 가중된 평균을 얻어요

10:47.060 --> 10:52.310
비트가 뭘 예측하려 하는지 좀 더 정확하게 알아낼 수 있는 방법이죠

10:52.490 --> 10:57.770
그리고 항상 숫자가 전부인 건 아니지만 예측할 수 있게 해주죠

10:58.000 --> 11:01.480
제가 사용한 기술이에요

11:01.480 --> 11:06.520
분류 문제로서 퇴행 문제를 치료하고 있다는 사실을 해결하는

11:06.520 --> 11:07.300
거죠

11:07.360 --> 11:11.950
이걸 아는 게 그리 중요하진 않지만 위의 함수를 사용한다고 크게

11:11.950 --> 11:13.420
달라지진 않아요

11:13.450 --> 11:14.800
비트가 약간 달라요

11:15.010 --> 11:20.260
신경망의 마지막 계층에 관심이 있다면 한 번 살펴보는

11:20.290 --> 11:27.670
게 좋을 것 같습니다. 왜냐하면 미세하게 조정한 모델이 입력을 통과하면

11:27.670 --> 11:37.150
출력을 얻고 이것들은 로그잇으로 간주됩니다. 토큰라이저의 가능한 어휘 엔트리에 걸쳐 있는

11:37.210 --> 11:38.860
벡터죠.

11:38.860 --> 11:43.180
그런 다음 소프트맥스를 호출해 확률로 전환하죠

11:43.180 --> 11:46.270
그리고 상위 3인에 들죠

11:46.270 --> 11:51.490
그리고 이 검프라는 게 상위 3위의 평균을 가늠하는 거예요

11:51.610 --> 11:54.400
가격도 중대하고 가격도 중대해요

11:54.400 --> 11:56.050
그게 반환되죠

11:56.050 --> 11:58.660
모델 예측과 아주 유사하죠

11:58.660 --> 12:03.940
좀 더 정확한 답을 제공할 뿐이죠 최고의 예측이 아니라 상위 3개 예측에

12:03.940 --> 12:05.260
근거해서요

12:05.890 --> 12:09.100
그리고 우리 반 테스터도 있어요

12:09.100 --> 12:12.700
이건 우리가 전에 사용했던 테스터 클래스와 정확히 같아요

12:12.940 --> 12:19.450
제가 전에 언급했던 것을 짚고 넘어가야 할 것 같아요 이게 전체의

12:19.450 --> 12:21.250
핵심이에요

12:21.250 --> 12:28.780
통과한 함수를 취하고 호출할 때 통과하는 건 데이터 포인트와 관련된 텍스트예요

12:28.810 --> 12:30.730
가격은 당연히 안 알려줘요

12:30.730 --> 12:35.800
문자만 알고 있어서 가격은 전혀 몰라요

12:35.800 --> 12:37.330
네, 물론이죠

12:37.720 --> 12:45.610
그런 다음 테스트를 호출하죠 개선된 함수를 사용해서요 테스트를

12:45.610 --> 12:53.710
통과합니다 드라마 같죠 다음 비디오에서 결과를 알려드리죠 get

12:53.710 --> 12:57.070
it get it

12:57.100 --> 12:58.540
거기서 봐요
