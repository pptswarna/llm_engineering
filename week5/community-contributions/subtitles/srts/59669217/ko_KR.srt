WEBVTT

00:00.530 --> 00:04.220
데이터 시각화의 다음 단계에 오신 걸 환영해요

00:04.220 --> 00:06.500
재빨리 3D로 보여드릴 수 있죠

00:06.530 --> 00:12.350
그 거대한 부지를 없애고 다시 켜고 나서도 제 상자는 무사했어요

00:12.380 --> 00:16.250
제 방식을 따라 하지 않으셨길 바라요 하지만 더 현명하게 선택하셨네요

00:16.280 --> 00:25.730
어쨌든 3D로 시각화해 보겠습니다 텍스트의 벡터 삽입이 어떤 의미인지 이해하기

00:25.730 --> 00:28.250
위해서요 get it

00:28.490 --> 00:34.070
이번에는 좀 더 합리적인 10,000를 택했어요 지루하고 특이하죠

00:34.070 --> 00:41.450
코드는 전에 Rag에서 했던 것과 같아요 Plotly 라이브러리를 이용해 다시 산란

00:41.450 --> 00:43.250
플롯을 생성하죠

00:43.250 --> 00:47.660
3D 시각화로 보면 이런 모습이에요

00:47.690 --> 00:52.160
줌인과 아웃을 막기는 어렵지만 어쨌든 됐네요

00:52.280 --> 00:58.700
전에 비트를 봤을 때처럼 훨씬 작은 벡터 데이터 공간을 보면

00:58.700 --> 01:02.780
이렇게 멀리서 보면 좀 이상해 보여요

01:02.780 --> 01:10.340
하지만 회전시키고 상호 작용해보면 3D의 진가를 확실히 알게 될 겁니다 관련 제품을

01:10.340 --> 01:17.900
나타내는 클러스터가 어떻게 있는지 말이에요 Get in get get it

01:17.930 --> 01:20.060
전에 사용한 코드를 복사할 수 있어요

01:20.060 --> 01:22.940
원한다면 각각의 텍스트를 get으로 출력할 수 있어요.

01:22.940 --> 01:25.790
메모리를 더 쓰게 될 텐데 그래도 괜찮아요

01:25.940 --> 01:31.760
데이터는 비슷한 것들이 서로 가깝게 표현된다는 점에서 스스로 만족할 수

01:31.760 --> 01:33.440
있는 멋진 방법이죠

01:33.440 --> 01:35.810
그게 정말 중요한 부분이죠

01:35.810 --> 01:41.510
그리고 보라색 점이 주류에서 벗어난 이유를 알게 될 거예요 Get

01:41.510 --> 01:42.350
it

01:42.380 --> 01:44.150
그게 정말 도움이 돼요

01:44.150 --> 01:54.050
이건 직관을 키우기 위한 연습에 가까워요 훨씬 많은 문서에 대한 래그의 규모를 키워도

01:54.050 --> 02:00.170
같은 규칙이 적용되고 데이터를 시각화하고 실험할 수

02:00.170 --> 02:03.860
있다는 걸 보여주기 위해서요

02:04.160 --> 02:07.280
벡터 데이터 저장소 얘기는 충분히 들었어요

02:07.280 --> 02:13.010
이제 래그 파이프라인을 구축해서 비슷한 제품을 이용해 제품 가격을 추정할 때예요

02:13.010 --> 02:14.240
Get it, get it 해 보죠
