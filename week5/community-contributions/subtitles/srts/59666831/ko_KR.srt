WEBVTT

00:00.890 --> 00:07.700
잠시 시간을 내서 이 멋진 도표를 보세요 모든 걸 배치한 거죠 그런 다음 넘어가죠

00:07.700 --> 00:10.970
이제 제가 말씀드리고 싶었던 세부적인 부분으로 넘어가죠

00:10.970 --> 00:18.470
제가 비트를 좀 느슨하게 표현했는데요 모델이 다음 토큰을 예측한다고 했었죠 그렇게 생각할

00:18.470 --> 00:19.970
수도 있겠네요

00:20.000 --> 00:21.200
간단하게 생각해 보죠

00:21.200 --> 00:25.730
종종 그런 표현을 쓰지만 실제로는 그렇지 않아요

00:25.730 --> 00:30.800
변압기 구조가 있는 것도 아니고 맨 아래 계층에서 나오는 건 단일 토큰이

00:30.800 --> 00:33.560
아니죠 예측 가능한 다음 토큰이요

00:33.800 --> 00:35.390
그렇게 되는 게 아니에요

00:35.390 --> 00:40.310
마지막 층에서 나오는 건 확률이에요

00:40.310 --> 00:44.390
모든 토큰을 갖고 있고 그 모든 토큰에 대해 알고 있죠

00:44.390 --> 00:48.080
그게 다음 토큰이 될 확률은 얼마나 될까요?

00:48.080 --> 00:52.130
일련의 확률을 내놓죠

00:52.160 --> 00:54.920
신경망 아래에서 나오는 거예요

00:55.100 --> 01:00.410
프린트할 때 마지막으로 봤던 레이어가 있었죠

01:00.410 --> 01:02.640
LM 헤드라는 모델이에요

01:02.700 --> 01:06.420
그게 가장 마지막 단계예요

01:06.420 --> 01:11.310
숫자의 벡터인 로그잇을 가지고 나타납니다 확률을 나타내는

01:11.310 --> 01:12.810
것들이죠

01:12.840 --> 01:14.970
그걸 함수에 넣어야 해요 Put it up

01:15.090 --> 01:19.260
너무 자세하게 설명하는 것 같지만 이미 알고 계실지도 몰라요

01:19.260 --> 01:25.680
소프트맥스라는 함수가 있는데 이 숫자들을 확률로 변환할 수 있습니다 각각의

01:25.680 --> 01:31.650
토큰은 0에서 1 사이일 것이고 그 다합이 1이기 때문이죠

01:31.680 --> 01:39.540
따라서 모델의 결과를 가능한 다음 토큰의 확률로 해석할 수 있는 방법을 제공하죠

01:39.540 --> 01:43.710
이게 포워드 패스에서 나오는 거예요

01:44.130 --> 01:50.370
추론 모드에서 이걸 실행하면 get-ference 모드에서 얻는 건

01:50.370 --> 01:52.080
이 모든 확률이에요

01:52.080 --> 01:52.980
이걸로 뭘 할 수 있을까요?

01:53.010 --> 01:55.530
다음 토큰이 뭘 예언하는지 어떻게 알죠?

01:55.530 --> 01:58.080
대부분은 아주 간단한 접근법이에요

01:58.080 --> 02:00.600
가장 가능성이 높은 토큰을 선택하면 돼요

02:00.600 --> 02:02.820
가능성이 높은 토큰을 선택하세요

02:02.850 --> 02:04.450
개연성이 아주 다양해요

02:04.480 --> 02:06.130
누가 최대인지 알아봐요

02:06.130 --> 02:07.750
다음 글자는 이거로 해요

02:07.780 --> 02:10.840
좀 더 세련된 비트도 있어요

02:10.840 --> 02:16.720
이런 확률을 체중으로 삼아 무작위로 샘플을 채취할 수 있어요

02:16.780 --> 02:18.550
비트가 좀 더 다양해지죠

02:18.700 --> 02:24.520
몇 개의 글자를 연속해서 샘플링할 수 있는 다른 기술도 있어요 그리고 그 경로를

02:24.520 --> 02:25.900
선택할 수 있죠

02:25.900 --> 02:32.290
추론할 때 다양한 전략을 쓸 수 있어요 이런 확률을 바탕으로 최선의 결과를

02:32.290 --> 02:33.490
낼 수 있죠

02:33.490 --> 02:39.220
잠시 후 우리 프로젝트를 보면 약간 비표준 전략을 사용할

02:39.220 --> 02:45.940
겁니다 각각의 토큰은 비용, 숫자를 나타내니까요

02:45.940 --> 02:50.440
비트를 좀 더 영리하게 바꿀 수도 있지만 그럴 필요는 없어요

02:50.440 --> 02:54.130
아니면 가장 가능성이 높은 걸 선택해도 되고요

02:54.340 --> 02:57.550
모델 출력이 잘 설명했고요

02:57.580 --> 02:59.470
이제 확실히 아셨길 바라요

02:59.680 --> 03:02.050
그리고 상실 함수요

03:02.050 --> 03:04.330
지난 영상에서는 살짝 얼버무렸어요

03:04.360 --> 03:05.840
손해 보는 것도 모르시네요

03:05.840 --> 03:07.550
얼마나 심각했어요?

03:07.550 --> 03:09.950
실제론 어떤 의미일까요?

03:09.980 --> 03:11.990
놀랍도록 간단해요

03:11.990 --> 03:15.890
가능한 다음 토큰의 모든 가능성을 갖고 있죠

03:16.010 --> 03:21.200
그래서 다음 토큰이 무엇이었는지 알고 있다고 하는 거죠

03:21.290 --> 03:23.690
99개라고 가정해 보죠

03:23.690 --> 03:30.740
이 모든 확률을 살펴보고 모델에서 99의 확률을 계산해 올바른 다음 토큰이

03:30.740 --> 03:33.350
무엇인지 알아내는 거죠

03:33.350 --> 03:34.790
그게 가장 중요하죠

03:34.790 --> 03:38.780
중요한 건 정확한 결과를 낼 확률이 얼마냐는 거죠

03:39.080 --> 03:45.320
만약 그게 100%의 확률이라면 완벽한 거죠

03:45.320 --> 03:48.050
좋은 결과를 낼 거라고 100% 확신했어요

03:48.050 --> 03:51.320
다른 건 다 0이어야 해요 확률은 1이 되니까요

03:51.320 --> 03:53.900
그러니 정말 완벽하죠

03:53.900 --> 03:58.190
만약 100% less라면 잘 안 된 거예요

03:58.400 --> 04:01.850
확률이 낮을수록 더 안 좋은 결과가 나왔어요

04:02.000 --> 04:07.590
그 확률을 따져보면 잘 되는 것 같은 공식은 그 숫자의

04:07.920 --> 04:11.910
로그를 반증하는 거예요

04:11.910 --> 04:15.390
1을 그 숫자의 로그에 곱해요

04:15.390 --> 04:20.430
이것을 계산하면, 만약 1이라면, 100%의 확률이라면, 0이

04:20.430 --> 04:21.360
되겠죠.

04:21.360 --> 04:24.150
손해 볼 게 없으니 좋은 거죠

04:24.180 --> 04:26.700
완벽하다면 패배는 아무것도 아니죠

04:27.090 --> 04:32.340
확률이 낮을수록 손실률도 높아지는 거죠

04:32.340 --> 04:42.840
확률을 부정적으로 기록하는 건 손실 함수를 잘 활용하는 방법이죠

04:43.230 --> 04:44.670
거창한 명칭도 있죠

04:44.670 --> 04:48.030
이 손실 함수를 교차 엔트로피 손실이라고 해요

04:48.060 --> 04:49.200
그렇게 부르더군요

04:49.200 --> 04:54.330
다음 토큰의 참일 확률의 마이너스 로그일 뿐이죠

04:54.660 --> 04:57.120
그걸 사용했어요

04:57.120 --> 05:01.410
훈련을 계속한다면 지금 그걸 이용하는 거예요 각 예측의

05:01.410 --> 05:04.860
교차 엔트로피 손실을 계산하는 거죠

05:05.190 --> 05:07.890
그리고 덧붙일 말이 있어요

05:07.920 --> 05:11.790
이것에 대한 해석이 있어요 특히 데이터 과학자들에겐요

05:11.790 --> 05:17.700
이건 분류에 사용되는 계산입니다 뭔가를 다른 빈으로 분류하려고 할 때요

05:17.700 --> 05:22.860
예전에 이미지를 4-5가지 다른 범주로 분류하려고 했던 때가

05:22.860 --> 05:28.230
있었죠 교차 엔트로피 손실요 확률을 생각해내고 교차 엔트로피

05:28.230 --> 05:33.210
손실을 이용해서 분류를 잘했는지 아닌지 알아내요

05:33.630 --> 05:39.930
사실, 말이 되는 것이 다음 토큰을 예측하는 전체 프로세스는 분류 문제이기

05:39.930 --> 05:41.580
때문이죠

05:41.580 --> 05:48.000
다음 토큰이 될 수 있는 카테고리는 아주 많다는 거죠?

05:48.030 --> 05:50.880
사실, 가능한 모든 다음 패가 거기 있어요

05:50.880 --> 05:57.660
어떤 버킷이 다음 토큰에 가장 잘 맞을지 예측하는 거죠.

05:57.660 --> 06:03.690
따라서 인공지능이 생성되는 과정은 사실 분류 문제일 뿐이에요

06:03.690 --> 06:09.540
다음 토큰을 분류하고 다음 토큰이 무엇인지 밝혀질 확률을 계산하는

06:09.540 --> 06:10.200
거죠

06:10.690 --> 06:18.160
흥미롭게도 우리 프로젝트의 가격 예측은 몇 년 전에 말씀드렸듯이 정말

06:18.280 --> 06:20.320
퇴보하고 있어요

06:20.320 --> 06:25.390
숫자를 예측하려 하고 분류 문제로 취급하는 거죠 그건 괜찮아요

06:25.390 --> 06:31.910
왜냐하면 0과 999 사이의 숫자가 될 테니까요 죄송합니다 1과 999

06:31.910 --> 06:36.670
사이 가능한 999개의 양동이들이죠

06:36.670 --> 06:42.790
모든 제품을 이 999개의 양동이에 효과적으로 분류하려는 거예요

06:42.790 --> 06:45.850
그래서 분류 문제로서 꽤 효과적인 거죠

06:45.850 --> 06:52.690
그래서 개척 모델들이 잘 되고 있고 우리의 오픈 소스 모델도

06:52.690 --> 06:55.120
잘 되길 바라는 거죠

06:55.390 --> 07:01.030
이 모든 걸 종합해 보면 유용한 이론이 뒷받침되겠죠

07:01.030 --> 07:04.060
하지만 지금은 다시 연습할 때예요 get get it

07:04.060 --> 07:12.730
그걸 염두에 두고 오픈 소스 미세 조정은 어떻게 돼가는지 얘기해보죠
