WEBVTT

00:00.350 --> 00:05.270
8주 차 둘째 날의 4부에 잘 오셨어요

00:05.330 --> 00:11.210
이번 주에 할 일이 많은데 오늘 들어온 부품 중에 이게 제일

00:11.210 --> 00:12.410
무거워요

00:12.530 --> 00:14.900
Get it, get it, get it 바로 시작하죠

00:14.930 --> 00:19.970
기억하세요 오늘 우리가 할 것은 다른 종류의 가격을 만들어

00:19.970 --> 00:26.690
함께 합치는 겁니다 제품의 가치를 정확하게 추정하기 위해서요 Put

00:26.810 --> 00:31.550
이 수업을 하는 이유는 우리가 배운 다양한 기술을 복습하고

00:31.550 --> 00:36.830
학습 능력을 강화하고 즐거운 운동이 될 수 있도록 하기 위해서죠

00:37.070 --> 00:42.920
임의의 숲 학습 형태의 머신 러닝을 사용할 거예요 6주 차에 실험했던

00:42.920 --> 00:43.670
거죠

00:43.670 --> 00:46.310
전통적인 ML이지만 다르게 할 거예요

00:46.310 --> 00:53.510
크로마에 있는 벡터 내장 기법을 사용할 거예요 얼굴 문장을 끌어안는 변압기

00:53.540 --> 01:01.810
벡터라이저에 기반한 건데 트랜스포머와 머신 러닝을 함께 쓴다는 뜻이죠

01:01.810 --> 01:06.370
몇 가지 수입과 상수 설정으로 시작하죠

01:06.370 --> 01:13.870
이번엔 제품 벡터를 설정하고 일관되게 저장하고 환경을 로드하고 테스트 데이터를 로드하는

01:13.870 --> 01:15.280
걸 기억하죠

01:15.280 --> 01:20.710
훈련 데이터가 필요 없죠 그건 Cromer에 있고 Cromer 자체와 Cromer의

01:20.710 --> 01:26.200
제품 컬렉션에 연결되어 변수 컬렉션에 넣고 Cromer에서 로드하니까요

01:26.230 --> 01:31.900
결과로 벡터와 문서, 가격을 알 수 있죠

01:32.530 --> 01:38.170
이제 임의의 숲을 다시 살펴볼게요

01:38.260 --> 01:42.640
이 대사 기억하실지 모르겠네요 지난번엔 이렇게 했죠

01:42.640 --> 01:45.070
무작위로 숲으로 퇴행하는 사람을 훈련해요

01:45.280 --> 01:50.650
여기 이 놉은 동시 진행 가능한 절차의 수예요

01:50.650 --> 01:54.610
Get 1을 누르면 컴퓨터 전체를 다 쓰게 돼요

01:54.610 --> 01:56.290
모든 코어에 대한 프로세스를 실행하죠

01:56.290 --> 01:58.210
제 상자를 부수죠

01:58.210 --> 02:05.170
제 M1 Mac은 실행하는 데 1시간 정도 걸립니다 이미 실행했으니 여러분은 박스에

02:05.170 --> 02:09.160
맞게 시간을 재고 1인치만 사용하세요

02:09.160 --> 02:13.450
잠시 물러나서 비트를 감상할 수 있다면요

02:13.540 --> 02:21.700
그게 끝나면 모델 무게를 파일에 저장할 수 있습니다 유용한 유틸리티 Joblib.Doplib를 이용해서요

02:21.700 --> 02:25.660
scikit learn에 있는 거죠

02:25.660 --> 02:31.570
그럼 모델을 제공해 저장할 수 있죠 모델 웨이트를 저장해요

02:31.570 --> 02:36.550
그런 다음 다시 로드합니다 훈련 시간을 낭비하지 않으려고요

02:36.910 --> 02:45.820
이제 세 가지 요소를 장착합니다 전문 요원, 개척지 요원 그리고 임의

02:45.820 --> 02:47.560
숲 요원이죠

02:47.590 --> 02:51.370
에이전트 폴더를 잠깐 살펴보고 그걸 살펴보죠

02:51.400 --> 02:54.460
특수 요원은 이미 봤던 거예요

02:54.460 --> 02:55.450
이미 써놨잖아요

02:55.450 --> 02:57.970
이건 프로덕션화된 코드예요

02:58.060 --> 03:04.470
기본적으로 이닛이라는 건데 컨스트럭터라는 특수 에이전트예요 모달이라고

03:04.470 --> 03:05.820
하죠

03:05.850 --> 03:08.100
ModalCass-out을 사용해서요

03:08.100 --> 03:13.470
서비스 이름과 클래스 이름을 제공하고 클래스를 인스턴스화하죠

03:13.470 --> 03:19.320
그리고 가격으로 호출할 때는 셀프.Price.Price라고 입력합니다

03:19.320 --> 03:22.170
함수죠 함수 . remote이요

03:22.170 --> 03:24.300
그 방법만 기억하면 돼요

03:24.300 --> 03:25.410
이걸 로컬로 실행하면 안 돼요

03:25.410 --> 03:31.230
클라우드에 호출해 원격으로 실행하고 결과를 가져오면 결과를 반환하죠

03:31.230 --> 03:34.350
전에 봤던 특수 요원이에요

03:34.380 --> 03:40.560
프런티어 에이전트를 보면 여기 있는 코드는 지난 시간에 살펴본

03:40.560 --> 03:47.310
것으로 매개 변수를 식별하고 주석을 달아 멋지게 만들었죠

03:47.310 --> 03:48.570
의사봉합이 있어요

03:48.600 --> 03:50.130
여기 도서가 있어요

03:50.130 --> 03:54.330
우리가 작업하는 개체를 설명하는 형식 힌트가 있어요

03:54.570 --> 04:00.600
이런 과정을 거쳐야만 코드를 얻을 수 있어요 주피터 노트북 코드에서

04:00.600 --> 04:02.400
생산 준비 단계로요

04:02.400 --> 04:08.750
보통 JupyterLab에서는 작성하지 않아요 IDE에서 하죠 VSCode나

04:08.750 --> 04:10.970
PyCam 같은 거요

04:11.240 --> 04:15.500
여기에 구축하면 힌트 형식이나 검프 일부를 채우는 데 도움이

04:15.500 --> 04:16.520
될 거예요

04:16.880 --> 04:19.730
원한다면 주피터랩을 이용해도 돼요

04:20.030 --> 04:22.730
이쪽은 프런티어 요원이에요

04:22.730 --> 04:27.410
이제 임의의 산림청소를 보면 아주 간단해요

04:27.410 --> 04:33.800
생성자에서 먼저 문장 변압기를 만듭니다 벡터를 만들기 위해 사용하는

04:33.830 --> 04:35.180
모델이죠

04:35.180 --> 04:39.170
그런 다음 조금 전에 저장한 모델을 로드하죠

04:39.530 --> 04:46.100
실제 작업과 가격 실행 추론에 관해선 우리가 하는 일은 먼저 제품

04:46.100 --> 04:51.770
설명에 통과된 설명을 취합니다 벡터로 암호화하죠

04:51.770 --> 04:55.430
셀프.Model이라고 하고요 벡터로 예측하세요

04:55.430 --> 04:59.840
그러면 임의의 숲 결과를 받고 반환하죠

05:00.200 --> 05:01.280
아주 간단해요

05:01.280 --> 05:03.200
0으로 최대치를 설정했어요

05:03.200 --> 05:07.390
음수를 반환하지 못하게 0에서 밟는 게 좋겠어요

05:07.390 --> 05:08.950
그럴지는 잘 모르겠어요

05:08.980 --> 05:15.160
초기 버전에서 본 것 같아요 그래서 그게 현명한 예방책 같았죠

05:15.190 --> 05:17.470
적자를 예상하면 안 되니까요

05:18.010 --> 05:18.880
네

05:18.880 --> 05:23.530
어쨌든 저건 에이전트란 거죠

05:23.590 --> 05:26.410
그 에이전트를 인스턴스화할 수 있죠

05:26.440 --> 05:31.600
여기 이 함수는 설명입니다 지난 번과 정확히 같죠

05:31.600 --> 05:39.880
그냥 항목을 가져다가 가장 가까운 달러로 끌어내는 거죠

05:39.910 --> 05:41.770
도입부 문자가 헤더에 들어가요

05:41.770 --> 05:44.110
달러도 떼어낼 거예요

05:44.110 --> 05:48.670
다시 광고 문구로 돌아가죠 제품에 대한 간단한 설명이요 Get up

05:49.030 --> 05:55.960
그걸 염두에 두고 RF라는 함수를 쓸 수 있어요 랜덤포레스트라는 함수인데 항목을 설명으로

05:55.960 --> 06:02.290
바꾸는 거죠 랜덤포레스트 에이전트 가격을 랜덤포레스트로 불러요

06:02.290 --> 06:03.010
그것요

06:03.010 --> 06:08.800
그걸 명심하고 하니스 테스트 기억하시죠?

06:08.830 --> 06:15.130
이제 250개의 데이터 포인트로 시험할 수 있습니다 무작위 숲이 어떻게 작동하는지 보죠

06:15.190 --> 06:16.420
시작할게요

06:17.020 --> 06:19.090
붉은색이 꽤 많네요

06:19.720 --> 06:20.710
지난번 일 기억나요?

06:20.740 --> 06:22.870
97 정도였던 것 같아요

06:23.260 --> 06:25.030
어떻게 되나 보죠

06:26.800 --> 06:30.400
사실 지난번보다 아주 조금 더 나빠졌어요

06:30.400 --> 06:31.900
하지만 이건 정말 가깝네요

06:31.900 --> 06:33.340
기본적으로 똑같아요

06:33.370 --> 06:42.550
무작위 숲은 개선된 벡터와 두 베카 벡터가 같은 수를 제공하죠

06:42.550 --> 06:44.590
겉으로 보기에는 괜찮아요

06:44.620 --> 06:46.960
비탈이 좀 안 좋아요

06:46.960 --> 06:50.260
그리고 문제가 좀 있어요 저기예요

06:50.260 --> 06:52.030
하지만 일반적으로 보면 다 끝난 거예요

06:52.030 --> 06:52.690
칭찬할 만해요

06:52.690 --> 06:56.410
요즘 모델과는 다르지만요

06:56.680 --> 06:59.170
저기가 무작위 숲이에요

06:59.170 --> 07:05.260
다음 비디오에선 모든 걸 하나로 묶어주는 앙상블 모델로 넘어갈 거예요

07:05.290 --> 07:06.550
거기서 봐요
