WEBVTT

00:00.350 --> 00:05.270
そして､ 第8週2日目のパート4へようこそ｡ 

00:05.330 --> 00:12.410
ええと､ 今週はいろいろなことが起こっている｡

00:12.530 --> 00:14.900
さっそく始めよう｡ 

00:14.930 --> 00:19.970
覚えているだろうか､ 今日我々がやろうとしていることは､ 商品の価値を推定する能力の精度を向上させるために､

00:19.970 --> 00:26.690
他の種類の価格を構築し､ それらをまとめていくことだ｡

00:26.810 --> 00:31.550
繰り返しになるけど､ これをやっているのは､ これまで学んできたさまざまなテクニックを復習し､

00:31.550 --> 00:36.830
学習の一部を定着させる機会であると同時に､ 楽しい練習でもあるんだ｡

00:37.070 --> 00:43.670
第6週で実験したランダムフォレスト型の機械学習を使う｡

00:43.670 --> 00:46.310
それは伝統的なMLだが､ 我々は違うやり方をするつもりだ｡ 

00:46.310 --> 00:53.510
私たちは､ クロマにあるベクトル埋め込みを使うつもりです｡ それは､ えー､ 抱擁顔文トランスフォーマーVectorizerに基づいています｡

00:53.540 --> 01:01.810
つまり､ トランスフォーマーと､ えー､ 伝統的な機械学習を一緒に使うということです｡

01:01.810 --> 01:06.370
まずはインポートを行い､ いくつかの定数を設定する｡ 

01:06.370 --> 01:15.280
今回は､ 製品ベクトルの設定､ 定数の保存､ 環境のロード､ テストデータのロードを忘れないようにした｡

01:15.280 --> 01:20.710
トレーニングデータはCromerにあるので必要ない｡ Cromer自体に接続し､ Cromerの商品コレクションを変数コレクションに入れ､

01:20.710 --> 01:26.200
Cromerからロードする｡

01:26.230 --> 01:31.900
その結果､ ベクトル､ ドキュメント､ 価格が得られる｡ 

01:32.530 --> 01:38.170
ということで､ ランダムフォレストをもう一度見てみよう｡ 

01:38.260 --> 01:42.640
そして､ 前回どうやったか､ このセリフを覚えているかもしれない｡ 

01:42.640 --> 01:45.070
ランダムフォレスト回帰器を訓練する｡ 

01:45.280 --> 01:50.650
このnjobsというのは､ 同時に実行できるプロセスの数だ｡ 

01:50.650 --> 01:54.610
しかも､ マイナス1本だとマシン全体を使い切ることになる｡ 

01:54.610 --> 01:56.290
各コアごとにプロセスを実行する｡ 

01:56.290 --> 01:58.210
そして､ 本当に僕の箱を叩くんだ｡ 

01:58.210 --> 02:09.160
私のM1マックでは､ これを実行するのに1時間くらいかかる｡

02:09.160 --> 02:13.450
もし余裕があれば､ 少し離れてマシンの音に耳を傾けてみてほしい｡ 

02:13.540 --> 02:21.700
それが終わったら､ Joblib dot dumpという便利なユーティリティを使って､

02:21.700 --> 02:25.660
モデルの重みをファイルに保存します｡

02:25.660 --> 02:31.570
そしてモデルを提供し､ それを保存してモデルの重みを保存すればいい｡ 

02:31.570 --> 02:36.550
そして､ 何時間分ものトレーニングをする必要がないように､ 再びロードし直すんだ｡ 

02:36.910 --> 02:47.560
ここでは､ 3つのエージェント・オブジェクト､ スペシャリスト・エージェント､ フロンティア・エージェント､ そしてランダムフォレスト・エージェントを読み込みます｡

02:47.590 --> 02:51.370
エージェント・フォルダーを見てみよう｡ 

02:51.400 --> 02:54.460
専門エージェントは､ 以前にも紹介したことがある｡ 

02:54.460 --> 02:55.450
これはすでに書いた｡ 

02:55.450 --> 02:57.970
これはプロダクション化されたコードだ｡ 

02:58.060 --> 03:05.820
つまり､ 基本的には､ 特化型エージェントのコンストラクタのinitで､ モーダルと呼ばれるものを使います｡

03:05.850 --> 03:08.100
モーダル・クラス・ルックアップと言う｡ 

03:08.100 --> 03:13.470
そして､ サービス名とクラス名を提供し､ そのクラスをインスタンス化する｡ 

03:13.470 --> 03:19.320
そして､ 実際にpriceを呼び出すときには､ 単にself dot price

03:19.320 --> 03:22.170
dot priceと言う｡

03:22.170 --> 03:24.300
モーダルの伝え方を覚えておいてほしい｡ 

03:24.300 --> 03:25.410
我々はこれをローカルで実行したくない｡ 

03:25.410 --> 03:31.230
私たちはクラウドを呼び出し､ リモートでそれを実行し､ 結果を返したい｡

03:31.230 --> 03:34.350
というわけで､ これが以前見た専門エージェントだ｡ 

03:34.380 --> 03:47.310
フロンティア・エージェントを見ると､ ここにあるのは前回説明したコードであることがわかる｡

03:47.310 --> 03:48.570
docstringがある｡ 

03:48.600 --> 03:50.130
ここにdocstringsがある｡ 

03:50.130 --> 03:54.330
どのようなオブジェクトを扱っているかを示すタイプ・ヒンティングがある｡ 

03:54.570 --> 04:02.400
そしてこれは､ Jupyter Notebookのコードから本番に使えるコードにするためのプロセスだ｡

04:02.400 --> 04:10.970
そして通常､ JupyterLabでこれを書くことはなく､ VSCodeやPyCharmのようなIDEでこれを行うでしょう｡

04:11.240 --> 04:16.520
そして､ タイプヒントを助けたり､ このゴミを埋めたりしてくれるから､ そこに作ることになる｡

04:16.880 --> 04:19.730
しかし､ JupyterLabを使うこともできる｡ 

04:20.030 --> 04:22.730
これがフロンティア・エージェントなんだ｡ 

04:22.730 --> 04:27.410
ランダムフォレスト・エージェントを見ると､ これはとてもシンプルだ｡ 

04:27.410 --> 04:35.180
コンストラクターでは､ まず､ ベクトルを作成するためのモデルである文型変換器を作成する｡

04:35.180 --> 04:39.170
そして､ 先ほど保存したモデルをロードする｡ 

04:39.530 --> 04:46.100
そして､ 実際に価格を推論するときには､ まず､ 商品の説明文に記載された説明を受け取り､

04:46.100 --> 04:51.770
それをベクトルにエンコードします｡

04:51.770 --> 04:55.430
そして､ セルフ・ドット・モデルと呼ぶ｡  そのベクトルで予測する｡ 

04:55.430 --> 04:59.840
これでランダムフォレストの結果が得られたので､ それを返す｡ 

05:00.200 --> 05:01.280
簡単なことだ｡ 

05:01.280 --> 05:03.200
ここではゼロを最大にしているのがわかるだろう｡ 

05:03.200 --> 05:07.390
負の数を返せないように､ 床をゼロにすることを提案する｡ 

05:07.390 --> 05:08.950
そうなるかどうかは分からない｡ 

05:08.980 --> 05:15.160
以前のバージョンで見たかもしれないので､ 賢明な予防措置だと思った｡

05:15.190 --> 05:17.470
マイナス価格を予測してほしくない｡ 

05:18.010 --> 05:18.880
オーケー｡ 

05:18.880 --> 05:23.530
とにかく､ これがエージェントたちだ｡ 

05:23.590 --> 05:26.410
そして､ それらのエージェントをインスタンス化することができる｡ 

05:26.440 --> 05:31.600
さて､ この関数の説明は､ 前回とまったく同じである｡ 

05:31.600 --> 05:39.880
私たちは単純に品物を手に取り､ その敏速さを測り､ 最も近いドル数を引き出します｡ 

05:39.910 --> 05:41.770
冒頭の文章はヘッダーである｡ 

05:41.770 --> 05:44.110
そして価格も引き下げる｡ 

05:44.110 --> 05:48.670
だから､ 宣伝文句そのもの､ つまり商品のシンプルな説明に戻るだけだ｡ 

05:49.030 --> 05:55.960
そして､ それを念頭に置いて､ アイテムを受け取り､ それを説明文に変換し､ ランダムフォレスト・エージェントの価格を価格に呼び出す関数､

05:55.960 --> 06:02.290
RF（randomforest）を持つことができます｡

06:02.290 --> 06:03.010
それだ｡ 

06:03.010 --> 06:08.800
もちろん､ 我々の偉大なテストハーネス・テスターテストを覚えているだろう｡ 

06:08.830 --> 06:15.130
250点のデータでテストし､ ランダムフォレストのパフォーマンスを見ることができる｡ 

06:15.190 --> 06:16.420
さあ､ 始めよう｡ 

06:17.020 --> 06:19.090
赤がかなり多いね｡ 

06:19.720 --> 06:20.710
前回を覚えているか？

06:20.740 --> 06:22.870
97点くらいだったと思う｡ 

06:23.260 --> 06:25.030
どうなるか見てみよう｡ 

06:26.800 --> 06:30.400
ええと､ 実際､ 前回よりほんの少し悪くなっている｡ 

06:30.400 --> 06:31.900
しかし､ これは明らかに超接戦だ｡ 

06:31.900 --> 06:33.340
基本的には同じだ｡ 

06:33.370 --> 06:42.550
つまり､ ランダムフォレストは､ 改良されたベクトルと2つの単語のベクトルを比較した場合､ 基本的に同じ数値を出す｡

06:42.550 --> 06:44.590
そして､ 視覚的にもうまくいっていることがわかる｡ 

06:44.620 --> 06:46.960
ここにはある種の間違ったスロープがある｡ 

06:46.960 --> 06:50.260
それで､ ちょっと問題が......あ､ あそこで

06:50.260 --> 06:52.030
しかし､ 一般的に言えば､ それは終わったことだ｡ 

06:52.030 --> 06:52.690
称賛に値する｡ 

06:52.690 --> 06:56.410
まあ､ 最近のモデルとは違うけどね｡ 

06:56.680 --> 06:59.170
これがランダムフォレストだ｡ 

06:59.170 --> 07:05.260
そして次のビデオでは､ すべてをまとめるアンサンブル・モデルに移る｡ 

07:05.290 --> 07:06.550
そこで会おう｡ 
