WEBVTT

00:00.350 --> 00:05.540
다시 오신 걸 환영합니다 모든 걸 아름다운 사용자 인터페이스로 통합할 시간이네요

00:05.540 --> 00:10.880
하지만 먼저 한 번 더 살펴보죠 추론 엔드포인트 스크린에서 제 실행 중인 코드를

00:10.880 --> 00:12.260
볼 수 있어요

00:12.260 --> 00:15.380
퀴네 1요 570억 개의 채팅 추론이죠

00:15.680 --> 00:16.640
할 수 있어요

00:16.670 --> 00:23.060
보여드리고 싶은 게 있는데 여기로 오셔서 여러분의 추론 엔드포인트가 어떻게 실행되고 있는지 살펴보세요

00:23.060 --> 00:28.850
분석 보기 같은 걸 할 수 있어요 어떻게 되고 있는지, 요청 수를 볼 수 있죠 제가 만들긴 했지만

00:28.850 --> 00:32.090
레이더에 잡히기엔 충분하지 않아요

00:32.210 --> 00:34.430
대기 시간과 CPU 사용도요

00:34.460 --> 00:34.940
저기 있네요

00:34.970 --> 00:38.930
CPU 사용량과 GPU 사용량에 작은 변화가 있네요

00:38.960 --> 00:39.920
좋아요

00:40.010 --> 00:51.020
원가를 보시면 3달러가 사용된 걸 알 수 있어요 이 모델은 지금까지 64,000달러예요

00:51.380 --> 00:53.150
네

00:53.180 --> 01:00.770
그걸 염두에 두고 분석은 그만두고 주피터 연구소로 돌아가죠

01:01.010 --> 01:09.070
코드 콴을 호출하기 위해 이 코드를 마무리하죠 멋진 스트림 메서드로요 GPT 4와 Clude

01:09.070 --> 01:14.620
스트림 Quen에서 이미 했던 다른 스트림 메서드처럼요

01:14.650 --> 01:17.200
같은 종류의 메서드지만 물론 같은 함수죠

01:17.200 --> 01:18.700
아주 다르게 할 거예요

01:18.910 --> 01:21.370
토큰라이저를 생성할 거예요

01:21.370 --> 01:27.700
파이썬 을 일반적인 메시지 리스트로 바꿔줄 거예요

01:27.700 --> 01:29.710
채팅 템플릿을 적용할 거예요

01:29.710 --> 01:34.420
이제 텍스트에서 토큰화 준비가 됐어요

01:34.420 --> 01:41.590
그런 다음 수증 클라이언트를 위해 URL을 이용해 수증하는 마법을 부립니다 H깅페이스 토큰을

01:41.590 --> 01:43.120
넘기기 위해서요

01:43.120 --> 01:47.020
클라이언트 텍스트 생성을 하고 있는데요

01:47.020 --> 01:49.570
여기 우리가 스트리밍할 텍스트가 있어요

01:49.570 --> 01:52.930
최대 새 토큰이에요

01:52.930 --> 01:55.900
그리고 결과가 나오죠

01:55.900 --> 02:03.400
지금까지 우리가 준 토큰을 스트리밍하면서 지금까지의 총액을 확인하죠 그라디오가 기대하는 게

02:03.400 --> 02:05.740
그거란 걸 기억하시길 바라요

02:05.740 --> 02:13.280
지금까지 받은 모든 정보가 누적되어야 해요 모든 덩어리가요

02:13.280 --> 02:21.080
저 스트림 컬렉션은 전에 만든 다른 스트림 GPT와 컴패니언 기능이에요

02:21.080 --> 02:23.030
스트림 클로드요

02:23.030 --> 02:29.600
이제 최적화된 메서드를 가질 수 있습니다 코드를 최적화하는 이전의 최적화된 메서드를 대체할 수 있죠

02:29.600 --> 02:34.010
GPT Clude나 Code K콴 세 모델 사이에서 바꿀 수 있어요

02:34.400 --> 02:34.910
네

02:34.910 --> 02:41.900
사용자 인터페이스 그라디오 코드의 총합이 여기 있네요

02:41.930 --> 02:43.400
이거 꼭 돌려야 해요

02:43.820 --> 02:46.520
얼마나 간단한지 기억하시라고요

02:46.520 --> 02:47.720
말도 안 돼요

02:47.960 --> 02:54.710
작지만 멋진 타이틀이 있고요 파이썬 코드와 C++ 코드가 있는 행도 있네요

02:54.710 --> 02:57.140
모델을 선택할 행이 있어요

02:57.140 --> 03:03.200
이제 코드 권을 3개에 추가했어요 이전 두 모델 사이에서 선택할 수 있었던 것에 대해서요

03:03.320 --> 03:08.750
코드를 변환하는 버튼과 파이썬을 실행하는 버튼 C++를 실행하는 버튼이 있습니다

03:08.750 --> 03:13.600
파이썬 결과와 C플러스플러스 결과의 출력 상자도 있고요

03:13.600 --> 03:17.500
세 가지 액션이 있어요

03:17.500 --> 03:22.870
버튼을 클릭하면 어떤 행동을 취하는 세 장소요

03:22.870 --> 03:26.290
단순히 영어처럼 읽히는 게 마음에 들어요

03:26.290 --> 03:31.000
누군가 변환을 원한다면 변환 버튼을 누르면 최적화 함수를 호출해요

03:31.000 --> 03:33.550
이게 입력이고 이게 출력이죠

03:33.550 --> 03:37.120
파이썬 실행 버튼을 누르면 파이썬을 실행하죠

03:37.120 --> 03:44.080
입력은 파이썬 코드이고 출력은 파이썬 아웃입니다 C++ 버튼도 마찬가지고요

03:44.080 --> 03:47.020
아주 간단해 보여야 해요

03:47.020 --> 03:48.880
아주 간단하기 때문이죠

03:49.300 --> 03:51.310
이제 시작할 거예요

03:51.340 --> 03:54.730
예쁘게 나오길 기도해 보죠

03:55.060 --> 03:58.840
자, 이게 사용자 인터페이스예요

03:59.080 --> 04:08.050
그리고 여기 보이는 것은 파이썬 코드입니다 간단한 파이 계산을 위한 코드죠

04:08.050 --> 04:09.280
왜 안 되죠?

04:09.280 --> 04:12.490
GPT를 위해 한번 해 보죠

04:14.750 --> 04:17.720
C 플러스 플러스 등가라는 걸 기억하세요

04:17.750 --> 04:21.080
파이썬 변형을 실행해보죠

04:21.110 --> 04:23.240
제 기억이 맞는다면 8초 정도 걸렸어요

04:23.240 --> 04:25.220
8까지 셀 때까지 기다려야 해요

04:25.250 --> 04:27.140
파이썬 결과가 Get in get으로 나올 거예요

04:27.170 --> 04:29.810
8번 나왔네요 6초요

04:29.810 --> 04:34.820
원주율은 소수점 이하 자리까지 있어요

04:34.820 --> 04:36.410
이제 C+를 실행할게요

04:36.410 --> 04:38.630
GPT 4에서도 연락이 왔고요

04:38.630 --> 04:47.630
0년에도 잘했고요 06초면 100 엑스 이상 향상된 거죠

04:47.810 --> 04:50.630
클로드를 위해 한 번 더 불러보죠

04:50.750 --> 04:55.340
클로드의 코드를 변환하는 거죠

04:55.820 --> 04:57.380
저기 있네요

04:57.410 --> 05:00.080
클로드의 C 플러스도 해 볼게요

05:00.080 --> 05:00.680
더 있어요

05:00.680 --> 05:05.480
GPT 4를 다시 한번 간발의 차로 이기죠

05:05.480 --> 05:10.940
하지만 이 선 때문에 속도가 약간 빨라진 것 같아요

05:10.940 --> 05:13.610
클로드의 코드가 더 빠를지도 몰라요

05:13.790 --> 05:16.400
너무 비슷해서 의심스러워요

05:16.400 --> 05:16.810
맞아요

05:16.840 --> 05:19.480
컴파일러에 의해 최적화돼요

05:19.600 --> 05:22.570
하지만 이게 일정하게 약간 더 빠를 수도 있어요

05:22.570 --> 05:24.880
C 플러스 전문가일 수도 있겠네요

05:24.880 --> 05:25.540
그걸 보면 알 수 있죠

05:25.540 --> 05:31.030
직접 해 보고 만족할 수도 있겠죠. 당신의 구조가 빠르든 느리든

05:31.030 --> 05:31.960
간에요.

05:31.960 --> 05:33.880
어쨌든 중요한 건 그게 아니에요

05:33.910 --> 05:38.260
코드 품질이 어떻게 측정되는지 알아보려고 해요

05:38.290 --> 05:39.220
전환이 가능한가요?

05:39.250 --> 05:42.130
말이 되는지, 다른 점이 있는지요

05:42.160 --> 05:45.430
코드 변환 버튼을 눌러 어떻게 되는지 보죠

05:45.430 --> 05:49.780
우선, 알다시피 수다스러운 느낌이 더 강하죠

05:49.810 --> 05:53.920
설명이 정확히 나오지 않았어요

05:53.920 --> 05:55.720
그러니 삭제해야 해요

05:55.720 --> 05:57.880
하지만 그렇게 하도록 놔두죠 get it

05:57.910 --> 06:03.790
추가적인 것을 추가하는 코드 모델을 치지 않을게요.

06:05.320 --> 06:11.530
기억하세요, 이건 지금 모두 스트리밍 중입니다 엔드포인트에서부터 보고 있으니까요

06:11.560 --> 06:15.070
여기로 가면 새로 고침이 필요할지도 몰라요

06:15.070 --> 06:17.290
그걸 봐야 해요

06:17.320 --> 06:22.820
결과를 스트리밍할 때 CPU와 GPU 현상이 보여요

06:23.240 --> 06:29.990
이제 여기 아래를 보시면... 죄송합니다, 그라데이션 스크린으로요

06:29.990 --> 06:30.860
시작할게요

06:30.860 --> 06:35.690
완벽한 해결책을 찾았어요

06:35.690 --> 06:42.260
이제 상단에 있는 걸 제거하겠습니다 끝에 있는 설명도

06:42.260 --> 06:46.400
제거할게요 필요 없으니까요

06:46.430 --> 06:51.980
이 C++ 코드를 실행해 퀸 코드가 어떻게 됐는지 보죠

06:52.250 --> 06:53.780
한번 해 보죠

06:56.060 --> 06:58.670
아주 빠르게 달렸죠

06:58.700 --> 07:00.140
GPT 4와 거의 비슷했어요

07:00.170 --> 07:02.720
아마 비슷할 거예요

07:02.900 --> 07:09.170
실용적인 느낌이 나진 않지만 아주 잘 만든 것 같아요

07:09.170 --> 07:10.640
답은 같아요

07:10.640 --> 07:15.290
그게 코드에 있어서는 확실히 성공이라고 생각해요

07:15.290 --> 07:16.010
퀸이에요

07:16.340 --> 07:24.130
코드 퀸이 실행 중인 모델 매개 변수는 70억 개로 다른

07:24.130 --> 07:33.730
모델과 비교하면 죄송합니다 GPT 4와 클로드에는 2조 개 이상의

07:33.730 --> 07:37.660
매개 변수가 있죠

07:38.170 --> 07:44.200
그럼 다시 돌아가서 수준을 높여 보죠

07:44.230 --> 07:46.000
더 어려운 과제를 내 보죠

07:46.030 --> 07:57.580
이 값을 파이썬 하드 으로 바꾸겠습니다 최대 서브-러레이 합을 계산하는 코드죠

07:57.580 --> 08:05.110
이제 오픈 소스 모델이 이 복잡한 케이스를 어떻게 처리하는지 보죠

08:08.260 --> 08:11.590
뭘 하는 거죠?

08:13.240 --> 08:15.970
벌써 문제가 생겼네요

08:15.970 --> 08:16.840
문제가 있어요

08:16.840 --> 08:24.790
그 문제는 임의의 숫자를 생성하는 접근법을 보류하기로 결정했다는

08:24.790 --> 08:33.440
거예요 LCG라는 기술로 구현마다 반복적이고 일관된 임의의 숫자를

08:33.440 --> 08:36.380
생성하는 거죠

08:36.410 --> 08:41.270
제가 분명히 시스템 프롬프트에 난수 생성 주변의 기능성 변경을 금한다고

08:41.270 --> 08:43.760
입력했는데도 말이죠.

08:43.790 --> 08:50.990
그 전략을 바꾸라고 코텡을 설득할 수 없었어요

08:51.050 --> 08:53.960
이걸로 실험해 보세요 더 잘할 수 있는지 보죠

08:53.960 --> 08:58.580
하지만 실험만으로는 그렇게 할 수 없었어요

08:59.000 --> 09:00.950
거의 다 됐어요

09:01.160 --> 09:01.940
됐어요

09:01.940 --> 09:02.540
다 됐어요

09:02.570 --> 09:07.640
그래서 끝에 나오는 것도 빼고 처음에 나오는 것도 뺄 거예요

09:07.640 --> 09:09.680
이제 진실의 순간이에요

09:09.680 --> 09:15.230
콴 코드부터 C 플러스 플러스 코드를 실행하고 스크롤을 내리죠

09:15.770 --> 09:21.380
물론 그 숫자가 일치하지 않는다는 걸 알게 됐죠

09:21.410 --> 09:23.930
예전 결과를 기억한다면요

09:23.930 --> 09:30.220
그래서 안타깝게도 코드 콴이 숫자를 복제하는 데 실패했는데 놀랄 일도 아니죠

09:30.220 --> 09:37.420
왜냐하면 이 차에는 무작위 번호 생성기가 있거든요

09:37.720 --> 09:42.850
흥미로운 일이 좀 있었어요

09:42.850 --> 09:49.930
더 효율적인 방법론을 잠재적으로 인정한 것 같지만 숫자가 일치하지 않으니

09:49.930 --> 09:56.230
모든 게 제대로 작동하고 숫자가 맞는지 확인할 수 없어요

09:56.230 --> 10:00.970
그래서 정말 안타깝지만 희망을 걸었어요

10:00.970 --> 10:08.830
코드클런은 파이 테스트 즉, 간단한 테스트를 통과했지만 더

10:08.830 --> 10:16.930
어려운 테스트에 실패하고 말았습니다 파이썬 부호와 같은 답을

10:16.930 --> 10:19.060
내지 못했죠

10:19.060 --> 10:24.850
그런 관점에서 보면 안타깝게도 개척자 모델이 우세해요

10:24.850 --> 10:27.370
다시 한 번 승리를 거머쥐었죠

10:27.370 --> 10:30.340
코드클랜은 성공하지 못했죠

10:31.240 --> 10:33.250
그럼 다음 시간에 마무리하죠
