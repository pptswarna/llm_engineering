WEBVTT

00:00.560 --> 00:06.710
포기하지 않고 코스를 잘 통과해서 정말 대단해요

00:06.710 --> 00:17.630
이제 마지막 며칠이 남았네요 오늘 8주 차를 위한 중요한 전문 지식을 쌓아야 해요

00:17.660 --> 00:25.910
셋째 날은 계속해서 실력을 강화하고 한 단계 발전시키면서 기존 기술을

00:25.970 --> 00:28.700
수정하는 날이에요

00:28.700 --> 00:30.620
오늘은 새로운 걸 살펴볼 거예요

00:30.650 --> 00:35.630
구조적인 출생 작품이란 최근에 나온 혁신으로 개척 모델에

00:35.630 --> 00:41.000
특정 기준에 따라 반응하라고 말할 수 있는 방법이죠

00:41.000 --> 00:42.500
오늘 할 거예요

00:42.500 --> 00:48.950
또한 프론티어 모델과 함께 작업 경험을 더 쌓을 거예요 첫 주의 콜백 같은

00:48.950 --> 00:54.140
걸 작업하는 거죠 과거에 작업했던 것처럼 인터넷 스크랩페이지를

00:54.140 --> 01:01.040
만들 건데 프론티어 모델을 이용해 데이터를 합성할 거예요

01:01.070 --> 01:04.220
예전에 요약본 쓴 거 기억하시죠?

01:04.250 --> 01:07.610
인터넷 독자 다이제스트는 우리의 한 주였어요

01:07.610 --> 01:10.310
어느 날 갑자기 만족감이 밀려왔죠

01:10.460 --> 01:13.070
우린 그걸 몇 단계 더 발전시킬 거예요

01:13.400 --> 01:15.980
그게 오늘 계획이에요

01:15.980 --> 01:21.740
이것 역시 많은 부분을 수정하고 만들고 실험하는 과정이죠

01:21.980 --> 01:26.270
구조화된 출력물에 대해 몇 마디만 할게요

01:26.300 --> 01:27.590
구조화된 출력물이죠

01:27.590 --> 01:30.710
과거에 JSON 세대 사용했던 거 기억하시죠?

01:30.710 --> 01:35.960
JSON 내의 출력 형식으로 모델이 반응하길 원한다고 했죠

01:35.960 --> 01:40.070
프롬프트에서 JSON이 정확히 어떻게 보여야 하는지 설명하죠

01:40.070 --> 01:43.070
100% 믿을 수도 없고요

01:43.100 --> 01:44.600
아주 맛있어요

01:44.600 --> 01:50.270
그건 자주, 거의 항상 JSON으로 응답해요

01:50.540 --> 01:55.580
하지만 삐뚤어지기 시작하는 건 아주 복잡한 개체가 있어서 응답해야

01:55.610 --> 02:03.680
할 경우예요 시간이 지나면 일부 부분이 환각으로 나타나거나 잘못된 포맷을 보낼 수 있죠

02:03.680 --> 02:10.620
구조적인 출력이라는 건 모델이 어떻게 반응해야 하는지 정확히 지시하는

02:10.620 --> 02:11.490
거예요

02:11.490 --> 02:19.500
그렇게 하는 방법은 클래스로 응답을 정의하는 겁니다 Python 클래스로요 사실 그건 클래스가 될 겁니다 파이디언틱의

02:19.500 --> 02:24.510
베이스 모델이란 것의 서브클래스가 될 거예요 엔지니어링을 전공하신다면

02:24.510 --> 02:28.800
이미 경험해 보셨을 수도 있지만 걱정 마세요

02:28.800 --> 02:30.240
아니면 보여 줄게요

02:30.510 --> 02:36.990
기본 모델의 서브클래스를 만들어서 여러분이 찾는 걸 정확히 설명하는 데 사용하죠

02:37.110 --> 02:46.170
그런 다음 OpenAI를 호출할 때 해당 클래스를 지정합니다 그럼 해당 클래스의 인스턴스를 생성해 여러분에게

02:46.170 --> 02:47.970
다시 보내죠

02:48.480 --> 02:55.980
필요한 구조로 데이터를 생성하는 데 유용한 개념이죠

02:56.010 --> 03:03.210
다른 접근법과 비교해봐야 합니다 도구 함수 호출 사용이죠 좀 전에

03:03.210 --> 03:05.580
다시 살펴봤어요

03:05.760 --> 03:11.980
둘 다 꽤 비슷한 기술이에요 모델로부터 특정한

03:11.980 --> 03:16.840
구조의 반응을 확실히 가져오죠

03:16.840 --> 03:19.060
둘 다 장단점이 있어요

03:19.390 --> 03:26.020
일반적으로 권장하는 건 모델을 응용 프로그램 코드에 직접 연결할

03:26.020 --> 03:31.930
경우 특정 메서드 서명이 필요한 함수를 호출할 때 함수 호출과

03:31.930 --> 03:35.980
도구를 사용하는 게 낫다는 거죠

03:35.980 --> 03:41.800
그게 더 나은 모델이죠 그럼 완전히 반응할 테니까요 여러분이 정의한 JSON 구조에

03:41.800 --> 03:46.390
따라서요 여러분의 함수를 호출하기 위한 올바른 매개 변수로요

03:46.420 --> 03:53.140
만약 여러분이 보고자 하는 것이 다운스트림 소비를 위한 특정 포맷의 데이터를 생성하는

03:53.140 --> 03:56.860
것이라면 구조화된 출력화가 방법이에요

03:56.980 --> 04:01.900
장단점이 이렇게 나뉘어 있는데요. 한동안 시도하고 나면 어느

04:01.930 --> 04:07.060
쪽이 더 잘했는지 알게 되고, 어느 쪽이 더 잘했는지도 알게 되죠.

04:07.150 --> 04:10.480
소개를 마쳤으니 유피터랩으로 가보죠. HDMI

04:10.480 --> 04:12.700
직접 시험해 보려고요
