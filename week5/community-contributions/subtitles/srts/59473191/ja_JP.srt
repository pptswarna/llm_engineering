WEBVTT

00:00.920 --> 00:02.690
そして､ あなたは私たちがここに到着することはないと思っていた｡ 

00:02.720 --> 00:07.910
ここではJupyter Labでフロンティアモデルの微調整を行っている｡ 

00:07.910 --> 00:10.580
だから､ まずは輸入品の数々から始める｡ 

00:10.580 --> 00:12.860
テストデータもインポートする｡ 

00:12.860 --> 00:21.140
覚えているだろうか､ これは250のテスト例を実行し､ 美しいチャートを与えてくれる､ あの気の利いたコードの一部である｡

00:21.140 --> 00:28.880
その最後に､ 環境をロードし､ ハグする顔のトークンをロードします｡ 今回は使いませんが､

00:28.910 --> 00:34.280
以前のように､ いつもハグやハグする顔のようにしませんか？

00:34.310 --> 00:36.800
そしてOpenAIを使うつもりだ｡ 

00:36.830 --> 00:41.000
だから､ あそこでもここでもそのラインを走らせる必要がある｡ 

00:41.000 --> 00:46.610
トレーニング・データとテスト・データをピックルファイルから開くことで､

00:46.700 --> 00:51.200
すべてを一から作り直す必要がなくなる｡

00:51.470 --> 00:52.340
分かった｡ 

00:52.340 --> 00:54.500
では､ これからどうするかについて話そう｡ 

00:54.500 --> 01:06.210
そこでOpenAIは､ トレーニングを行う際には､ トレーニングに使用するサンプルポイントを50から100の間で使用することを推奨しています｡

01:06.210 --> 01:14.160
そして､ フロンティア・モデルのファイン・チューニングの主な目的は､ そのトーンやスタイルを適応させることであり､

01:14.160 --> 01:19.860
状況によってはエラーを修正し､ 精度を向上させることである｡

01:20.010 --> 01:28.860
GPTの4つのシリーズのようなモデルは､ 非常に多くのデータで訓練されているので､ 本当にやろうとしていることは､

01:28.980 --> 01:39.150
何か特定のことをさせたいときに十分な例を与えて､ そこから学習させることです｡

01:39.390 --> 01:50.970
でも､ 少なくともここでは､ 彼らが推奨している数より多い500を選ぶつもりだ｡

01:51.060 --> 01:55.830
ええと､ テストしてみたんだけど､ 小さい数字よりはうまくいったよ｡ 

01:56.130 --> 01:59.040
それで､ 例の中から500を選んでいるんだ｡ 

01:59.070 --> 02:00.540
今の例はとても小さい｡ 

02:00.570 --> 02:07.310
私たちのテキストはとても小さく､ 一般的にはもっと大きなトレーニング文書を考えていると思う｡ 

02:07.310 --> 02:10.220
だから､ この件に関しては悪い気はしない｡ 

02:10.430 --> 02:14.510
そして現在､ これは実際に微調整を行っている｡ 

02:14.660 --> 02:19.850
ええと､ 9月23日だと思うけど､ 9月後半までの期間無料なんだ｡ 

02:19.850 --> 02:30.830
しかし､ 無料でなくなったとしても､ あなたが支払うコストは､ 実際に500個の推論を実行するのにかかるコストと同じようなものである｡

02:30.830 --> 02:36.890
だから､ 現時点では約0ドルというところだろう｡  05を行うには､ えー､ あなたの通貨で､

02:36.890 --> 02:38.480
または同等額で｡

02:38.570 --> 02:41.930
ええと､ だからまだ小銭なんだ｡ 

02:41.930 --> 02:46.490
少なくとも9月下旬までは無料だ｡ 

02:46.730 --> 02:56.600
そのため､ 実際のトレーニングセットである400,000から500のトレーニングセットに分割している｡

02:56.780 --> 03:00.020
ええと､ そして私は50を検証として受け取るつもりだ｡ 

03:00.020 --> 03:07.190
先ほど､ 検証は必要ないと言いましたが､ トレーニングセットは1エポックしか行わないからです｡

03:07.460 --> 03:13.340
うーん､ でも､ 将来のプロジェクトでこの方法を知ってもらうために､ お見せした方が役に立つと思ったんだ｡

03:13.340 --> 03:16.970
なぜなら､ このすべてがあなたのプロジェクトでも再現できるからだ｡ 

03:16.970 --> 03:18.560
だからこれを実行する｡ 

03:19.010 --> 03:30.020
最初のステップは､ JsonlのJSONラインデータを準備することで､ トレーニングデータをこのフォーマットに変換することだとお話ししました｡

03:30.020 --> 03:40.040
まず最初に､ 皆さんがよく知っている関数を使ったメソッドを書きました｡

03:40.130 --> 03:46.580
ええと､ 商品の価格を見積もり､ 価格だけを返信してください｡ 

03:46.580 --> 03:51.380
そして､ ユーザー・プロンプトには､ その項目からテスト・プロンプトを選ぶ｡ 

03:51.590 --> 03:58.850
それで､ 1ドル単位まで切り取って､ それを "空 "に置き換えたんだ｡ 

03:58.850 --> 04:05.740
フロンティア・ラボにはそのような近似値は必要ない｡

04:05.740 --> 04:10.900
そして､ ユーザー・プロンプトに表示されるのも､ この部分だ｡ 

04:10.900 --> 04:17.350
そして､ アシスタントに "price is "と答え､ 値段を伝える｡ 

04:17.350 --> 04:19.090
では､ それを実行してみよう｡ 

04:19.090 --> 04:24.760
念のため､ 例を挙げてみよう｡ 

04:24.790 --> 04:34.210
モデルが最初に目にする列車ゼロのメッセージ｡ 

04:34.210 --> 04:36.910
そして､ これがロールシステムだ｡ 

04:36.910 --> 04:38.560
これがシステム・プロンプトだ｡ 

04:38.590 --> 04:42.970
それで満足していることを確認してから､ ユーザーをロールバックする｡ 

04:43.090 --> 04:45.070
そしてこれがユーザー・プロンプトだ｡ 

04:45.430 --> 04:51.040
ええと......これはいくらかかるんだろう？

04:51.040 --> 04:58.270
そして､ デルファイ､ デルファイ､ 燃料ポンプ・モジュールについての説明だ｡ 

04:58.690 --> 05:04.900
ええと､ それからこれがアシスタントの返事です｡ 

05:04.900 --> 05:07.330
価格は226ドル｡ 

05:07.330 --> 05:12.310
まさかあんなことになるとは......｡ 

05:12.520 --> 05:14.080
ええと､ どうぞ｡ 

05:14.080 --> 05:15.700
毎日何かを学んでいる｡ 

05:15.700 --> 05:21.040
いずれにせよ､ これがメッセージの形式であり､ 現段階ではとても､ とても馴染みのあるものであるはずだ｡

05:21.040 --> 05:29.410
そして､ これがいかに完璧に作られたテスト､ 申し訳ないが､ モデルに提供するトレーニング・データ・ポイントであるかがおわかりいただけるだろう｡

05:29.770 --> 05:38.530
では､ ここでJSON Lを作る関数を紹介しよう｡

05:38.530 --> 05:40.570
これらの項目を繰り返し処理する｡ 

05:40.570 --> 05:47.560
このテキスト､ このテキスト､ このオブジェクトをそれぞれ作成する｡ 

05:47.560 --> 05:54.340
そしてJsonを使う｡  はダンプ文字列を単純な文字列に変換する｡ 

05:54.340 --> 06:00.820
そして､ この文字列の最後にキャリッジ・リターンを追加するだけだ｡ 

06:00.850 --> 06:05.020
そしてそれを戻して､ 最後のキャリッジ・リターンを取り除く｡ 

06:05.020 --> 06:07.360
では､ 実際に見てみよう｡ 

06:07.360 --> 06:10.240
では､ まずそれを実行してみよう｡ 

06:10.450 --> 06:12.340
私のいつもの失態を犯さないように｡ 

06:12.640 --> 06:13.600
これでよし｡ 

06:13.600 --> 06:15.730
そして今､ JSONを作ると言う｡ 

06:15.730 --> 06:22.180
そして､ トレーニング・データを入れてみましょう｡ 

06:22.210 --> 06:27.370
全部が混雑しないように､ 最初の3つだけパスしよう｡ 

06:27.370 --> 06:29.860
もちろん､ ここで糸が戻ってくる｡ 

06:29.860 --> 06:34.090
そして､ この文字列は...｡ 

06:34.090 --> 06:35.830
印刷した方が簡単かもしれない｡ 

06:35.860 --> 06:40.090
空の線がはっきり見えるように印刷しよう｡ 

06:40.420 --> 06:48.130
文字列の中に1行､ 2行､ 3行と並んでいる｡ 

06:48.370 --> 06:50.290
うーん､ 巻きついている感じだね｡ 

06:50.290 --> 07:02.290
各行には､ そのトレーニング・データ・ポイントでやり取りされた全メッセージが含まれているのがわかるだろう｡

07:02.740 --> 07:03.400
オーケー｡ 

07:03.410 --> 07:04.760
ここまでは順調だ｡ 

07:04.940 --> 07:08.240
今､ 私たちはこの機能を使っている｡ 

07:08.240 --> 07:08.810
そうだろう？

07:08.840 --> 07:12.110
Jsonlは項目を取り､ ファイル名を取る｡ 

07:12.110 --> 07:13.850
そしてこれは超シンプルなものだ｡ 

07:13.880 --> 07:18.950
そのファイル名を開き､ 上の関数を呼び出して書き出す｡ 

07:18.950 --> 07:23.270
だから､ そのデモをお見せする必要はないと思う｡ 

07:23.300 --> 07:26.180
実行する必要はあるが､ 実際に実行することはできる｡ 

07:26.180 --> 07:34.190
そこで､ トレーニング・データ・セット､ つまり500アイテムからなる微調整されたトレーニング・データ・セットを使います｡

07:34.190 --> 07:34.940
確認しよう｡ 

07:34.970 --> 07:40.550
トレーニングデータセット全体から500アイテム､ つまり400,000アイテムだ｡ 

07:40.580 --> 07:45.590
すべてをファイルに書き込んでGPT4にアップロードするつもりはない｡ 

07:45.920 --> 07:52.550
それをFine Tune train dot JSONというファイルに書き出す｡ 

07:52.550 --> 07:58.700
では､ それを実行し､ 検証セットも同じように実行しよう｡ 

07:58.700 --> 08:03.170
2つのファイルを書き込んだが､ 数秒前に書き込まれたばかりであることがわかるだろう｡ 

08:03.170 --> 08:05.790
だから､ これを開けば開けるんだ｡ 

08:05.790 --> 08:13.530
実際には､ JupyterLabには派手なJSON行エディタがあるのですが､ ここでは普通のエディタについて説明します｡

08:13.560 --> 08:18.420
そして､ ここでは､ 期待通り､ 500行を想定していることがわかる｡ 

08:18.420 --> 08:24.270
さあ､ 最後まで500列だ｡ 

08:24.300 --> 08:27.960
そして､ そのどれもが期待通りの構造を持っている｡ 

08:28.170 --> 08:35.010
各行が整形されたJSONドキュメントだからです｡

08:35.010 --> 08:42.990
しかし､ 重要なのは､ これをJSONドキュメントとして読み込んでパースすることはできないということだ｡

08:42.990 --> 08:44.910
別々のラインだ｡ 

08:45.240 --> 08:50.730
それから､ エディターで開く検証ファイルは50だと思う｡ 

08:50.760 --> 08:54.780
私たちは50行をほぼ同じように言った｡ 

08:54.900 --> 08:58.680
ええと､ JSONの行でどのように見えるかをお見せしましょう｡ 

08:58.680 --> 08:59.130
編集者

08:59.130 --> 09:01.140
こんな感じの派手なエディターだ｡ 

09:01.140 --> 09:04.290
それぞれを開くと､ JSONオブジェクトのようになっている｡ 

09:04.720 --> 09:05.110
ええと｡ 

09:05.200 --> 09:06.310
あれを見ろ｡ 

09:07.060 --> 09:08.260
そうやって始めるべきだったんだ｡ 

09:08.260 --> 09:08.980
おそらくね｡ 

09:09.010 --> 09:11.380
何が起こっているのか､ とてもよくわかる｡ 

09:11.650 --> 09:17.080
メッセージがパッケージされる理由を直感的に理解できるんだ｡ 

09:17.080 --> 09:18.280
パッケージの仕方だ｡ 

09:19.180 --> 09:23.950
よし､ これがそのファイルだ｡ 

09:24.100 --> 09:26.080
これが最後のステップだ｡ 

09:26.080 --> 09:27.310
この部分だ｡ 

09:27.700 --> 09:33.550
そろそろ､ これらのファイルをOpenAIにアップロードしなければならない｡ 

09:33.550 --> 09:38.350
そのために､ OpenAIのドット・ファイルをドット・クリエイトと呼んでいる｡ 

09:38.350 --> 09:42.880
そしてファイルを渡し､ 目的は微調整だと伝える｡ 

09:43.270 --> 09:47.350
それと､ ひとつだけ気をつけてほしいことがある｡ 

09:47.350 --> 09:50.560
このファイルを渡すときは､ このファイルを渡さなければならない｡ 

09:50.590 --> 09:58.270
バイナリファイルとして開く必要があります｡ なぜなら､ OpenAIにストリームアップされるのは､ そのファイルのバイナリバイトになるからです｡

09:58.300 --> 10:02.980
つまり､ Rではなく､ RBにしたいわけだ｡ 

10:02.980 --> 10:07.160
ええと､ だから気をつけるべきはほんのちょっとしたニュアンスなんだ｡ 

10:07.160 --> 10:12.140
ファイルの中身を全部そのままOpenAIに送っているだけです｡ 

10:12.290 --> 10:15.950
だから､ その行を実行するのに1秒かかる｡ 

10:15.980 --> 10:20.960
戻ってきたものを検査すると､ ファイル・オブジェクトが返ってくる｡ 

10:21.650 --> 10:24.410
バイト数は決まっている｡ 

10:24.620 --> 10:28.070
オブジェクトはファイル､ 目的は微調整､ ステータスは処理｡ 

10:28.070 --> 10:32.660
だから､ OpenAIはすでにそのファイルを受け取り､ 処理している｡ 

10:32.660 --> 10:35.930
そして､ 私たちは同じことを検証のために行う｡ 

10:36.260 --> 10:38.660
走らせればいいんだ｡ 

10:38.660 --> 10:41.420
そしてもう一度､ 加工される｡ 

10:41.420 --> 10:45.350
この時点で､ 2つのJSONファイルを作成したことになる｡ 

10:45.350 --> 10:50.180
1つは微調整したトレーニングセット用､ もう1つは微調整した検証セット用だ｡ 

10:50.180 --> 10:53.000
ファイルシステムに書き出した｡ 

10:53.000 --> 11:00.560
そしてそれらをOpenAIにアップロードし､ OpenAIのファイルオブジェクトとして置いています｡ 

11:00.590 --> 11:05.150
次のセッションでは､ 実際に微調整を行う｡ 

11:05.180 --> 11:06.170
そこで会おう
