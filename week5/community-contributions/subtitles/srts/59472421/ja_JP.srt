WEBVTT

00:00.110 --> 00:05.510
そして､ Jupyter Labでの伝統的な機械学習の最終回へようこそ｡ 

00:05.510 --> 00:07.100
もうすぐ終わる｡ 

00:07.130 --> 00:09.170
個人的には､ とても楽しいと思う｡ 

00:09.260 --> 00:12.290
あなたにとって耐え難いことでなければいいのですが｡ 

00:12.320 --> 00:23.660
もっと機能を追加したり､ 実験したり､ もっとこれを活用できないか試したりしてほしい｡

00:23.660 --> 00:29.150
このチャートは最後に見たもので､ 平均115のエラーを記録したワード2ベックだった｡ 

00:29.180 --> 00:39.320
そして､ 「バッグ・オブ・ワード」NLPのオリジナル・モデルで､ 114 113に到達したことを覚えていらっしゃるかもしれません｡

00:39.320 --> 00:39.320
6とかなんとか｡ 

00:39.680 --> 00:46.010
それで､ ええと､ これから最後の2つのモデルを発表します｡ 

00:46.040 --> 00:56.630
サポート・ベクトル・マシンのサポート・ベクトル回帰を使う｡

00:56.630 --> 01:03.070
データ点を取り､ サポート・ベクトルと呼ばれる､ 超平面に最も近い点を持つベクトルを使って､

01:03.100 --> 01:09.730
データを分離する超平面に当てはめようとします｡

01:09.820 --> 01:15.100
あなたにとってはナンセンスなことかもしれないし､ 私がうまく説明できていないだけで､ あなたが知っていることかもしれない｡

01:15.100 --> 01:16.840
いずれにせよ､ それは問題ではない｡ 

01:16.840 --> 01:22.630
使いやすいscikit learnのライブラリをそのまま使おう｡ 

01:22.750 --> 01:24.970
我々は線形SVRを使用している｡ 

01:25.000 --> 01:31.000
カーネルが異なる他のタイプもあり､ より良い結果が得られるかもしれないが､ 実行に時間がかかる｡

01:31.000 --> 01:37.630
これは非常に速く､ 速すぎるくらいだ｡

01:37.720 --> 01:44.380
ええと､ でも､ すでに実行したところ､ 5秒ほどで終わったんですが､ 別のカーネルで使ったものは､

01:44.380 --> 01:47.890
一晩中実行してもまだ終わりませんでした｡

01:47.890 --> 01:53.920
だから､ その真ん中あたりを探ってみるのもいいかもしれない｡ 

01:54.070 --> 01:58.480
でも､ これが精一杯だった｡ 

01:58.510 --> 02:02.610
どうなるか見てみよう｡ 

02:02.640 --> 02:03.240
準備はできているか？

02:03.270 --> 02:04.080
賭け金を入れる｡ 

02:04.080 --> 02:05.700
そして今､ 私はそれを実行する｡ 

02:05.970 --> 02:06.990
いや､ しないよ｡ 

02:07.290 --> 02:09.510
そうだ｡ 

02:09.600 --> 02:10.470
うまくいったよ｡ 

02:10.890 --> 02:12.360
ああ､ わかった｡ 

02:12.360 --> 02:17.190
だから黄色､ 赤､ 緑が多い｡ 

02:17.190 --> 02:22.740
明らかに砕けてはいないが､ いくつか､ あー､ ひどくはなさそうだ｡ 

02:22.740 --> 02:25.860
チャートを見てみよう｡ 

02:26.940 --> 02:33.210
まあ､ だから､ 今のところ勝者だよ｡ 

02:33.240 --> 02:35.220
112. 5.

02:35.250 --> 02:43.680
その前の勝者であるバッグ・オブ・ワード線形回帰モデルよりは少しましだ｡

02:43.710 --> 02:52.740
視覚的に､ 良いことがいくつか起こっているのがわかると思うが､ 明らかに平均点よりはるかに上の点を見積もろうと苦戦している｡

02:52.860 --> 02:58.950
多少の進歩は見られるが､ 大きな進歩はない｡ 

02:59.400 --> 03:03.590
これがサポート・ベクトル回帰モデルである｡ 

03:03.770 --> 03:11.990
最後のモデルは､ ランダムフォレスト回帰ランダムフォレストだ｡

03:12.020 --> 03:13.610
特殊なテクニック｡ 

03:13.610 --> 03:19.040
アンサンブル・テクニックの一種で､ 小さなモデルをたくさん組み合わせる｡ 

03:19.250 --> 03:32.270
組み合わせるモデルは､ それぞれデータポイントのランダムなサンプルと特徴のランダムなサンプルを取る｡

03:32.390 --> 03:38.900
そして､ それに基づいて多くのモデルを訓練し､ それらのモデルをすべて組み合わせる｡ 

03:38.900 --> 03:47.000
回帰の場合､ これらのミニモデルの平均をとり､ それをランダムフォレストと呼ぶ｡

03:47.090 --> 03:49.610
だから､ それがどう作用するか見てみよう｡ 

03:49.610 --> 03:55.700
これらは一般に､ あらゆる形や大きさのデータセットに対して優れた性能を発揮することが知られている｡ 

03:55.730 --> 03:59.540
ハイパーパラメーターが少ないのもいい｡ 

03:59.570 --> 04:04.520
ハイパーパラメーターは､ 余計なことを微調整するための単なる追加ノブと呼ばれるものだ｡ 

04:04.520 --> 04:06.800
いろいろな値を試してみる必要がある｡ 

04:07.100 --> 04:09.230
ランダムフォレストにはあまりない｡ 

04:09.230 --> 04:11.480
そのまま使って様子を見るだけだ｡ 

04:11.480 --> 04:15.560
だから､ このまま使って､ これから様子を見ようというわけだ｡ 

04:15.590 --> 04:19.970
テスターがドットテストを行い､ ランダムフォレストプロセッサーでパスした｡ 

04:19.970 --> 04:21.680
そして､ また賭けをする｡ 

04:21.980 --> 04:25.880
ええと､ ランダムフォレストの方が良い結果になると思いますか､ それとも悪い結果になると思いますか？

04:25.910 --> 04:28.010
112は倒すべき数字だ｡ 

04:28.010 --> 04:30.740
従来の機械学習のパフォーマンスを見てみよう｡ 

04:30.740 --> 04:31.790
グリーンも見える｡ 

04:31.790 --> 04:34.130
赤もあれば緑もある｡ 

04:34.370 --> 04:36.830
走るのに少し時間がかかる｡ 

04:36.860 --> 04:42.020
グリーン､ グリーン､ グリーン､ 赤､ たくさんの赤が見られる｡ 

04:42.320 --> 04:45.230
しかし､ 一般的にはこうだ｡ 

04:45.230 --> 04:46.820
そうだ｡ 

04:46.820 --> 04:50.060
つまり､ ランダムフォレストの勝利だ｡ 

04:50.090 --> 04:52.940
誤差は97ドル｡ 

04:52.940 --> 04:54.920
100を切ってきた｡ 

04:54.950 --> 04:56.780
ハンドルは9本だ｡ 

04:56.780 --> 04:58.610
我々は100ドル以下でやってきた｡ 

04:58.640 --> 04:59.930
これまでのベストだ｡ 

04:59.930 --> 05:02.370
点の34％が緑｡ 

05:02.550 --> 05:03.840
これが我々のラインだ｡ 

05:03.840 --> 05:05.130
これが緑の点だ｡ 

05:05.130 --> 05:09.450
また､ 平均以上の成績を残すことに少し問題があるが､ それほど悪くはない｡ 

05:09.720 --> 05:11.310
あの男がいたことで､ どれだけうまくいったかわかるだろう｡ 

05:11.340 --> 05:14.220
本当に高価なものは緑色だった｡ 

05:14.340 --> 05:23.340
そして......一般的には......かなり良い結果を残している｡ 

05:23.340 --> 05:25.410
おめでとう､ ランダムフォレスト｡ 

05:25.500 --> 05:27.450
そしてもちろん､ おめでとう｡ 

05:27.450 --> 05:34.710
これを克服したなら､ ランダムフォレストを使うこともできますが､ 今思いついたベクトルだけでなく､

05:34.710 --> 05:38.160
特徴量も加えることができます｡

05:38.160 --> 05:49.110
いくつかの機能を製造し､ それを押し込むことで､ この数字に打ち勝ち､ 97よりも良い結果を出そうとすることができる｡

05:49.230 --> 05:59.640
LMSの試用に移る前に､ 従来の機械学習をどう楽しむかを見てほしい｡

05:59.640 --> 06:02.730
その前に､ スライドで簡単にまとめよう｡ 
