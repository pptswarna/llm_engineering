WEBVTT

00:00.410 --> 00:02.180
また会えて嬉しいよ｡ 

00:02.180 --> 00:11.900
冒険の3週目､ 3日目をスタートさせるにあたり､ ええと､ 今回は物事がより深くなりそうだ｡

00:11.900 --> 00:18.890
我々は､ Face Transformersライブラリを抱きしめるための低レベルのAPIに入るために､ 腕まくりをするつもりだ｡

00:19.490 --> 00:26.330
そしていつものように､ フロンティアモデルに対してコードを書くことも､ AIアシスタントを構築することも､ パイプラインを使用することもできることを簡単に覚えておいてほしい｡

00:26.330 --> 00:26.870
パイプライン

00:26.870 --> 00:36.290
前回やったことは､ Hugging Faceから入手可能なオープンソースの推論タスクを幅広く利用する簡単な方法だ｡

00:36.290 --> 00:39.260
今日､ 私たちはもっと低いレベルにいる｡ 

00:39.350 --> 00:45.470
先ほど申し上げたように､ パイプラインよりも低いレベルでトランスフォーマーとやりとりする方法の一部として､

00:45.470 --> 00:49.430
トークナイザーとモデルがあります｡

00:49.430 --> 00:50.630
そして､ それが今日私たちがやろうとしていることだ｡ 

00:50.630 --> 00:53.000
まずはトーケナイザーから｡ 

00:53.000 --> 01:03.890
テキストとトークンの間の翻訳をモデル別に学び､ チャット・テンプレートというものを理解するつもりです｡

01:03.920 --> 01:06.170
非常に重要な瞬間だ｡ 

01:06.440 --> 01:13.700
ええと､ まず､ ハギング・フェイスのトークナイザーと呼ばれるオブジェクトを紹介すると､

01:13.700 --> 01:20.870
これはテキスト（文字列）とトークン（数値のリスト）の変換を行うオブジェクトです｡

01:21.020 --> 01:23.930
ええと､ 簡単に言うと2つの機能がある｡ 

01:23.930 --> 01:26.960
エンコードとデコードについて知っておくべき2つのこと｡ 

01:26.960 --> 01:32.060
エンコードすると文字列からトークンになり､ デコードすると元に戻る｡ 

01:32.060 --> 01:33.590
そして私たちはそれを見ることになる｡ 

01:33.590 --> 01:39.920
もちろん､ ちょっとしたニュアンスや手間のかかることはあるが､ 基本的にはそれだけだ｡

01:40.370 --> 01:53.150
トークナイザーにはボキャブラリーがあり､ 1文字､ 2文字､ 3文字､ 4文字など､ トークンを構成するさまざまな文字の断片がすべて含まれています｡

01:53.360 --> 01:57.110
そして､ このような文字の断片を含むこともできる｡ 

01:57.110 --> 01:59.870
スペシャル・トークンと呼ばれるものが含まれることもある｡ 

01:59.900 --> 02:07.880
特別なトークンとは､ 文の始まりやアシスタントとのチャットの始まりなど､

02:07.880 --> 02:17.210
モデルに何かを伝えるためのトークンです｡

02:17.660 --> 02:23.150
前にも言ったように､ ニューラルネットワーク・アーキテクチャをどのように訓練すればいいのか､

02:23.150 --> 02:28.730
特定のトークンが文頭などを表すと期待できるようにニューラルネットワーク・アーキテクチャをどのように構築すればいいのか､

02:28.730 --> 02:33.470
と考えているのなら､ どうすればいいのだろう？

02:33.470 --> 02:35.420
そして､ 魔法のような答えはない｡ 

02:35.420 --> 02:37.370
単純にトレーニングに尽きる｡ 

02:37.370 --> 02:46.550
もし学習データの中で､ その特別なトークンがその目的に使われている例を十分に見ていれば､ それがその特別なトークンの目的であることを学習する｡

02:46.550 --> 02:52.400
しかし､ 一般的に言って､ ある特定のタイプのトークンを他のトークンよりも期待するような､

02:52.400 --> 02:57.890
またトークナイザーを期待するような基本的なものは､ アーキテクチャにはない｡

02:57.890 --> 03:03.590
これに加えて､ テキストをトークンにマッピングし､ ボキャブラリーを持つことも､ チャットテンプレートと呼ばれるものがある｡

03:03.590 --> 03:07.320
少なくとも､ 特定のタイプのモデルについては､ これからわかるだろう｡ 

03:07.320 --> 03:16.950
そして､ システム・メッセージやユーザー・メッセージなどのメッセージ・セットを､ トークン・セットに変換する方法を知っている｡

03:16.950 --> 03:20.940
そしてそれは､ 実際の例を見ればすべて理解できるだろう｡ 

03:21.630 --> 03:29.520
だから､ ハギング・フェイスのすべてのモデル､ すべてのオープン・ソース・モデルには､ それ自身のトークナイザーが関連付けられている｡ 

03:29.520 --> 03:35.190
モデルがどのようにトレーニングされたかに依存するので､ モデルに適用される一般的なトークナイザーは1つだけではありません｡

03:35.220 --> 03:53.040
しかし､ 重要なのは､ モデルが学習されたときにどのトークナイザーが使われたかということだ｡

03:53.130 --> 03:57.390
それはいずれやってみるべき実験かもしれない｡ 

03:57.390 --> 04:01.380
そんなことをしたら､ すぐに非生産的な実験になってしまう｡ 

04:01.380 --> 04:12.120
というわけで､ 今日は llama 3 のトークナイザを見てみましょう｡  ラルマの象徴的なモデル群である「1」が道を切り開いた｡

04:12.240 --> 04:12.420
申し訳ない｡ 

04:12.450 --> 04:12.660
からだ｡ 

04:12.690 --> 04:13.230
ラルマより

04:13.230 --> 04:13.890
メータより

04:13.920 --> 04:17.010
それがオープンソースモデルへの道を開いた｡ 

04:17.010 --> 04:20.670
マイクロソフトのファイ3というモデルを見てみよう｡ 

04:20.670 --> 04:29.400
アリババ・クラウドの強豪であり､ さまざまな指標で業界をリードしているクイン2を再び見てみよう｡

04:29.400 --> 04:41.010
スター・コーダー2と呼ばれる､ コードを生成するためのモデルだ｡

04:41.010 --> 04:44.970
そのトークナイザーを見て､ 違いを確認する｡ 

04:45.270 --> 04:53.520
ええと､ この2つが似たようなグラフィックなのは､ ラマ3. 1とファイ3は極めてよく似ている｡

04:53.550 --> 05:01.650
Quantuもよく似ていますが､ 英語だけでなく中国語にも力を入れています｡

05:01.650 --> 05:05.580
Star Coder 2は､ もちろんコーディングに関するものだ｡ 

05:05.700 --> 05:12.120
それでは､ Google Colabに移動し､ トークン化を行います｡ 
