WEBVTT

00:00.740 --> 00:04.160
이 시점에서 hyperperameter에 관해 얘기할 거예요

00:04.160 --> 00:06.320
그중 세 가지를 소개할게요

00:06.320 --> 00:08.840
hyperperameter가 뭔지 다시 말씀드릴게요

00:08.840 --> 00:10.700
지난주에 비트 얘기를 좀 했어요

00:10.730 --> 00:13.910
하이퍼파라미터는 이 레버 중 하나예요

00:14.000 --> 00:19.250
실험자로서 원하는 걸 선택할 수 있는 거예요

00:19.250 --> 00:24.740
무엇이어야 하는지에 대한 어렵고 빠른 규칙은 없어요 hyperpaameter

00:24.740 --> 00:32.570
최적화라는 프로세스를 사용해야 합니다 다양한 값을 시도하고 당면한 작업에 뭐가 최선인지 알아보기 위해서요

00:32.570 --> 00:38.690
사실 우리가 하는 일은 시행착오를 겪는 거예요

00:38.690 --> 00:44.690
추측과 실험이 뒤따르는 작업이죠 비트를 한 방향으로만 설정해야

00:44.690 --> 00:47.570
하는 이론적 이유가 없거든요

00:47.570 --> 00:50.000
실질적인 실험의 문제죠

00:50.000 --> 00:56.240
이런 경우 종종 발견하게 되는데 잘 작동하는 프로그램일 경우 몇 가지 제어 매개

00:56.240 --> 01:01.250
변수가 있지만 어떻게 설정해야 할지 잘 모르는 경우가 있죠

01:01.280 --> 01:03.570
어떤 형태가 돼야 할지 아직 이론적으로 몰라요

01:03.600 --> 01:05.490
hyperperameter라고 부르죠

01:05.610 --> 01:06.570
그렇게 불러요

01:06.570 --> 01:11.940
올바른 설정을 고를 때까지 시행착오와 추측의 세계에 있다는 뜻이죠

01:11.940 --> 01:13.590
모델에게 가장 잘 어울려요

01:13.620 --> 01:17.550
비트를 좀 단순화했지만 대충 이해하셨으면 좋겠네요 get it get it

01:17.550 --> 01:21.180
가장 중요한 세 가지가 있어요

01:21.180 --> 01:26.760
Q 로라 파인 튜닝의 경우 이따금 소개해 드릴게요

01:26.760 --> 01:29.640
그들과 함께 작업할 거예요

01:29.640 --> 01:33.720
첫 번째는 R이라고 해요 직위를 뜻하죠

01:33.810 --> 01:41.940
라마 건축물에서 낮은 계층의 행렬을 만들 때 사용하는 차원이 얼마나

01:41.940 --> 01:49.800
되는지를 뜻합니다 내부 층의 차원은 100만 4천 차원에 달하죠

01:49.800 --> 01:55.020
낮은 계급 행렬에서 훨씬 적은 수의 치수를 확보해 주세요

01:55.020 --> 01:56.640
그게 그들의 의도예요

01:56.850 --> 02:03.600
아까 말했듯이 어렵고 빠른 규칙은 없어요 이런 언어 생성 모델에서

02:03.600 --> 02:09.520
작업할 땐 다양한 작업과 다양한 R 값을 찾죠

02:09.520 --> 02:14.740
제가 항상 써먹던 경험 법칙이 하나 있는데 일반적으로 사람들이 쓰는

02:14.740 --> 02:18.910
걸 보니 8부터 시작하는 것 같아요 작은 숫자죠

02:19.210 --> 02:24.940
아주 적은 메모리를 사용하고 꽤 빨리 실행된다는 뜻이죠

02:25.120 --> 02:30.940
다음엔 16으로 두 배 늘리죠 메모리를 더 잡아먹고 더 천천히 실행하면서 더 나은 결과를

02:30.940 --> 02:36.280
얻는지 보고 잠재적으로 또 두 배가 될 때까지요 결과물이 감소하는 지점까지 도달할

02:36.280 --> 02:37.450
때까지요

02:37.450 --> 02:40.690
속도가 느려지고 시간이 더 오래 걸리는데 나아지는 게 보이지 않아요

02:40.690 --> 02:45.520
높은 R을 갖는 건 의미가 없어요 이미 데이터를 위해 필요한 힘을

02:45.520 --> 02:47.170
갖고 있으니까요

02:47.350 --> 02:51.880
다음은 알파에 대해 얘기해 보죠

02:51.880 --> 02:56.890
알파는 단순히 배율 요인이 두 배인 거예요

02:56.890 --> 03:01.120
로라 A. 로라 B 매트릭스에 적용했어요

03:01.120 --> 03:05.530
그 무게로 모델의 무게를 바꾸죠

03:05.530 --> 03:10.710
값어치의 공식은 목표 모듈에서 모델에서 무게 중심을 변경하는

03:10.740 --> 03:11.940
양이에요

03:11.970 --> 03:16.830
알파 곱하기 A 곱하기 B 곱하기예요

03:16.830 --> 03:18.630
모두 함께 번성하죠 Get up, Get up

03:18.630 --> 03:21.330
알파가 클수록 효과도 크군요

03:21.330 --> 03:27.600
실제로 사용되는 경험 법칙은∙∙∙ 거의 보편적으로 전 항상 사용했고 항상

03:27.600 --> 03:32.880
이런 식으로 봤어요 예를 들어 알파를 R로 설정하는 거죠

03:32.910 --> 03:36.540
R이 8로 시작하면 알파는 16이 되죠

03:36.570 --> 03:42.540
16 알파 R은 32 32는 64가 되겠죠

03:42.540 --> 03:44.940
경험으로 터득한 좋은 법칙이죠

03:44.940 --> 03:51.510
물론 다양한 알파로 실험해볼 가치가 있죠 그게 여러분의 정확성을 바꿀지

03:51.540 --> 03:53.040
보려면요

03:54.240 --> 04:02.160
세 번째이자 마지막 핵심 하이퍼파라미터는 아키텍처에 적용하는

04:02.190 --> 04:08.640
데 집중할 대상 모듈이 무엇인가 하는 거죠

04:08.640 --> 04:15.970
이 중 어떤 레이어에 초점을 맞출지 선택하세요 일반적으로 가장 일반적인 선택은

04:15.970 --> 04:19.540
주의 집중 레이어에 초점을 맞추는 거죠

04:19.540 --> 04:20.830
흔한 일이에요

04:20.830 --> 04:23.920
코드에서 보실 수 있어요 보시면 더 이해가 될 거예요

04:23.980 --> 04:28.990
다른 목표 모듈을 목표로 삼고 싶을 때가 있죠

04:29.080 --> 04:35.800
예를 들어, 여러분이 뭔가를 생성할 때 결과물이 완전히 다른 언어로

04:35.830 --> 04:41.110
나오길 원한다면 최종 레이어 일부를 대상으로 하는

04:41.110 --> 04:43.780
게 좋을 거예요

04:43.780 --> 04:49.210
그래서 여러분이 보실 건 그게 어떻게 작동하는지에 대한 좀 더 많은 컨텍스트를 알려드리죠

04:49.210 --> 04:54.940
하지만 일반적으로 가장 많이 사용되는 것은 주의 헤드 층이에요

04:54.940 --> 04:56.440
그렇게 할 거예요

04:56.470 --> 04:59.470
어떻게 설정됐는지 곧 보실 거예요

05:00.670 --> 05:06.760
이제 구글 Colab으로 가서 몇 가지 모델을 살펴보고 로라에 관해 얘기해 보죠

05:06.760 --> 05:12.760
그리고 hyperperameter 3개가 어떻게 작동하는지 볼게요

05:13.180 --> 05:14.260
시작하죠
