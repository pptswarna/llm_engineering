WEBVTT

00:00.740 --> 00:01.670
잘 돌아왔어요

00:01.670 --> 00:07.070
그래서 저희는 완전히 불쾌하고 불쾌한 기능들을 작업해왔어요

00:07.070 --> 00:09.110
아주 지저분한 일이죠

00:09.110 --> 00:11.990
그래도 비트는 좀 재미있어요

00:11.990 --> 00:17.360
하지만 좀 허접하고 데이터에 깊이 들어가야 해요

00:17.360 --> 00:23.690
데이터에 있는 물건의 무게를 알아내려고 여러 가지를 살펴봤어요 무게를 못 찾으면

00:23.690 --> 00:25.730
평균 무게를 계산했고요

00:25.940 --> 00:30.980
이제 각 제품의 베스트셀러 순위를 살펴볼게요

00:31.190 --> 00:36.110
그래서 특징을 기준으로 베스트셀러 순위를 모을 거예요

00:36.230 --> 00:44.570
그리고 돌아오는 건 사실 사전이에요 아마존 제품 하나가 여러 베스트셀러

00:44.570 --> 00:48.860
목록과 순위를 매길 수 있거든요

00:49.010 --> 00:53.600
그래서 다시 한번 거칠고 준비된 걸 해볼게요

00:53.600 --> 00:59.090
여러 베스트셀러 목록에 속성들이 있다면 평균을 선택해서 한 목록에서 1위 다른

00:59.090 --> 01:03.350
목록에서 10,000위인 경우 중간 지점을 선택할게요

01:03.380 --> 01:07.460
5천 마크에 해당하는 걸 가져갈 거예요

01:07.760 --> 01:14.540
비트 박스는 추측일 뿐이에요

01:14.630 --> 01:16.190
비트 박스는 시행착오를 거치죠

01:16.190 --> 01:19.670
전통적인 데이터 과학은 사실 비트 박스와 비슷해요

01:19.670 --> 01:23.270
현대 데이터 과학도 마찬가지죠

01:23.270 --> 01:25.250
시행착오가 많아요

01:25.280 --> 01:29.750
일반적으로 이런 기술로 하는 건 많은 기능을 시도해보는 거죠

01:29.750 --> 01:33.980
평균을 택하거나 최고를 택하거나 다른 걸 택할 수도 있죠

01:33.980 --> 01:37.640
이 모든 기능을 밀어 넣으면 어떤 게 이기는지 알 수 있죠

01:37.670 --> 01:39.920
이 경우엔 평균을 선택할게요

01:39.920 --> 01:45.380
하지만 배짱이 있고 이 과정이 즐겁다면... 이렇게 여기저기 파헤치는

01:45.380 --> 01:48.560
게 좀 별로라면 다른 것도 해 보세요

01:48.560 --> 01:55.370
최저 계급이든 최대 계급이든 원하는 걸 추가해 보세요 가장 신호가 강한 게

01:55.370 --> 01:56.720
뭔지 보게요

01:57.110 --> 01:59.600
그래서 저희는 평균 등급을 뽑았어요

01:59.600 --> 02:00.740
그냥 하는 거예요

02:00.740 --> 02:05.360
추로 했던 것과 같은 기술을 할 거예요

02:05.360 --> 02:11.490
평균 등급을 계산해 볼게요 380,000명이라는 다소

02:11.490 --> 02:14.520
신기한 숫자가 나왔네요

02:14.520 --> 02:21.240
그런 다음 기본 함수로 get-rance를 줍니다 기본 함수는 랭크를 얻으려 하죠

02:21.240 --> 02:26.220
순위가 없는 것들은 평균을 줍니다. 훈련 데이터에서 평균 순위를

02:26.220 --> 02:27.180
주죠.

02:27.390 --> 02:28.230
네

02:28.230 --> 02:32.490
전에 말씀드리지 않은 기능이 하나 더 있어요

02:32.580 --> 02:39.540
추측하셨을 수도 있는데 모든 세부 사항이 담긴 테스트 프롬프트가 얼마나 긴지

02:39.540 --> 02:41.310
여쭤보려고요

02:41.340 --> 02:46.980
기억하실지 모르겠지만 며칠 전에 했던 분산도표가 있는데 빨간

02:47.010 --> 02:53.490
점이 많이 있는 그 도표는 가격과 텍스트의 양 사이에 상관관계가 있는지

02:53.490 --> 02:56.130
알아보려고 했었죠

02:56.130 --> 03:00.390
시각적으로 봤을 때 약간의 상관관계가 있는 것 같았어요

03:00.420 --> 03:02.070
제가 올렸을 거예요

03:02.070 --> 03:06.350
잠깐 살펴보면 이런, 이제 없네요

03:06.380 --> 03:07.700
다 치웠어요

03:07.700 --> 03:10.370
당신이 운영하면 당신이 돌아봐야 할 거예요

03:10.580 --> 03:15.590
다시 돌아가서 빨간 도표를 보면 무슨 뜻인지 알 거예요

03:15.710 --> 03:17.690
약간 상관관계가 있어요

03:17.690 --> 03:19.820
이걸 추가하죠

03:19.850 --> 03:23.630
텍스트 길이 get get 그것도 사용하죠

03:24.320 --> 03:27.740
마지막은 브랜드를 볼 거예요

03:28.130 --> 03:31.940
가장 흔한 40가지 브랜드부터 살펴보죠

03:31.940 --> 03:34.730
아까와 같은 접근 방법으로 모두 세어볼게요

03:34.760 --> 03:39.500
가장 흔한 브랜드 40개요

03:40.820 --> 03:43.280
가장 흔한 40가지 브랜드를 보죠

03:43.280 --> 03:44.510
여기 있네요

03:45.080 --> 03:53.120
여기 보시면 자동차 관련 브랜드가 몇 개 있는데 제가 잘 모르는 것들이에요

03:53.120 --> 03:54.500
저보다 더 잘 아실지도 몰라요

03:54.500 --> 03:54.920
그러세요

03:54.950 --> 03:56.180
제가 뭘 놓쳤다고 생각하시겠죠

03:56.210 --> 04:01.370
최고의 자동차 브랜드에서 볼 수 있는 멋진 기능이 있다고 할 수도 있죠 그런

04:01.370 --> 04:05.630
경우 해당 기능을 만들어 추가하고 어떻게 하는지 보세요

04:05.780 --> 04:09.020
안타깝게도 전 그런 분야는 잘 몰라요

04:09.170 --> 04:15.920
그래서 제가 고른 건 일류 전자 제품 브랜드예요 HP,

04:15.920 --> 04:22.070
델, 레노버 삼성, 소니, 캐논, 애플 같은 제품을

04:22.070 --> 04:25.700
이 카테고리에 넣은 거죠

04:25.700 --> 04:29.660
그럼 톱 일렉트로닉스 브랜드의 기능이 생기죠

04:29.660 --> 04:32.630
이건 제가 한 가지 기능을 끝낸 거예요

04:32.630 --> 04:34.640
여러 가지 기능을 생각해낼 수 있어요

04:34.640 --> 04:36.800
여러 가지 브랜드를 고를 수 있어요

04:36.800 --> 04:38.780
자동차 브랜드를 골라요

04:38.780 --> 04:41.390
원하는 만큼 많은 기능을 만들 수 있어요

04:41.390 --> 04:46.820
기능이 더 있다고 나쁠 건 없어요 회귀 모델이 어떤 기능이 신호를

04:46.820 --> 04:49.100
주는지 결정하거든요

04:49.280 --> 04:55.640
재미있는 대회는 기능을 생성하고 수공예 기능을 얼마나 잘 만드는지 보는

04:55.640 --> 04:56.480
거예요

04:56.600 --> 05:00.500
아까 중요한 걸 하나 더 말씀드릴게요

05:00.500 --> 05:06.650
자동차 전문가가 아니니 자동차 브랜드를 고를 수 없죠

05:06.650 --> 05:11.450
여기서 흥미로운 점이 등장하는데 전통적인 데이터 과학에서는

05:11.450 --> 05:18.050
데이터 과학자가 자신이 연구하는 분야에 대해 어느 정도 아는 게 중요했어요

05:18.080 --> 05:22.580
제품을 다루는 일을 한다면 다양한 제품을 이해해야 해요

05:22.580 --> 05:26.870
여러 자동차 제조사를 이해해야 했어요 어떤 기능을 설계해야

05:26.870 --> 05:30.290
성공 확률이 가장 높을지 알아야 했으니까요

05:30.320 --> 05:39.260
현대 딥 뉴런네트워크와 머신 러닝 딥 러닝이 가진 신기하고 놀라운 점은

05:39.260 --> 05:46.070
물질을 포함한 모델이 스스로 만들어 낸다는 거예요

05:46.070 --> 05:52.820
따라서 여러분이나 저 같은 데이터 과학자가 모델을 구축하는 분야에서 딥 도메인 전문성을

05:52.820 --> 05:57.260
가질 필요가 더는 없습니다 llms와 모델을 구축하는

05:57.290 --> 06:02.420
방법과 심층 신경망 구축에 관한 전문성이 있어야 하니까요

06:02.420 --> 06:10.670
수십억 개의 매개 변수를 가지고 있고 그 모든 매개 변수의 힘을 이용해서

06:10.700 --> 06:14.540
비즈니스 분야를 배울 수 있죠

06:14.540 --> 06:19.250
하지만 과거 피처링 엔지니어링에서는 스스로를 이해해야 했고 톱 전자

06:19.280 --> 06:22.880
공학이나 브랜드 같은 기능을 만들어야 했어요

06:22.880 --> 06:26.120
이 모든 게 이 함수로 연결돼요

06:26.150 --> 06:27.710
get 피처링이요

06:27.740 --> 06:35.120
항목을 하나 골라 멋진 사전을 만듭니다 중량, 순위, 텍스트 길이

06:35.120 --> 06:40.220
1이나 0으로 된 톱 전자 제품 브랜드가 있죠

06:40.490 --> 06:48.650
이게 첫 번째 모델의 특징 그룹이에요

06:48.650 --> 06:50.660
우리가 만드는 첫 번째 모형이죠

06:50.660 --> 06:59.510
그리고 부디 시간을 들여 이걸 꿈의 형태로 바꿔 보세요

06:59.510 --> 07:02.150
엔지니어링 기능으로 얼마나 잘할지 보는 거죠

07:02.150 --> 07:03.830
잘할 수 있을 거예요

07:03.950 --> 07:06.890
하지만 앞으로의 일에 비하면 상대도 안 될 거예요

07:06.890 --> 07:08.180
그래도 한번 해 봐요

07:08.390 --> 07:08.600
지금요

07:08.600 --> 07:10.190
최선을 다해 봐요

07:10.190 --> 07:14.630
하지만 이다음에 나오는 다음 영상에서는 실제로 달릴 거예요

07:14.630 --> 07:19.760
전통적인 머신 러닝 모델을 실행해 보고 결과를 보죠

07:19.760 --> 07:20.990
그때 봐요
