WEBVTT

00:00.740 --> 00:01.670
お帰りなさい｡ 

00:01.670 --> 00:07.070
だから私たちは､ フィーチャー・エンジニアリングという､ 徹底的に不愉快で不愉快な仕事をしてきた｡ 

00:07.070 --> 00:09.110
とてもグロテスクな､ あー､ 仕事だ｡ 

00:09.110 --> 00:11.990
でも､ 正直言って､ 今でもちょっと楽しいんだ｡ 

00:11.990 --> 00:17.360
しかし､ それはかなり､ かなり､ かなり､ かなり､ 厄介で､ データに深く入り込む必要がある｡ 

00:17.360 --> 00:25.730
データセットに含まれるアイテムの重みを計算し､ 重みがわからない場合は平均的な重みを入力する｡

00:25.940 --> 00:30.980
それでは､ 各アイテムのベストセラーランキングを見ていきましょう｡ 

00:31.190 --> 00:36.110
そこで､ その特徴からベストセラーランキングを集めてみようと思う｡ 

00:36.230 --> 00:48.860
アマゾンの商品は複数のベストセラーリストにランクインすることができるからだ｡

00:49.010 --> 00:53.600
ええと､ それで､ また何かやろうと思っているんだ､ とてもラフで準備万端なんだけどね｡ 

00:53.600 --> 00:59.090
また､ 複数のベストセラーリストに掲載されている場合､ あるリストで1位､ 別のリストで10,000位にランクインしている場合は､

00:59.090 --> 01:03.350
その平均を取るだけである｡

01:03.380 --> 01:07.460
私たちは､ 5000ドル付近のものを取るつもりだ｡ 

01:07.760 --> 01:14.540
ええと､ だから､ これは......ええと､ すべてちょっとした推測なんだ｡ 

01:14.630 --> 01:16.190
試行錯誤の繰り返しだよ｡ 

01:16.190 --> 01:19.670
伝統的なデータサイエンスは､ 実はこのようなものなのだ｡ 

01:19.670 --> 01:23.270
これからわかるように､ 現代のデータサイエンスも同様である｡ 

01:23.270 --> 01:25.250
試行錯誤はいくらでもある｡ 

01:25.280 --> 01:29.750
通常､ このようなテクニックで行うのは､ たくさんの機能を試すことだ｡ 

01:29.750 --> 01:33.980
平均をとってみてもいいし､ ベストをとってみてもいい｡ 

01:33.980 --> 01:37.640
そして､ これらの機能をすべて押し込んで､ どれが勝つかを見るんだ｡ 

01:37.670 --> 01:39.920
さて､ 今回は平均値を選ぶことにする｡ 

01:39.920 --> 01:45.380
しかし､ もしあなたにその気概があり､ この､ 私が言うのもなんだが､ 機能を掘り下げるという少し嫌な作業を楽しんでいるのであれば､

01:45.380 --> 01:48.560
さらにいくつかの機能を試してみてほしい｡

01:48.560 --> 01:56.720
最低ランクでも最高ランクでも､ 好きなものを入れてみて､ 何が一番シグナルになるか試してみてください｡

01:57.110 --> 01:59.600
だから､ 私たちの場合は平均順位を選んだ｡ 

01:59.600 --> 02:00.740
ただやるだけだ｡ 

02:00.740 --> 02:05.360
そして､ ウエイトでやったのと同じトリックをやるんだ｡ 

02:05.360 --> 02:14.520
平均ランクの平均を調べることになるが､ 38万人というちょっと不思議な数字になった｡

02:14.520 --> 02:21.240
そして､ ランクを取得しようとするデフォルト関数でランクを取得する｡ 

02:21.240 --> 02:27.180
もしランクがない場合は､ トレーニング・データ・セットの平均ランクが表示される｡

02:27.390 --> 02:28.230
オーケー｡ 

02:28.230 --> 02:32.490
そしてもうひとつ､ これまで触れなかった機能をミックスに加えようと思う｡ 

02:32.580 --> 02:41.310
ええと､ お察しかもしれませんが､ テストプロンプトの長さはどのくらいですか？

02:41.340 --> 02:46.980
覚えていらっしゃるかどうか分かりませんが､ 2､

02:47.010 --> 02:56.130
3日前､ あるいはほんの1日前､ 赤い点がたくさん並んだ散布図がありました｡

02:56.130 --> 03:00.390
そして､ それを視覚的に見ると､ わずかながら相関関係があるように見えた｡ 

03:00.420 --> 03:02.070
たぶん､ 私が立てたんだと思う｡ 

03:02.070 --> 03:06.350
それをちょっと覗いて､ ああ､ もうないんだ､ と確認すればいい｡ 

03:06.380 --> 03:07.700
もう片付けたよ｡ 

03:07.700 --> 03:10.370
走ったのなら､ 自分で振り返ってみなければならない｡ 

03:10.580 --> 03:15.590
もう一度､ あの赤い図を見てもらえれば､ 私の言っている意味がわかると思う｡ 

03:15.710 --> 03:17.690
そこには若干の相関関係がある｡ 

03:17.690 --> 03:19.820
だから､ それを加えよう｡ 

03:19.850 --> 03:23.630
テキストの長さを取得しよう｡ 

03:24.320 --> 03:27.740
そして最後はブランドについて｡ 

03:28.130 --> 03:31.940
まず､ 最も一般的な40銘柄を見てみよう｡ 

03:31.940 --> 03:34.730
だから､ 前と同じやり方で､ すべてを数え上げる｡ 

03:34.760 --> 03:39.500
最も一般的な40のブランド｡ 

03:40.820 --> 03:43.280
最も一般的な40ブランドを見てみよう｡ 

03:43.280 --> 03:44.510
それがこれだ｡ 

03:45.080 --> 03:53.120
そして､ ここでお気づきになるのは､ 私はあまり知識がないのですが､ 自動車関連のブランドがいくつかあることです｡

03:53.120 --> 03:54.500
あなたの方が詳しいかもしれない｡ 

03:54.500 --> 03:54.920
そうかもしれない｡ 

03:54.950 --> 03:56.180
あなたは私がトリックを見逃していると思うかもしれない｡ 

03:56.210 --> 04:01.370
その場合は､ その機能を作って追加し､

04:01.370 --> 04:05.630
どうなるか見てみるべきだ｡

04:05.780 --> 04:09.020
残念ながら､ 私にはその分野の専門知識はないんだ｡ 

04:09.170 --> 04:15.920
トップ・エレクトロニクス・ブランドと呼ばれる小さなカテゴリーに､ HP､ デル､ レノボ､

04:15.920 --> 04:25.700
サムスン､ アスース､ ソニー､ キャノン､ アップル､ インテルなど､ ここから抜き出したものをこのカテゴリーに押し込んだ｡

04:25.700 --> 04:29.660
そして､ トップ・エレクトロニクス・ブランドという特徴を教えてくれた｡ 

04:29.660 --> 04:32.630
そして､ これはまた私が1つの特集を組んだものだ｡ 

04:32.630 --> 04:34.640
たくさんの機能を思いつくことができるだろう｡ 

04:34.640 --> 04:36.800
いろいろなブランドを選ぶことができる｡ 

04:36.800 --> 04:38.780
いくつかの自動車ブランドを選ぶことができる｡ 

04:38.780 --> 04:41.390
好きなだけ機能を作ることができる｡ 

04:41.390 --> 04:49.100
回帰モデルは､ どの特徴が実際にシグナルを与えるかを決定するからだ｡

04:49.280 --> 04:56.480
だから､ あなたにとって楽しい競争は､ 機能を生み出し､ 手作りの機能でどれだけうまくやれるかを見ることだ｡

04:56.600 --> 05:00.500
もう1つ､ 先ほど述べた重要な観察をしておこう｡ 

05:00.500 --> 05:06.650
私は車の専門知識がないので､ 自動車ブランドを抜き出すことはできない｡ 

05:06.650 --> 05:11.450
つまり､ この種の伝統的なデータサイエンスでは､ データサイエンティストは､

05:11.450 --> 05:18.050
自分たちが研究している領域について強い知識を持っていることが重要だったのだ｡

05:18.080 --> 05:22.580
製品に携わるのであれば､ さまざまな製品について理解する必要がある｡ 

05:22.580 --> 05:30.290
さまざまな自動車メーカーについて理解する必要があったし､ 成功する可能性が最も高いのはどの機能をエンジニアリングすればよいかを知る必要があったからだ｡

05:30.320 --> 05:39.260
ディープ・ニューラル・ネットワークや最新の機械学習､ 最新のディープ・ラーニングの不思議で驚くべき点は､

05:39.260 --> 05:46.070
どの特徴が重要かをモデルが自ら見つけ出すことだ｡

05:46.070 --> 05:52.820
そのため､ あなたや私のようなデータサイエンティストには､

05:52.820 --> 06:02.420
モデルを構築していた分野の深い専門知識が必要ではなくなりました｡

06:02.420 --> 06:14.540
そして､ 彼らは何十億ものパラメーターを持っており､ そのすべてのパラメーターの理解力を使ってビジネスエリアについて学ぶことができる｡

06:14.540 --> 06:22.880
しかし､ その昔､ フィーチャー・エンジニアリングでは､ 自分自身でそれを理解し､ トップエレクトロニクスやブランド機能のようなものを作らなければならなかった｡

06:22.880 --> 06:26.120
そして､ そのすべてがこの機能へとつながっている｡ 

06:26.150 --> 06:27.710
特徴をつかめ｡ 

06:27.740 --> 06:40.220
この辞書には､ 重さ､ ランク､ テキストの長さ､ そしてトップ・エレクトロニクス・ブランド（1か0）が入っている｡

06:40.490 --> 06:48.650
これが､ この最初のモデルの特徴だ｡ 

06:48.650 --> 06:50.660
私たちが作っている最初の本格的なモデルだ｡ 

06:50.660 --> 06:59.510
そして､ どうか､ これを夢の特集にするために時間を費やしてほしい｡ 

06:59.510 --> 07:02.150
ええと､ エンジニアリングの機能でどれだけうまくやれるか見てみよう｡ 

07:02.150 --> 07:03.830
そして､ おそらくかなりうまくやれるだろう｡ 

07:03.950 --> 07:06.890
うーん､ でも､ これから起こることにあなたが太刀打ちできるとは思えない｡ 

07:06.890 --> 07:08.180
しかし､ 試してみてほしい｡ 

07:08.390 --> 07:08.600
今すぐだ｡ 

07:08.600 --> 07:10.190
ベストを尽くせ｡ 

07:10.190 --> 07:14.630
でもこの後､ 次のビデオでは実際に走るんだ｡ 

07:14.630 --> 07:19.760
従来の機械学習モデルを実行し､ その結果を見る｡ 

07:19.760 --> 07:20.990
それではまた｡ 
