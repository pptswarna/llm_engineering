WEBVTT

00:00.410 --> 00:01.820
돌아오신 걸 환영해요

00:01.850 --> 00:08.660
GPT 40이 하드 파이썬 변환 문제를 멋지게 해결하지 못한 걸 보셨는데요

00:08.660 --> 00:12.980
이제 클로드가 같은 문제를 어떻게 해결하는지 보죠

00:12.980 --> 00:15.950
최적화 메서드를 실행해요

00:15.950 --> 00:18.740
클로드에게서 많은 걸 얻어요 Get up

00:18.740 --> 00:20.030
여기 있네요

00:20.660 --> 00:29.930
이제 clang 최적화된 메서드를 실행하겠습니다 컴파일하고 코드를 최적화하는 거죠 실행해

00:29.930 --> 00:31.850
어떻게 되는지 보죠

00:36.110 --> 00:37.370
계속 발전하고 있었어요

00:37.370 --> 00:40.280
많은 일이 있었어요

00:40.310 --> 00:45.320
긴 정지가 있었던 이유는 아직 코드 생성을 완료하지 않았기 때문입니다.

00:45.320 --> 00:49.670
반 정도 완료된 것을 보았습니다. 하지만 완료하고 컴파일하고

00:49.670 --> 00:52.610
실행해서 올바른 답을 얻었어요.

00:52.610 --> 00:56.570
정말 빠른 것 좀 보세요

00:56.570 --> 00:58.010
차이를 보세요

00:58.040 --> 01:02.990
클로드는 이 일뿐만 아니라 놀라울 정도로 잘했어요

01:02.990 --> 01:12.330
2밀리초입니다 파이썬 코드에서 파이썬 코드로 다시 이동하는 시간의

01:12.360 --> 01:14.640
2밀리초죠

01:14.880 --> 01:18.210
파이썬 으로 코드는 어디서 했었죠?

01:18.210 --> 01:18.630
시작할게요

01:18.660 --> 01:22.500
파이썬 + 코드는 27초 만에 같은 답을 얻죠

01:22.500 --> 01:30.510
get 27 계산기 좀 가져올게요 빨리 27이라고 되뇌어 봐야겠어요

01:33.300 --> 01:37.830
13,000배는 빨라요

01:37.830 --> 01:40.110
대단해요

01:40.110 --> 01:43.380
깜짝 놀라실 거예요

01:43.380 --> 01:47.730
GPT 4가 실패하지 않고 코드를 생성할 때도 있어요

01:47.730 --> 01:53.280
그렇게 되면 생성된 코드는 적어도 제 경우엔 더 빨라져요 하지만 10배나

01:53.280 --> 01:55.590
100배 더 빨라지죠

01:55.590 --> 01:57.030
클로드 같지 않아요

01:57.030 --> 02:01.020
클로드는 대체 어떻게 이걸 해냈을까요?

02:01.050 --> 02:05.490
어떻게 최적화된 코드를 만들 수 있었을까요?

02:05.490 --> 02:09.480
파이썬 을 잘못 사용하고 있는 건가요? 파이썬 을 잘못 사용하고 있는 게 분명합니다.

02:09.480 --> 02:12.000
아주 아주 빠르게 사용할 수 있다면요.

02:12.000 --> 02:15.450
아뇨, 비트가 좀 더 있어요

02:15.540 --> 02:20.610
클로드가 생성한 최적화된 코드를 보세요

02:20.730 --> 02:20.970
잠깐만요

02:20.970 --> 02:23.760
이걸 닫고 다시 더블 클릭해야 볼 수 있을 것 같아요

02:23.760 --> 02:24.690
시작할게요

02:25.080 --> 02:27.990
비트가 좀 더 있어요

02:27.990 --> 02:29.970
비트가 더 있어요

02:29.970 --> 02:31.590
무슨 일이죠?

02:31.620 --> 02:39.240
클로드에게 방향을 지시했을 때 같은 반응을 최대한

02:39.240 --> 02:44.520
빨리 만들어내라고 했어요

02:44.520 --> 02:48.510
프롬프트는 C++에서 다시 구현하라고 조심스럽게 말했죠

02:48.510 --> 02:51.240
클로드가 그렇게 했어요

02:51.240 --> 02:58.500
클로드는 놀랍게도 코드를 분석하고 그 의미를 이해했어요

02:58.710 --> 03:01.800
함수 이름에 힌트를 준 것 같아요

03:01.800 --> 03:05.310
함수 이름만 가지고 다 말씀하시진 마세요

03:05.310 --> 03:11.460
궤도에서 벗어나게 한 몇 가지 요소가 있었지만 완전히 다른

03:11.460 --> 03:18.990
방식으로 재설정했어요 섀넌의 알고리즘이라는 정리를 이용해서요

03:19.140 --> 03:20.520
그런 것 같아요

03:20.520 --> 03:22.890
네, 섀넌의 알고리즘이에요

03:23.070 --> 03:30.760
이 방법은 이 퍼즐을 한 번의 루프로 풀 수 있게 해줘요

03:30.760 --> 03:32.230
한 바퀴 돌아요

03:32.260 --> 03:33.820
죄송해요, 다른 루프에 있었네요

03:33.820 --> 03:34.570
이게 루프예요

03:34.570 --> 03:38.590
한 루프만 통과하면 돼요

03:38.650 --> 03:44.920
그 결과, 보시다시피 두 개가 나란히 놓여 있어요

03:44.920 --> 03:50.140
하지만 이건 중첩된 루프가 아니라 루프 안의 루프예요

03:50.170 --> 03:55.510
아주 짧은 시간 안에 get get에 도달할 수 있죠

03:55.510 --> 04:01.540
클로드가 한 것은 정말 기발합니다 함수의 의도를 이해했어요

04:01.540 --> 04:07.360
파이썬 을 동등한 C++ 코드로 번역한 게 아닙니다 취소했어요

04:07.360 --> 04:15.130
같은 답을 얻도록 프롬프트된 거죠 아주 짧은 시간 동안에요

04:15.130 --> 04:20.020
클로드가 정말 멋진 결과를 냈네요

04:20.080 --> 04:23.230
박수 한번 주세요

04:23.230 --> 04:26.800
씰 리더보드에서 본 것과 일치해요

04:26.800 --> 04:31.000
클로드 3세예요 5개의 소네트가 쇼를 지배하죠

04:31.000 --> 04:32.530
클로드가 이겼어요
