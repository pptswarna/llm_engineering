WEBVTT

00:00.410 --> 00:01.820
そしてお帰りなさい｡ 

00:01.850 --> 00:08.660
GPT4のゼロがハードPythonの変換問題で見事に失敗したのを見ただろう｡ 

00:08.660 --> 00:12.980
そして今度は､ クロードが同じ問題にどう対処するか見てみよう｡ 

00:12.980 --> 00:15.950
そこでオプティマイズ・メソッドを実行する｡ 

00:15.950 --> 00:18.740
クロードからたくさんのものを取り戻した｡ 

00:18.740 --> 00:20.030
これだ｡ 

00:20.660 --> 00:31.850
次に､ このコードをコンパイルして最適化するclang最適化メソッドを実行して､ 何が得られるか見てみよう｡

00:36.110 --> 00:37.370
ああ､ まだ発電していたんだ｡ 

00:37.370 --> 00:40.280
そこでいろいろなことが起こった｡ 

00:40.310 --> 00:52.610
長い間中断があったのは､ まだコードを生成し終えていなかったからだ｡

00:52.610 --> 00:56.570
その速さを見てほしい｡ 

00:56.570 --> 00:58.010
この違いを見てほしい｡ 

00:58.040 --> 01:02.990
クロードがやっただけでなく､ クロードは衝撃的なほどうまくやった｡ 

01:02.990 --> 01:14.640
Pythonのコードが再びPythonのコードに戻るまでの時間に比べれば､ 2ミリ秒､ 2ミリ秒であることにお気づきだろう｡

01:14.880 --> 01:18.210
Pythonのコードはどこでやったんだっけ？

01:18.210 --> 01:18.630
さあ､ 始めよう｡ 

01:18.660 --> 01:22.500
Pythonのコードは27秒で同じ答えを出した｡ 

01:22.500 --> 01:30.510
というわけで､ 手っ取り早く自分に27を伝えるために､ ここで電卓を手に入れる必要がありそうだ｡ 

01:33.300 --> 01:37.830
13,000倍も速いんだ｡ 

01:37.830 --> 01:40.110
すごい､ すごい｡ 

01:40.110 --> 01:43.380
だから､ あなたはそれに圧倒されるはずだ｡ 

01:43.380 --> 01:47.730
GPT4が失敗せず､ コードを生成できたこともある｡ 

01:47.730 --> 01:55.590
そうして生成されたコードは､ 少なくとも私にとっては､ 10倍か100倍速くなった｡

01:55.590 --> 01:57.030
クロードとは違う｡ 

01:57.030 --> 02:01.020
では､ クロードはいったいどうやってこんなことができたのか？

02:01.050 --> 02:05.490
どうやってこれほど最適化されたコードを作ったんだ？

02:05.490 --> 02:12.000
Pythonがこんなに速くなるのなら､ Pythonには何か問題があるに違いない｡

02:12.000 --> 02:15.450
いやいや､ この話にはもう少し続きがある｡ 

02:15.540 --> 02:20.610
クロードが生成した最適化されたコードを見てみよう｡ 

02:20.730 --> 02:20.970
ちょっと待て｡ 

02:20.970 --> 02:23.760
これを閉じて､ もう一度ダブルクリックしないと見られないと思う｡ 

02:23.760 --> 02:24.690
さあ､ 始めよう｡ 

02:25.080 --> 02:27.990
この話にはもう少し続きがあるんだ｡ 

02:27.990 --> 02:29.970
物語にはもう少し続きがある｡ 

02:29.970 --> 02:31.590
何が起こったのか？

02:31.620 --> 02:44.520
何が起こったかというと､ クロード､ つまり私たちがクロードに与えた指示は､ 可能な限り最速で同じ回答が得られるようにすることだった｡

02:44.520 --> 02:48.510
プロンプトには､ Cプラスプラスで再インプリメントするようにと注意書きがあった｡ 

02:48.510 --> 02:51.240
そして､ それこそがクロードが成し遂げたことなのだ｡ 

02:51.240 --> 02:58.500
クロードは驚くべきことに､ コードを分析し､ コードの意図を理解している｡ 

02:58.710 --> 03:01.800
ええと､ おそらく関数名でヒントがあるのでしょう｡ 

03:01.800 --> 03:05.310
でも､ 関数名ですべてを明かしてはいけない｡ 

03:05.310 --> 03:11.460
シャノンのアルゴリズムと呼ばれる定理を使って､

03:11.460 --> 03:18.990
まったく別のアプローチでこれを再実装したんだ｡

03:19.140 --> 03:20.520
その通りだと思う｡ 

03:20.520 --> 03:22.890
そう､ シャノンのアルゴリズムと呼ばれるものだ｡ 

03:23.070 --> 03:30.760
このパズルは､ 1つのループだけで解くことができるんだ｡ 

03:30.760 --> 03:32.230
1ループスルー｡ 

03:32.260 --> 03:33.820
あ､ ごめん､ ループを間違えた｡ 

03:33.820 --> 03:34.570
これがループだ｡ 

03:34.570 --> 03:38.590
ネストされたループではなく､ 1つのループスルー｡ 

03:38.650 --> 03:44.920
その結果､ 2本が並んでいるのがわかるだろう｡ 

03:44.920 --> 03:50.140
しかし､ これはネストされたループではなく､ ループの中のループだ｡ 

03:50.170 --> 03:55.510
そうすれば､ ほんのわずかな時間で答えにたどり着くことができる｡ 

03:55.510 --> 04:01.540
つまり､ クロードがやったことは､ とても独創的で､ 関数の意図を理解し､

04:01.540 --> 04:07.360
Pythonの何かを同等のC＋＋のコードに翻訳しただけでなく､

04:07.360 --> 04:15.130
同じ答えを得るために､ 促された通りに再実装したのだ｡

04:15.130 --> 04:20.020
だから､ クロードは素晴らしい､ 素晴らしい結果を残したと言える｡ 

04:20.080 --> 04:23.230
そして拍手喝采｡ 

04:23.230 --> 04:26.800
そしてそれは､ シールのリーダーボードから見たものと一致している｡ 

04:26.800 --> 04:31.000
クロード 3. 5ソネットは､ ショーを支配している｡ 

04:31.000 --> 04:32.530
クロードの勝ちだ｡ 
