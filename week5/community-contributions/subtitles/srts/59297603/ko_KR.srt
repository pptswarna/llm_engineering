WEBVTT

00:00.470 --> 00:05.930
LM 엔지니어링으로 다시 오신 걸 환영합니다 벡터와 만나는 날이죠

00:05.930 --> 00:08.570
벡터 얘기를 너무 오래 했네요

00:08.600 --> 00:11.390
오늘은 실제로 갖고 놀 거예요 get it get it

00:11.540 --> 00:18.380
곧 주피터 연구소에 가서 그 덩어리를 만들 거예요

00:18.380 --> 00:24.320
오픈AI 엠베딩을 이용해 텍스트 덩어리로부터 벡터를 생성합니다 앞서 말씀드린 인코딩

00:24.320 --> 00:25.100
모델이죠

00:25.130 --> 00:31.460
유명한 오픈 소스 벡터 데이터베이스에 벡터들을 저장할 겁니다 크로마라고 하죠

00:31.640 --> 00:36.440
그런 다음 벡터들이 뭘 나타내는지를 시각화하는 거죠 get it

00:36.530 --> 00:41.150
벡터를 계속 갖고 노는 연습이 될 거예요

00:41.270 --> 00:48.140
벡터에 여러분만의 것을 입력해 보세요 텍스트를 숫자로 바꾸어 의미를 갖는다는 게 어떤

00:48.140 --> 00:52.430
것인지 더 나은 감각을 갖게 될 거예요 Get it

00:52.610 --> 00:56.660
잠시 이런 다양한 모델 유형에 관해 얘기할게요

00:56.810 --> 00:58.970
텍스트를 벡터로 바꾸는 방법이요

00:58.970 --> 01:03.080
우선 아주 간단한 방법이 있어요

01:03.350 --> 01:07.160
예를 들어 어휘를 생각해 보라고 하는 거죠

01:07.160 --> 01:10.190
가능한 단어를 하나씩 생각해 봐요

01:10.190 --> 01:15.260
여러분이 아는 단어 중 첫 번째가 개고 두 번째가

01:15.260 --> 01:16.730
고양이예요

01:17.270 --> 01:23.360
텍스트 블록을 하나 골라서 그 안에 있는 특정 단어의 횟수를

01:23.360 --> 01:24.860
세는 거예요

01:24.860 --> 01:30.890
예를 들어 dog라는 단어가 두 번 들어갔다면 첫 번째 장소에 2를

01:30.890 --> 01:33.320
넣고 캣은 한 번 넣어요

01:33.320 --> 01:36.320
그런 다음 해당 위치에 Put을 하는 거죠

01:36.320 --> 01:43.010
특정 유형의 단어 수를 세서 벡터로 입력하는 거죠

01:43.010 --> 01:44.660
아주 단순하죠

01:44.660 --> 01:50.840
단어가 배치된 순서를 반영하지 못해요 같은 단어인 Java가 커피콩이나

01:50.840 --> 01:56.120
프로그래밍 언어를 참조할 수 없다는 사실도요

01:56.120 --> 01:59.090
단어 개수만 세면 돼요

01:59.420 --> 02:01.430
그러니 좀 단순하죠

02:01.430 --> 02:04.670
다행히 더 진보된 방법이 있죠

02:04.700 --> 02:11.510
주목을 받은 것 중 하나는 2013년에 워드 2벡이라는 것이 등장했을

02:11.600 --> 02:22.550
때입니다 심층 신경망을 이용해 단어를 벡터로 변환할 수 있었죠 그 의미를 반영하는 방식으로요

02:22.550 --> 02:28.550
우리는 단어 2개를 통해 이런 얘기를 하기 시작했어요 킹에서 남자를 빼면

02:28.550 --> 02:30.470
여자가 퀸이 되죠

02:30.830 --> 02:34.970
버트는 제가 전에 말했던 모델이에요

02:35.000 --> 02:41.690
이건 변압기 모델로 구글이 논문을 발표한 직후에 만든 부호화 모델입니다 트랜스포머

02:41.690 --> 02:43.700
발명이었죠

02:43.760 --> 02:48.440
우리가 사용할 OpenAI 엠디딩은 OpenAI에서 온 거예요

02:48.440 --> 02:52.610
가장 최근 버전은 2024년의 업데이트예요

02:52.640 --> 02:57.470
텍스트를 숫자 벡터로 변환하는 데 사용할 수 있는 가장

02:57.500 --> 03:00.680
최신의 가장 훌륭한 모델이죠

03:01.760 --> 03:07.160
그럼 이제 채도에 대해 빠르게 이야기해 보고 다시 보도록 하죠. Get in the Cream

03:07.160 --> 03:14.290
채도는 벡터 데이터 저장소의 한 예인데요

03:14.290 --> 03:21.220
꽤 많이 있고, 메인 데이터베이스도 벡터를 찾고 검색하는

03:21.220 --> 03:23.020
것을 지원하죠

03:23.140 --> 03:28.690
많은 사람들이 NoSQL 데이터 스토어로 사용하는 몽고DB의 예는 벡터를 취하고 벡터 데이터베이스로

03:28.690 --> 03:29.950
작용할 수 있어요

03:29.950 --> 03:33.700
크로머는 무엇보다도 벡터 데이터베이스였어요

03:33.790 --> 03:37.120
이게 그 웹사이트예요

03:37.150 --> 03:46.570
보시다시피 옛날 맥 인터페이스보다 사진이 더 잘 나와요

03:46.780 --> 03:52.030
I 응용 프로그램에서 쿼리를 할 수 있고 여러 벡터에서 데이터를 검색할

03:52.030 --> 03:56.380
수 있고 그 데이터를 입력한 프롬프트와 큐리에 넣는 거죠.

03:56.380 --> 04:01.150
저번에 보여드린 다이어그램의 좀 더 화려한 버전이에요

04:01.510 --> 04:03.730
이쪽은 크로머예요

04:03.760 --> 04:06.460
벡터를 저장하기 위해 사용할 것들이죠

04:06.460 --> 04:08.740
잡담은 충분히 한 것 같네요

04:08.770 --> 04:13.570
JupyterLab을 get 할 때입니다 벡터를 먼저 사용할 때죠

04:13.600 --> 04:14.350
거기서 봐요
