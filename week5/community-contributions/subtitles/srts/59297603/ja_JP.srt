WEBVTT

00:00.470 --> 00:05.930
そして､ ベクターに焦点を当てたこの日に､ LMエンジニアリングに戻ってこられたことを嬉しく思う｡ 

00:05.930 --> 00:08.570
最後に､ 私はずっとベクターについて話してきた｡ 

00:08.600 --> 00:11.390
今日は実際に彼らと遊ぶことができる｡ 

00:11.540 --> 00:18.380
近々Jupyter Labに入り､ チャンクを作成する予定だ｡ 

00:18.380 --> 00:25.100
私たちはOpenAIのエンベッディングを使って､ テキストの塊からベクトルを作っています｡

00:25.130 --> 00:31.460
これらのベクターは､ chromaという非常に人気のあるオープンソースのベクターデータベースに保存します｡ 

00:31.640 --> 00:36.440
そして､ そのベクトルを視覚化し､ それが何を表しているかを把握する｡ 

00:36.530 --> 00:41.150
そしてそれは､ ベクターで遊び続けるための練習になる｡ 

00:41.270 --> 00:48.140
自分の物事をベクトルに置き換えてみて､ テキストを数字の束に変えることで意味を持つということがどういうことなのかを､

00:48.140 --> 00:52.430
どんどん感じ取ってほしい｡

00:52.610 --> 00:56.660
そこで､ これらの異なるタイプのモデルについて少し話をしよう｡ 

00:56.810 --> 00:58.970
テキストをベクターに変換する方法｡ 

00:58.970 --> 01:03.080
だから､ まず第一に､ 非常に単純化された方法がある｡ 

01:03.350 --> 01:07.160
例えば､ ボキャブラリーを考え出すとかね｡ 

01:07.160 --> 01:10.190
そこで､ 可能性のある言葉のリストを考えてみよう｡ 

01:10.190 --> 01:16.730
例えば､ あなたのボキャブラリーの最初の単語がdogで､ 2番目の単語がcatだとしよう｡

01:17.270 --> 01:24.860
そして､ テキストのブロックを取り出して､ そのブロックの中にある特定の単語の回数を数えることができる｡

01:24.860 --> 01:30.890
そして､ 例えばdogという単語が2回入っていたら､ ベクトルの最初の位置に2を入れ､

01:30.890 --> 01:33.320
catは1回入れる｡

01:33.320 --> 01:36.320
そして､ その場所に1本､ といった具合だ｡ 

01:36.320 --> 01:43.010
つまり､ 特定のタイプの単語の数を数えて､ それをベクターに入れるだけなのだ｡

01:43.010 --> 01:44.660
それはとても単純なことだ｡ 

01:44.660 --> 01:50.840
単語が並べられた順番は反映されないし､ 例えば同じJavaという単語がコーヒー豆の一種を指すこともあれば､

01:50.840 --> 01:56.120
プログラミング言語を指すこともあるという事実も反映されない｡

01:56.120 --> 01:59.090
単語数のカウントだけだろう｡ 

01:59.420 --> 02:01.430
だから､ それはむしろ単純なことだ｡ 

02:01.430 --> 02:04.670
そして幸運なことに､ これにはもっと高度な方法がある｡ 

02:04.700 --> 02:11.510
注目されたもののひとつは､ 2013年に登場したワード・ツー・ベックと呼ばれるもので､

02:11.600 --> 02:22.550
ディープ・ニューラル・ネットワークを使って､ 単語の意味を反映するような形でベクトル変換を始めることができた｡

02:22.550 --> 02:30.470
そして､ 2人のベックという言葉をきっかけに､ 王＋男＋女＝女王というような話をするようになったんだ｡

02:30.830 --> 02:34.970
ええと､ バートは少し前に話したモデルだよ｡ 

02:35.000 --> 02:43.700
これは､ グーグルが論文『Inventing Transformers』を発表した直後に作成したエンコーディングのトランスフォーマーモデルだ｡

02:43.760 --> 02:48.440
今回使用するOpenAI embeddingsは､ OpenAIのものです｡ 

02:48.440 --> 02:52.610
そして最新バージョンは､ 2024年から更新されたものだ｡ 

02:52.640 --> 03:00.680
それで､ これがテキストを数字ベクトルに変換するために使う最新で最高のモデルになるんだ｡

03:01.760 --> 03:07.160
ということで､ クロマについて手短にお話させてください｡ 

03:07.160 --> 03:14.290
クロマはベクトル・データ・ストアの一例だ｡ 

03:14.290 --> 03:23.020
その数はかなり多く､ 主要なデータベースの多くも､ 現在ではベクターの採取やベクターでの検索をサポートしている｡

03:23.140 --> 03:29.950
多くの人がNoSQLデータストアとして使っているMongoDBの例では､ ベクトルも扱うことができ､ ベクトルデータベースとして機能する｡

03:29.950 --> 03:33.700
しかし､ クロマーは何よりもまずベクター・データベースのようなものだった｡ 

03:33.790 --> 03:37.120
そしてこれがそのウェブサイトだ｡ 

03:37.150 --> 03:46.570
それに､ 昔ながらのマックのインターフェイスで撮った写真よりもいい写真が撮れるんだ｡

03:46.780 --> 03:52.030
でも､ Iアプリケーションでクエリーを実行すれば､ たくさんのベクターから検索することができ､

03:52.030 --> 03:56.380
検索されたデータはプロンプトとクエリーに入力されます｡

03:56.380 --> 04:01.150
つまり､ 前回お見せした図のファンシー・バージョンというわけだ｡ 

04:01.510 --> 04:03.730
ええと､ クロマーです｡ 

04:03.760 --> 04:06.460
これをベクターの保存に使う｡ 

04:06.460 --> 04:08.740
雑談はもう十分だろう｡ 

04:08.770 --> 04:13.570
JupyterLabを手に入れ､ ベクターを実際に使う時が来たのだ｡ 

04:13.600 --> 04:14.350
そこで会おう
