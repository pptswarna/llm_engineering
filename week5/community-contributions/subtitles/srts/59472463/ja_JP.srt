WEBVTT

00:00.800 --> 00:06.560
前回は､ 素性工学を使った地味な線形回帰モデルを見てきたが､

00:06.560 --> 00:12.080
今回は素性に別れを告げて､ 自然言語処理に取りかかる｡

00:12.080 --> 00:21.110
そして､ 前に少し触れた「言葉の袋」と呼ばれる､ かなり単純化されたタイプのNLPから始めます｡

00:21.140 --> 00:24.950
だから､ まずはこの2つのとても便利なものを作ることから始めよう｡ 

00:24.950 --> 00:33.920
1つはprice､ もう1つはdocumentsと呼ばれ､ priceはトレーニングデータセットに含まれるすべての価格のリスト､

00:33.920 --> 00:42.020
documentsはトレーニングデータセットに含まれるすべてのテストプロンプトである｡

00:42.230 --> 00:47.480
私たちがこれからやろうとしているのは､ 私たち自身で設計した特徴を使うのではなく､

00:47.480 --> 00:51.440
文書中のテキストを使ったモデルを構築することです｡

00:51.440 --> 00:52.940
テキストを使うだけでいい｡ 

00:53.330 --> 01:01.440
そうそう､ ここでひとつ､ ちょっとしたトリックにお気づきかもしれないが､ 私はトレーニング用のプロンプトではなく､ テスト用のプロンプトを使っている｡

01:01.590 --> 01:06.000
トレーニング・プロンプトを使えば､ トレーニング・プロンプトに価格が含まれることになる｡ 

01:06.120 --> 01:13.470
というのも､ そうすれば当然､ モデルは価格そのものが実際にプロンプトの中にあることを見抜くことを学習してしまうからだ｡

01:13.470 --> 01:16.470
そしてテストになると､ かなり惨めに失敗する｡ 

01:16.470 --> 01:20.220
だから､ これは気をつけるべきちょっとしたトリックなんだ｡ 

01:20.460 --> 01:22.980
うーん､ 罠には気をつけたいね｡ 

01:22.980 --> 01:25.710
だからそれを準備する｡ 

01:25.710 --> 01:31.770
これからカウントベクタライザーと呼ばれるものを使う｡ 

01:31.800 --> 01:36.330
今日､ ベクターライザーのカウントで仕事をしようと思うと､ 高度に洗練されたものを作ろうとしているように聞こえるが､

01:36.330 --> 01:41.850
残念ながら洗練されていない｡

01:41.940 --> 01:49.740
この機能は､ 単純に単語の数を数え､ ベクトルを構築する｡ ベクトル内の各位置が特定の単語を表し､

01:49.740 --> 01:59.420
その単語が文書内に何回現れるかを示す｡

01:59.540 --> 02:06.110
つまり､ 各文書はベクトルとなり､ そのベクトルの各行が語彙の単語を表す｡ 

02:06.110 --> 02:09.170
そして､ カウンターはその回数をカウントする｡ 

02:09.170 --> 02:15.050
このような物事の考え方は､ バッグ・オブ・ワード・モデルとして知られている｡

02:15.050 --> 02:23.840
バッグの中に単語が入っていて､ それを数え上げるようなものだ｡

02:24.170 --> 02:31.700
それで､ 最も一般的な､ あるいは最も重要な単語を1000まで数えるんだ｡

02:31.700 --> 02:41.150
そして､ このパラメータを使って､ 一般的なストップワード（andやthe､ inやitのような､

02:41.150 --> 02:49.820
モデルにとって役に立たず､ 邪魔にしかならないもの）のみを削除するようにします｡

02:49.820 --> 02:54.320
そうして､ 彼らは私たちにジューシーな言葉を残したまま､ 引き抜かれてしまうのだ｡ 

02:54.320 --> 03:00.000
そして､ これからやることは......ああ､ 今見てもらえばわかると思うけど､ 僕らはもっと早くやるんだ｡ 

03:00.000 --> 03:05.340
これらの文書に基づいてデータセットを作成します｡ 

03:05.340 --> 03:09.240
前回と同じように､ 線形回帰モデルを作成します｡ 

03:09.270 --> 03:14.610
そして､ 私たちは言葉のバッグを､ うーん､ 私たちの価格に合わせるつもりだ｡ 

03:14.610 --> 03:21.090
言い換えれば､ 今回は特徴量を使う代わりに､ この単語の袋､ つまり､ 最も一般的な辞書の語彙に含まれる1000の単語について､

03:21.090 --> 03:32.850
それぞれの単語の数をカウントするベクトルで特徴量を置き換えるのだ｡

03:32.880 --> 03:34.650
だから､ そうするつもりだ｡ 

03:34.680 --> 03:36.480
線形回帰を実行する｡ 

03:36.480 --> 03:37.980
今まさに起きていることだ｡ 

03:37.980 --> 03:46.110
データセット全体の1000のベクトルポイントをカウントアップしている｡ 

03:46.440 --> 03:54.180
そうしたら､ それを線形回帰､ プライサーという言葉の袋に入れるんだ｡

03:54.180 --> 03:58.130
そして､ それをテストするつもりなので､ もう一度テストする｡ 

03:58.160 --> 03:59.660
走り終えたばかりだ｡ 

03:59.690 --> 04:08.570
ええと､ これが私たちの関数で､ 単純な関数で､ tester dot testでテストしてみます｡

04:09.320 --> 04:10.790
言葉の袋｡ 

04:10.820 --> 04:13.520
線形回帰 プライサー

04:16.010 --> 04:17.630
どうなるか見てみよう｡ 

04:19.550 --> 04:21.050
緑がたくさんあるね｡ 

04:21.050 --> 04:22.730
だが､ 赤も多い｡ 

04:23.300 --> 04:23.960
分かるだろう｡ 

04:23.990 --> 04:25.340
ひとつだけ抜こう｡ 

04:25.370 --> 04:27.140
客は74ドル｡ 

04:27.140 --> 04:29.030
そして､ 実際には46ドルだった｡ 

04:29.030 --> 04:31.640
だから､ 正しいことをやっているのがわかる｡ 

04:31.640 --> 04:33.530
また､ 大きくずれていることもある｡ 

04:33.560 --> 04:35.540
グラフはどうなると思う？

04:35.570 --> 04:36.830
見てみよう｡ 

04:37.430 --> 04:39.350
オーケー､ オーケー｡ 

04:39.350 --> 04:42.680
まあ､ 何かいいことが起こりそうな雰囲気はある｡ 

04:42.680 --> 04:46.130
ライン周辺に収束しつつあるのが見え始めている｡ 

04:46.130 --> 04:48.080
緑の点が多くなってきた｡ 

04:48.080 --> 04:51.140
平均は113ドル｡ 

04:51.140 --> 04:59.310
つまり､ 特徴量を使った線形回帰よりも､ 推測よりも明らかに優れているのだ｡ 

04:59.670 --> 05:01.980
それで､ 進展があったんだ｡ 

05:01.980 --> 05:05.760
ここにはまだ奇妙な異常値やいくつかの問題がある｡ 

05:06.000 --> 05:10.860
うーん､ でも､ これが本当の価値で､ どこかに書いてあるはずなんだ｡ 

05:11.160 --> 05:15.810
うーん､ でも前進しているのは見てわかるだろう｡ 

05:16.200 --> 05:24.540
では次に､ より高度なモデルに入る前のこのセットの最後として､ 素晴らしいGensimライブラリを使って､

05:24.540 --> 05:31.560
このvecモデルという言葉を紹介しよう｡

05:31.560 --> 05:37.050
それは､ 私がNLPで､ ベクトル化モデルを使って､ より洗練されたベクトル埋め込みモデルを使って､

05:37.410 --> 05:46.440
ニューラルネットワークに出会った最初の時だった｡

05:46.500 --> 05:57.980
Gensimの2つのvec関数クラスを使い､ 400次元のベクトルを作る｡

05:58.250 --> 06:02.960
そして､ 8人のワーカーを使うように設定している｡ 

06:02.960 --> 06:08.840
これでも実行には数分かかったが､ 事前に実行しておいたので､ このために待たされることはなかった｡

06:08.870 --> 06:24.410
そして､ これを実行した｡ うまくいけば､ これを実行するだけで､ すぐにテスター・ドット・テストの結果を見ることができるはずだ｡

06:25.160 --> 06:36.140
2つのvec線形回帰プライサーという単語を渡して､ この空想的なベクトル化モデルが線形回帰でどのように機能するかを見ることができるはずだ｡

06:37.070 --> 06:39.950
まあ､ 最初の2行を見る限りは良さそうだが､ いやはや｡ 

06:39.980 --> 06:49.290
赤､ 緑､ 赤､ 緑､ 赤がたくさんあって､ 250のテストデータポイントを通り越してチャートにすとんと落ちる｡

06:50.100 --> 06:52.080
だから､ ここにある｡ 

06:52.110 --> 06:54.150
今回もかなりまともに見える｡ 

06:54.180 --> 07:03.540
興味深いことに､ 悪いニュースとしては､ 単純な単語袋モデルに基づく線形回帰よりも､ 実際は少し悪いということだ｡

07:03.540 --> 07:11.850
だから､ 2ヴェク・ベクターという素敵な言葉を披露しても､ まだ特に役には立っていない｡ 

07:11.850 --> 07:25.140
それは､ 線形回帰モデルが､ この2つのvecベクトルに含まれる余分な情報をすべて活用できるほど強力ではないからかもしれない｡

07:25.410 --> 07:34.890
次回は､ もう少し洗練されたモデルを探求し､ 伝統的な機械学習は終わりにしよう｡

07:34.890 --> 07:38.820
だから､ もう少し我慢してくれ｡ ここからもう少し汁を出したいんだ｡ 

07:38.850 --> 07:44.730
私たちは､ ベースラインモデルをもう少し良くしたい｡ LMSがこのようなことに簡単に走らないようにしたいからだ｡

07:44.730 --> 07:46.350
我々は戦いを挑みたい｡ 

07:46.350 --> 07:48.330
それではまた次回｡ 
